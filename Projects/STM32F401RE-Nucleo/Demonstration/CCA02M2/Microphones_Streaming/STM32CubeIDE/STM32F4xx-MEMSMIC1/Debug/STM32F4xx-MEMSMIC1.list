
STM32F4xx-MEMSMIC1.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000194  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0000989c  08000198  08000198  00010198  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000314  08009a34  08009a34  00019a34  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM          00000008  08009d48  08009d48  00019d48  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .init_array   00000004  08009d50  08009d50  00019d50  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .fini_array   00000004  08009d54  08009d54  00019d54  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .data         0000052c  20000000  08009d58  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .bss          000023c0  20000530  0800a284  00020530  2**3
                  ALLOC
  8 ._user_heap_stack 00004000  200028f0  0800a284  000228f0  2**0
                  ALLOC
  9 .ARM.attributes 0000002e  00000000  00000000  0002052c  2**0
                  CONTENTS, READONLY
 10 .debug_info   00020f82  00000000  00000000  0002055a  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 11 .debug_abbrev 000051d7  00000000  00000000  000414dc  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_loc    000196ab  00000000  00000000  000466b3  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_aranges 00001138  00000000  00000000  0005fd60  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_ranges 00002738  00000000  00000000  00060e98  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_macro  0001ccdf  00000000  00000000  000635d0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_line   00025e26  00000000  00000000  000802af  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_str    000a42c0  00000000  00000000  000a60d5  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .comment      00000144  00000000  00000000  0014a395  2**0
                  CONTENTS, READONLY
 19 .debug_frame  00003c10  00000000  00000000  0014a4dc  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

08000198 <__do_global_dtors_aux>:
 8000198:	b510      	push	{r4, lr}
 800019a:	4c05      	ldr	r4, [pc, #20]	; (80001b0 <__do_global_dtors_aux+0x18>)
 800019c:	7823      	ldrb	r3, [r4, #0]
 800019e:	b933      	cbnz	r3, 80001ae <__do_global_dtors_aux+0x16>
 80001a0:	4b04      	ldr	r3, [pc, #16]	; (80001b4 <__do_global_dtors_aux+0x1c>)
 80001a2:	b113      	cbz	r3, 80001aa <__do_global_dtors_aux+0x12>
 80001a4:	4804      	ldr	r0, [pc, #16]	; (80001b8 <__do_global_dtors_aux+0x20>)
 80001a6:	f3af 8000 	nop.w
 80001aa:	2301      	movs	r3, #1
 80001ac:	7023      	strb	r3, [r4, #0]
 80001ae:	bd10      	pop	{r4, pc}
 80001b0:	20000530 	.word	0x20000530
 80001b4:	00000000 	.word	0x00000000
 80001b8:	08009a1c 	.word	0x08009a1c

080001bc <frame_dummy>:
 80001bc:	b508      	push	{r3, lr}
 80001be:	4b03      	ldr	r3, [pc, #12]	; (80001cc <frame_dummy+0x10>)
 80001c0:	b11b      	cbz	r3, 80001ca <frame_dummy+0xe>
 80001c2:	4903      	ldr	r1, [pc, #12]	; (80001d0 <frame_dummy+0x14>)
 80001c4:	4803      	ldr	r0, [pc, #12]	; (80001d4 <frame_dummy+0x18>)
 80001c6:	f3af 8000 	nop.w
 80001ca:	bd08      	pop	{r3, pc}
 80001cc:	00000000 	.word	0x00000000
 80001d0:	20000534 	.word	0x20000534
 80001d4:	08009a1c 	.word	0x08009a1c

080001d8 <__aeabi_uldivmod>:
 80001d8:	b953      	cbnz	r3, 80001f0 <__aeabi_uldivmod+0x18>
 80001da:	b94a      	cbnz	r2, 80001f0 <__aeabi_uldivmod+0x18>
 80001dc:	2900      	cmp	r1, #0
 80001de:	bf08      	it	eq
 80001e0:	2800      	cmpeq	r0, #0
 80001e2:	bf1c      	itt	ne
 80001e4:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
 80001e8:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
 80001ec:	f000 b974 	b.w	80004d8 <__aeabi_idiv0>
 80001f0:	f1ad 0c08 	sub.w	ip, sp, #8
 80001f4:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 80001f8:	f000 f806 	bl	8000208 <__udivmoddi4>
 80001fc:	f8dd e004 	ldr.w	lr, [sp, #4]
 8000200:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8000204:	b004      	add	sp, #16
 8000206:	4770      	bx	lr

08000208 <__udivmoddi4>:
 8000208:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800020c:	9d08      	ldr	r5, [sp, #32]
 800020e:	4604      	mov	r4, r0
 8000210:	468e      	mov	lr, r1
 8000212:	2b00      	cmp	r3, #0
 8000214:	d14d      	bne.n	80002b2 <__udivmoddi4+0xaa>
 8000216:	428a      	cmp	r2, r1
 8000218:	4694      	mov	ip, r2
 800021a:	d969      	bls.n	80002f0 <__udivmoddi4+0xe8>
 800021c:	fab2 f282 	clz	r2, r2
 8000220:	b152      	cbz	r2, 8000238 <__udivmoddi4+0x30>
 8000222:	fa01 f302 	lsl.w	r3, r1, r2
 8000226:	f1c2 0120 	rsb	r1, r2, #32
 800022a:	fa20 f101 	lsr.w	r1, r0, r1
 800022e:	fa0c fc02 	lsl.w	ip, ip, r2
 8000232:	ea41 0e03 	orr.w	lr, r1, r3
 8000236:	4094      	lsls	r4, r2
 8000238:	ea4f 481c 	mov.w	r8, ip, lsr #16
 800023c:	0c21      	lsrs	r1, r4, #16
 800023e:	fbbe f6f8 	udiv	r6, lr, r8
 8000242:	fa1f f78c 	uxth.w	r7, ip
 8000246:	fb08 e316 	mls	r3, r8, r6, lr
 800024a:	ea41 4303 	orr.w	r3, r1, r3, lsl #16
 800024e:	fb06 f107 	mul.w	r1, r6, r7
 8000252:	4299      	cmp	r1, r3
 8000254:	d90a      	bls.n	800026c <__udivmoddi4+0x64>
 8000256:	eb1c 0303 	adds.w	r3, ip, r3
 800025a:	f106 30ff 	add.w	r0, r6, #4294967295	; 0xffffffff
 800025e:	f080 811f 	bcs.w	80004a0 <__udivmoddi4+0x298>
 8000262:	4299      	cmp	r1, r3
 8000264:	f240 811c 	bls.w	80004a0 <__udivmoddi4+0x298>
 8000268:	3e02      	subs	r6, #2
 800026a:	4463      	add	r3, ip
 800026c:	1a5b      	subs	r3, r3, r1
 800026e:	b2a4      	uxth	r4, r4
 8000270:	fbb3 f0f8 	udiv	r0, r3, r8
 8000274:	fb08 3310 	mls	r3, r8, r0, r3
 8000278:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
 800027c:	fb00 f707 	mul.w	r7, r0, r7
 8000280:	42a7      	cmp	r7, r4
 8000282:	d90a      	bls.n	800029a <__udivmoddi4+0x92>
 8000284:	eb1c 0404 	adds.w	r4, ip, r4
 8000288:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
 800028c:	f080 810a 	bcs.w	80004a4 <__udivmoddi4+0x29c>
 8000290:	42a7      	cmp	r7, r4
 8000292:	f240 8107 	bls.w	80004a4 <__udivmoddi4+0x29c>
 8000296:	4464      	add	r4, ip
 8000298:	3802      	subs	r0, #2
 800029a:	ea40 4006 	orr.w	r0, r0, r6, lsl #16
 800029e:	1be4      	subs	r4, r4, r7
 80002a0:	2600      	movs	r6, #0
 80002a2:	b11d      	cbz	r5, 80002ac <__udivmoddi4+0xa4>
 80002a4:	40d4      	lsrs	r4, r2
 80002a6:	2300      	movs	r3, #0
 80002a8:	e9c5 4300 	strd	r4, r3, [r5]
 80002ac:	4631      	mov	r1, r6
 80002ae:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80002b2:	428b      	cmp	r3, r1
 80002b4:	d909      	bls.n	80002ca <__udivmoddi4+0xc2>
 80002b6:	2d00      	cmp	r5, #0
 80002b8:	f000 80ef 	beq.w	800049a <__udivmoddi4+0x292>
 80002bc:	2600      	movs	r6, #0
 80002be:	e9c5 0100 	strd	r0, r1, [r5]
 80002c2:	4630      	mov	r0, r6
 80002c4:	4631      	mov	r1, r6
 80002c6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80002ca:	fab3 f683 	clz	r6, r3
 80002ce:	2e00      	cmp	r6, #0
 80002d0:	d14a      	bne.n	8000368 <__udivmoddi4+0x160>
 80002d2:	428b      	cmp	r3, r1
 80002d4:	d302      	bcc.n	80002dc <__udivmoddi4+0xd4>
 80002d6:	4282      	cmp	r2, r0
 80002d8:	f200 80f9 	bhi.w	80004ce <__udivmoddi4+0x2c6>
 80002dc:	1a84      	subs	r4, r0, r2
 80002de:	eb61 0303 	sbc.w	r3, r1, r3
 80002e2:	2001      	movs	r0, #1
 80002e4:	469e      	mov	lr, r3
 80002e6:	2d00      	cmp	r5, #0
 80002e8:	d0e0      	beq.n	80002ac <__udivmoddi4+0xa4>
 80002ea:	e9c5 4e00 	strd	r4, lr, [r5]
 80002ee:	e7dd      	b.n	80002ac <__udivmoddi4+0xa4>
 80002f0:	b902      	cbnz	r2, 80002f4 <__udivmoddi4+0xec>
 80002f2:	deff      	udf	#255	; 0xff
 80002f4:	fab2 f282 	clz	r2, r2
 80002f8:	2a00      	cmp	r2, #0
 80002fa:	f040 8092 	bne.w	8000422 <__udivmoddi4+0x21a>
 80002fe:	eba1 010c 	sub.w	r1, r1, ip
 8000302:	ea4f 471c 	mov.w	r7, ip, lsr #16
 8000306:	fa1f fe8c 	uxth.w	lr, ip
 800030a:	2601      	movs	r6, #1
 800030c:	0c20      	lsrs	r0, r4, #16
 800030e:	fbb1 f3f7 	udiv	r3, r1, r7
 8000312:	fb07 1113 	mls	r1, r7, r3, r1
 8000316:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
 800031a:	fb0e f003 	mul.w	r0, lr, r3
 800031e:	4288      	cmp	r0, r1
 8000320:	d908      	bls.n	8000334 <__udivmoddi4+0x12c>
 8000322:	eb1c 0101 	adds.w	r1, ip, r1
 8000326:	f103 38ff 	add.w	r8, r3, #4294967295	; 0xffffffff
 800032a:	d202      	bcs.n	8000332 <__udivmoddi4+0x12a>
 800032c:	4288      	cmp	r0, r1
 800032e:	f200 80cb 	bhi.w	80004c8 <__udivmoddi4+0x2c0>
 8000332:	4643      	mov	r3, r8
 8000334:	1a09      	subs	r1, r1, r0
 8000336:	b2a4      	uxth	r4, r4
 8000338:	fbb1 f0f7 	udiv	r0, r1, r7
 800033c:	fb07 1110 	mls	r1, r7, r0, r1
 8000340:	ea44 4401 	orr.w	r4, r4, r1, lsl #16
 8000344:	fb0e fe00 	mul.w	lr, lr, r0
 8000348:	45a6      	cmp	lr, r4
 800034a:	d908      	bls.n	800035e <__udivmoddi4+0x156>
 800034c:	eb1c 0404 	adds.w	r4, ip, r4
 8000350:	f100 31ff 	add.w	r1, r0, #4294967295	; 0xffffffff
 8000354:	d202      	bcs.n	800035c <__udivmoddi4+0x154>
 8000356:	45a6      	cmp	lr, r4
 8000358:	f200 80bb 	bhi.w	80004d2 <__udivmoddi4+0x2ca>
 800035c:	4608      	mov	r0, r1
 800035e:	eba4 040e 	sub.w	r4, r4, lr
 8000362:	ea40 4003 	orr.w	r0, r0, r3, lsl #16
 8000366:	e79c      	b.n	80002a2 <__udivmoddi4+0x9a>
 8000368:	f1c6 0720 	rsb	r7, r6, #32
 800036c:	40b3      	lsls	r3, r6
 800036e:	fa22 fc07 	lsr.w	ip, r2, r7
 8000372:	ea4c 0c03 	orr.w	ip, ip, r3
 8000376:	fa20 f407 	lsr.w	r4, r0, r7
 800037a:	fa01 f306 	lsl.w	r3, r1, r6
 800037e:	431c      	orrs	r4, r3
 8000380:	40f9      	lsrs	r1, r7
 8000382:	ea4f 491c 	mov.w	r9, ip, lsr #16
 8000386:	fa00 f306 	lsl.w	r3, r0, r6
 800038a:	fbb1 f8f9 	udiv	r8, r1, r9
 800038e:	0c20      	lsrs	r0, r4, #16
 8000390:	fa1f fe8c 	uxth.w	lr, ip
 8000394:	fb09 1118 	mls	r1, r9, r8, r1
 8000398:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
 800039c:	fb08 f00e 	mul.w	r0, r8, lr
 80003a0:	4288      	cmp	r0, r1
 80003a2:	fa02 f206 	lsl.w	r2, r2, r6
 80003a6:	d90b      	bls.n	80003c0 <__udivmoddi4+0x1b8>
 80003a8:	eb1c 0101 	adds.w	r1, ip, r1
 80003ac:	f108 3aff 	add.w	sl, r8, #4294967295	; 0xffffffff
 80003b0:	f080 8088 	bcs.w	80004c4 <__udivmoddi4+0x2bc>
 80003b4:	4288      	cmp	r0, r1
 80003b6:	f240 8085 	bls.w	80004c4 <__udivmoddi4+0x2bc>
 80003ba:	f1a8 0802 	sub.w	r8, r8, #2
 80003be:	4461      	add	r1, ip
 80003c0:	1a09      	subs	r1, r1, r0
 80003c2:	b2a4      	uxth	r4, r4
 80003c4:	fbb1 f0f9 	udiv	r0, r1, r9
 80003c8:	fb09 1110 	mls	r1, r9, r0, r1
 80003cc:	ea44 4101 	orr.w	r1, r4, r1, lsl #16
 80003d0:	fb00 fe0e 	mul.w	lr, r0, lr
 80003d4:	458e      	cmp	lr, r1
 80003d6:	d908      	bls.n	80003ea <__udivmoddi4+0x1e2>
 80003d8:	eb1c 0101 	adds.w	r1, ip, r1
 80003dc:	f100 34ff 	add.w	r4, r0, #4294967295	; 0xffffffff
 80003e0:	d26c      	bcs.n	80004bc <__udivmoddi4+0x2b4>
 80003e2:	458e      	cmp	lr, r1
 80003e4:	d96a      	bls.n	80004bc <__udivmoddi4+0x2b4>
 80003e6:	3802      	subs	r0, #2
 80003e8:	4461      	add	r1, ip
 80003ea:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
 80003ee:	fba0 9402 	umull	r9, r4, r0, r2
 80003f2:	eba1 010e 	sub.w	r1, r1, lr
 80003f6:	42a1      	cmp	r1, r4
 80003f8:	46c8      	mov	r8, r9
 80003fa:	46a6      	mov	lr, r4
 80003fc:	d356      	bcc.n	80004ac <__udivmoddi4+0x2a4>
 80003fe:	d053      	beq.n	80004a8 <__udivmoddi4+0x2a0>
 8000400:	b15d      	cbz	r5, 800041a <__udivmoddi4+0x212>
 8000402:	ebb3 0208 	subs.w	r2, r3, r8
 8000406:	eb61 010e 	sbc.w	r1, r1, lr
 800040a:	fa01 f707 	lsl.w	r7, r1, r7
 800040e:	fa22 f306 	lsr.w	r3, r2, r6
 8000412:	40f1      	lsrs	r1, r6
 8000414:	431f      	orrs	r7, r3
 8000416:	e9c5 7100 	strd	r7, r1, [r5]
 800041a:	2600      	movs	r6, #0
 800041c:	4631      	mov	r1, r6
 800041e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000422:	f1c2 0320 	rsb	r3, r2, #32
 8000426:	40d8      	lsrs	r0, r3
 8000428:	fa0c fc02 	lsl.w	ip, ip, r2
 800042c:	fa21 f303 	lsr.w	r3, r1, r3
 8000430:	4091      	lsls	r1, r2
 8000432:	4301      	orrs	r1, r0
 8000434:	ea4f 471c 	mov.w	r7, ip, lsr #16
 8000438:	fa1f fe8c 	uxth.w	lr, ip
 800043c:	fbb3 f0f7 	udiv	r0, r3, r7
 8000440:	fb07 3610 	mls	r6, r7, r0, r3
 8000444:	0c0b      	lsrs	r3, r1, #16
 8000446:	ea43 4306 	orr.w	r3, r3, r6, lsl #16
 800044a:	fb00 f60e 	mul.w	r6, r0, lr
 800044e:	429e      	cmp	r6, r3
 8000450:	fa04 f402 	lsl.w	r4, r4, r2
 8000454:	d908      	bls.n	8000468 <__udivmoddi4+0x260>
 8000456:	eb1c 0303 	adds.w	r3, ip, r3
 800045a:	f100 38ff 	add.w	r8, r0, #4294967295	; 0xffffffff
 800045e:	d22f      	bcs.n	80004c0 <__udivmoddi4+0x2b8>
 8000460:	429e      	cmp	r6, r3
 8000462:	d92d      	bls.n	80004c0 <__udivmoddi4+0x2b8>
 8000464:	3802      	subs	r0, #2
 8000466:	4463      	add	r3, ip
 8000468:	1b9b      	subs	r3, r3, r6
 800046a:	b289      	uxth	r1, r1
 800046c:	fbb3 f6f7 	udiv	r6, r3, r7
 8000470:	fb07 3316 	mls	r3, r7, r6, r3
 8000474:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 8000478:	fb06 f30e 	mul.w	r3, r6, lr
 800047c:	428b      	cmp	r3, r1
 800047e:	d908      	bls.n	8000492 <__udivmoddi4+0x28a>
 8000480:	eb1c 0101 	adds.w	r1, ip, r1
 8000484:	f106 38ff 	add.w	r8, r6, #4294967295	; 0xffffffff
 8000488:	d216      	bcs.n	80004b8 <__udivmoddi4+0x2b0>
 800048a:	428b      	cmp	r3, r1
 800048c:	d914      	bls.n	80004b8 <__udivmoddi4+0x2b0>
 800048e:	3e02      	subs	r6, #2
 8000490:	4461      	add	r1, ip
 8000492:	1ac9      	subs	r1, r1, r3
 8000494:	ea46 4600 	orr.w	r6, r6, r0, lsl #16
 8000498:	e738      	b.n	800030c <__udivmoddi4+0x104>
 800049a:	462e      	mov	r6, r5
 800049c:	4628      	mov	r0, r5
 800049e:	e705      	b.n	80002ac <__udivmoddi4+0xa4>
 80004a0:	4606      	mov	r6, r0
 80004a2:	e6e3      	b.n	800026c <__udivmoddi4+0x64>
 80004a4:	4618      	mov	r0, r3
 80004a6:	e6f8      	b.n	800029a <__udivmoddi4+0x92>
 80004a8:	454b      	cmp	r3, r9
 80004aa:	d2a9      	bcs.n	8000400 <__udivmoddi4+0x1f8>
 80004ac:	ebb9 0802 	subs.w	r8, r9, r2
 80004b0:	eb64 0e0c 	sbc.w	lr, r4, ip
 80004b4:	3801      	subs	r0, #1
 80004b6:	e7a3      	b.n	8000400 <__udivmoddi4+0x1f8>
 80004b8:	4646      	mov	r6, r8
 80004ba:	e7ea      	b.n	8000492 <__udivmoddi4+0x28a>
 80004bc:	4620      	mov	r0, r4
 80004be:	e794      	b.n	80003ea <__udivmoddi4+0x1e2>
 80004c0:	4640      	mov	r0, r8
 80004c2:	e7d1      	b.n	8000468 <__udivmoddi4+0x260>
 80004c4:	46d0      	mov	r8, sl
 80004c6:	e77b      	b.n	80003c0 <__udivmoddi4+0x1b8>
 80004c8:	3b02      	subs	r3, #2
 80004ca:	4461      	add	r1, ip
 80004cc:	e732      	b.n	8000334 <__udivmoddi4+0x12c>
 80004ce:	4630      	mov	r0, r6
 80004d0:	e709      	b.n	80002e6 <__udivmoddi4+0xde>
 80004d2:	4464      	add	r4, ip
 80004d4:	3802      	subs	r0, #2
 80004d6:	e742      	b.n	800035e <__udivmoddi4+0x156>

080004d8 <__aeabi_idiv0>:
 80004d8:	4770      	bx	lr
 80004da:	bf00      	nop

080004dc <HAL_PCD_Init>:
  *         parameters in the PCD_InitTypeDef and initialize the associated handle.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Init(PCD_HandleTypeDef *hpcd)
{
 80004dc:	b5f0      	push	{r4, r5, r6, r7, lr}
 80004de:	b08b      	sub	sp, #44	; 0x2c
  USB_OTG_GlobalTypeDef *USBx;
  uint8_t i;

  /* Check the PCD handle allocation */
  if (hpcd == NULL)
 80004e0:	2800      	cmp	r0, #0
 80004e2:	f000 8085 	beq.w	80005f0 <HAL_PCD_Init+0x114>
  /* Check the parameters */
  assert_param(IS_PCD_ALL_INSTANCE(hpcd->Instance));

  USBx = hpcd->Instance;

  if (hpcd->State == HAL_PCD_STATE_RESET)
 80004e6:	f890 34bd 	ldrb.w	r3, [r0, #1213]	; 0x4bd
  USBx = hpcd->Instance;
 80004ea:	6804      	ldr	r4, [r0, #0]
  if (hpcd->State == HAL_PCD_STATE_RESET)
 80004ec:	4605      	mov	r5, r0
 80004ee:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 80004f2:	2b00      	cmp	r3, #0
 80004f4:	d076      	beq.n	80005e4 <HAL_PCD_Init+0x108>
 80004f6:	4620      	mov	r0, r4
    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_PCD_MspInit(hpcd);
#endif /* (USE_HAL_PCD_REGISTER_CALLBACKS) */
  }

  hpcd->State = HAL_PCD_STATE_BUSY;
 80004f8:	2303      	movs	r3, #3
 80004fa:	f885 34bd 	strb.w	r3, [r5, #1213]	; 0x4bd

  /* Disable DMA mode for FS instance */
  if ((USBx->CID & (0x1U << 8)) == 0U)
 80004fe:	6be3      	ldr	r3, [r4, #60]	; 0x3c

  /* Disable the Interrupts */
  __HAL_PCD_DISABLE(hpcd);

  /*Init the Core (common init.) */
  if (USB_CoreInit(hpcd->Instance, hpcd->Init) != HAL_OK)
 8000500:	462e      	mov	r6, r5
  if ((USBx->CID & (0x1U << 8)) == 0U)
 8000502:	f413 7380 	ands.w	r3, r3, #256	; 0x100
    hpcd->Init.dma_enable = 0U;
 8000506:	bf08      	it	eq
 8000508:	612b      	streq	r3, [r5, #16]
  __HAL_PCD_DISABLE(hpcd);
 800050a:	f004 fad3 	bl	8004ab4 <USB_DisableGlobalInt>
  if (USB_CoreInit(hpcd->Instance, hpcd->Init) != HAL_OK)
 800050e:	f856 eb10 	ldr.w	lr, [r6], #16
 8000512:	46b4      	mov	ip, r6
 8000514:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8000518:	466c      	mov	r4, sp
 800051a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 800051c:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8000520:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8000522:	e89c 0003 	ldmia.w	ip, {r0, r1}
 8000526:	e884 0003 	stmia.w	r4, {r0, r1}
 800052a:	1d2f      	adds	r7, r5, #4
 800052c:	e897 000e 	ldmia.w	r7, {r1, r2, r3}
 8000530:	4670      	mov	r0, lr
 8000532:	f004 f9bb 	bl	80048ac <USB_CoreInit>
 8000536:	4604      	mov	r4, r0
 8000538:	b130      	cbz	r0, 8000548 <HAL_PCD_Init+0x6c>

  /* Init Device */
  if (USB_DevInit(hpcd->Instance, hpcd->Init) != HAL_OK)
  {
    hpcd->State = HAL_PCD_STATE_ERROR;
    return HAL_ERROR;
 800053a:	2401      	movs	r4, #1
    hpcd->State = HAL_PCD_STATE_ERROR;
 800053c:	2302      	movs	r3, #2
  }
#endif /* defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx) */
  (void)USB_DevDisconnect(hpcd->Instance);

  return HAL_OK;
}
 800053e:	4620      	mov	r0, r4
    hpcd->State = HAL_PCD_STATE_ERROR;
 8000540:	f885 34bd 	strb.w	r3, [r5, #1213]	; 0x4bd
}
 8000544:	b00b      	add	sp, #44	; 0x2c
 8000546:	bdf0      	pop	{r4, r5, r6, r7, pc}
  (void)USB_SetCurrentMode(hpcd->Instance, USB_DEVICE_MODE);
 8000548:	4601      	mov	r1, r0
 800054a:	6828      	ldr	r0, [r5, #0]
 800054c:	f004 faba 	bl	8004ac4 <USB_SetCurrentMode>
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8000550:	6868      	ldr	r0, [r5, #4]
 8000552:	b358      	cbz	r0, 80005ac <HAL_PCD_Init+0xd0>
 8000554:	4622      	mov	r2, r4
    hpcd->IN_ep[i].is_in = 1U;
 8000556:	f04f 0e01 	mov.w	lr, #1
    hpcd->IN_ep[i].type = EP_TYPE_CTRL;
 800055a:	4621      	mov	r1, r4
    hpcd->IN_ep[i].is_in = 1U;
 800055c:	eb02 03c2 	add.w	r3, r2, r2, lsl #3
 8000560:	eb05 0383 	add.w	r3, r5, r3, lsl #2
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8000564:	f102 0c01 	add.w	ip, r2, #1
    hpcd->IN_ep[i].num = i;
 8000568:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    hpcd->IN_ep[i].tx_fifo_num = i;
 800056c:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8000570:	fa5f f28c 	uxtb.w	r2, ip
 8000574:	4282      	cmp	r2, r0
    hpcd->IN_ep[i].xfer_buff = 0U;
 8000576:	e9c3 1112 	strd	r1, r1, [r3, #72]	; 0x48
    hpcd->IN_ep[i].is_in = 1U;
 800057a:	f883 e03d 	strb.w	lr, [r3, #61]	; 0x3d
    hpcd->IN_ep[i].type = EP_TYPE_CTRL;
 800057e:	f883 1040 	strb.w	r1, [r3, #64]	; 0x40
    hpcd->IN_ep[i].xfer_len = 0U;
 8000582:	6559      	str	r1, [r3, #84]	; 0x54
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8000584:	d3ea      	bcc.n	800055c <HAL_PCD_Init+0x80>
    hpcd->OUT_ep[i].is_in = 0U;
 8000586:	2200      	movs	r2, #0
 8000588:	eb04 03c4 	add.w	r3, r4, r4, lsl #3
 800058c:	eb05 0383 	add.w	r3, r5, r3, lsl #2
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8000590:	1c61      	adds	r1, r4, #1
    hpcd->OUT_ep[i].num = i;
 8000592:	f883 427c 	strb.w	r4, [r3, #636]	; 0x27c
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8000596:	b2cc      	uxtb	r4, r1
 8000598:	4284      	cmp	r4, r0
    hpcd->OUT_ep[i].xfer_buff = 0U;
 800059a:	e9c3 22a2 	strd	r2, r2, [r3, #648]	; 0x288
    hpcd->OUT_ep[i].is_in = 0U;
 800059e:	f883 227d 	strb.w	r2, [r3, #637]	; 0x27d
    hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
 80005a2:	f883 2280 	strb.w	r2, [r3, #640]	; 0x280
    hpcd->OUT_ep[i].xfer_len = 0U;
 80005a6:	f8c3 2294 	str.w	r2, [r3, #660]	; 0x294
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 80005aa:	d3ed      	bcc.n	8000588 <HAL_PCD_Init+0xac>
  if (USB_DevInit(hpcd->Instance, hpcd->Init) != HAL_OK)
 80005ac:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 80005ae:	466c      	mov	r4, sp
 80005b0:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80005b2:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 80005b4:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80005b6:	e896 0003 	ldmia.w	r6, {r0, r1}
 80005ba:	e884 0003 	stmia.w	r4, {r0, r1}
 80005be:	e897 000e 	ldmia.w	r7, {r1, r2, r3}
 80005c2:	6828      	ldr	r0, [r5, #0]
 80005c4:	f004 fab6 	bl	8004b34 <USB_DevInit>
 80005c8:	4604      	mov	r4, r0
 80005ca:	2800      	cmp	r0, #0
 80005cc:	d1b5      	bne.n	800053a <HAL_PCD_Init+0x5e>
  hpcd->State = HAL_PCD_STATE_READY;
 80005ce:	2301      	movs	r3, #1
  hpcd->USB_Address = 0U;
 80005d0:	f885 0038 	strb.w	r0, [r5, #56]	; 0x38
  (void)USB_DevDisconnect(hpcd->Instance);
 80005d4:	6828      	ldr	r0, [r5, #0]
  hpcd->State = HAL_PCD_STATE_READY;
 80005d6:	f885 34bd 	strb.w	r3, [r5, #1213]	; 0x4bd
  (void)USB_DevDisconnect(hpcd->Instance);
 80005da:	f004 ff85 	bl	80054e8 <USB_DevDisconnect>
}
 80005de:	4620      	mov	r0, r4
 80005e0:	b00b      	add	sp, #44	; 0x2c
 80005e2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    hpcd->Lock = HAL_UNLOCKED;
 80005e4:	f880 24bc 	strb.w	r2, [r0, #1212]	; 0x4bc
    HAL_PCD_MspInit(hpcd);
 80005e8:	f000 ffea 	bl	80015c0 <HAL_PCD_MspInit>
  __HAL_PCD_DISABLE(hpcd);
 80005ec:	6828      	ldr	r0, [r5, #0]
 80005ee:	e783      	b.n	80004f8 <HAL_PCD_Init+0x1c>
    return HAL_ERROR;
 80005f0:	2401      	movs	r4, #1
}
 80005f2:	4620      	mov	r0, r4
 80005f4:	b00b      	add	sp, #44	; 0x2c
 80005f6:	bdf0      	pop	{r4, r5, r6, r7, pc}

080005f8 <HAL_PCD_Start>:
  * @brief  Start the USB device
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Start(PCD_HandleTypeDef *hpcd)
{
 80005f8:	b510      	push	{r4, lr}
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;

  __HAL_LOCK(hpcd);
 80005fa:	f890 34bc 	ldrb.w	r3, [r0, #1212]	; 0x4bc
 80005fe:	2b01      	cmp	r3, #1
{
 8000600:	4604      	mov	r4, r0
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 8000602:	6800      	ldr	r0, [r0, #0]
  __HAL_LOCK(hpcd);
 8000604:	d016      	beq.n	8000634 <HAL_PCD_Start+0x3c>

  if ((hpcd->Init.battery_charging_enable == 1U) &&
 8000606:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  __HAL_LOCK(hpcd);
 8000608:	2201      	movs	r2, #1
  if ((hpcd->Init.battery_charging_enable == 1U) &&
 800060a:	4293      	cmp	r3, r2
  __HAL_LOCK(hpcd);
 800060c:	f884 24bc 	strb.w	r2, [r4, #1212]	; 0x4bc
  if ((hpcd->Init.battery_charging_enable == 1U) &&
 8000610:	d008      	beq.n	8000624 <HAL_PCD_Start+0x2c>
  {
    /* Enable USB Transceiver */
    USBx->GCCFG |= USB_OTG_GCCFG_PWRDWN;
  }

  __HAL_PCD_ENABLE(hpcd);
 8000612:	f004 fa47 	bl	8004aa4 <USB_EnableGlobalInt>
  (void)USB_DevConnect(hpcd->Instance);
 8000616:	6820      	ldr	r0, [r4, #0]
 8000618:	f004 ff56 	bl	80054c8 <USB_DevConnect>
  __HAL_UNLOCK(hpcd);
 800061c:	2000      	movs	r0, #0
 800061e:	f884 04bc 	strb.w	r0, [r4, #1212]	; 0x4bc

  return HAL_OK;
}
 8000622:	bd10      	pop	{r4, pc}
  if ((hpcd->Init.battery_charging_enable == 1U) &&
 8000624:	69a3      	ldr	r3, [r4, #24]
 8000626:	4293      	cmp	r3, r2
 8000628:	d0f3      	beq.n	8000612 <HAL_PCD_Start+0x1a>
    USBx->GCCFG |= USB_OTG_GCCFG_PWRDWN;
 800062a:	6b83      	ldr	r3, [r0, #56]	; 0x38
 800062c:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8000630:	6383      	str	r3, [r0, #56]	; 0x38
 8000632:	e7ee      	b.n	8000612 <HAL_PCD_Start+0x1a>
  __HAL_LOCK(hpcd);
 8000634:	2002      	movs	r0, #2
}
 8000636:	bd10      	pop	{r4, pc}

08000638 <HAL_PCD_IRQHandler>:
  * @brief  Handles PCD interrupt request.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
 8000638:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 800063c:	6805      	ldr	r5, [r0, #0]
{
 800063e:	b089      	sub	sp, #36	; 0x24
 8000640:	4604      	mov	r4, r0
  uint32_t epnum;
  uint32_t fifoemptymsk;
  uint32_t RegVal;

  /* ensure that we are in device mode */
  if (USB_GetMode(hpcd->Instance) == USB_OTG_MODE_DEVICE)
 8000642:	4628      	mov	r0, r5
 8000644:	f004 ff8e 	bl	8005564 <USB_GetMode>
 8000648:	b110      	cbz	r0, 8000650 <HAL_PCD_IRQHandler+0x18>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
      }
      hpcd->Instance->GOTGINT |= RegVal;
    }
  }
}
 800064a:	b009      	add	sp, #36	; 0x24
 800064c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (__HAL_PCD_IS_INVALID_INTERRUPT(hpcd))
 8000650:	4683      	mov	fp, r0
 8000652:	6820      	ldr	r0, [r4, #0]
 8000654:	f004 ff58 	bl	8005508 <USB_ReadInterrupts>
 8000658:	2800      	cmp	r0, #0
 800065a:	d0f6      	beq.n	800064a <HAL_PCD_IRQHandler+0x12>
    hpcd->FrameNumber = (USBx_DEVICE->DSTS & USB_OTG_DSTS_FNSOF_Msk) >> USB_OTG_DSTS_FNSOF_Pos;
 800065c:	f8d5 3808 	ldr.w	r3, [r5, #2056]	; 0x808
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_MMIS))
 8000660:	6820      	ldr	r0, [r4, #0]
    hpcd->FrameNumber = (USBx_DEVICE->DSTS & USB_OTG_DSTS_FNSOF_Msk) >> USB_OTG_DSTS_FNSOF_Pos;
 8000662:	f3c3 230d 	ubfx	r3, r3, #8, #14
 8000666:	f8c4 34fc 	str.w	r3, [r4, #1276]	; 0x4fc
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_MMIS))
 800066a:	f004 ff4d 	bl	8005508 <USB_ReadInterrupts>
 800066e:	f010 0f02 	tst.w	r0, #2
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_MMIS);
 8000672:	6820      	ldr	r0, [r4, #0]
    hpcd->FrameNumber = (USBx_DEVICE->DSTS & USB_OTG_DSTS_FNSOF_Msk) >> USB_OTG_DSTS_FNSOF_Pos;
 8000674:	f505 6300 	add.w	r3, r5, #2048	; 0x800
 8000678:	9303      	str	r3, [sp, #12]
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_MMIS);
 800067a:	bf1e      	ittt	ne
 800067c:	6943      	ldrne	r3, [r0, #20]
 800067e:	f003 0302 	andne.w	r3, r3, #2
 8000682:	6143      	strne	r3, [r0, #20]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_RXFLVL))
 8000684:	f004 ff40 	bl	8005508 <USB_ReadInterrupts>
 8000688:	f010 0f10 	tst.w	r0, #16
      USB_MASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 800068c:	6820      	ldr	r0, [r4, #0]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_RXFLVL))
 800068e:	d012      	beq.n	80006b6 <HAL_PCD_IRQHandler+0x7e>
      USB_MASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 8000690:	6983      	ldr	r3, [r0, #24]
 8000692:	f023 0310 	bic.w	r3, r3, #16
 8000696:	6183      	str	r3, [r0, #24]
      RegVal = USBx->GRXSTSP;
 8000698:	6a2e      	ldr	r6, [r5, #32]
      if (((RegVal & USB_OTG_GRXSTSP_PKTSTS) >> 17) ==  STS_DATA_UPDT)
 800069a:	f3c6 4343 	ubfx	r3, r6, #17, #4
 800069e:	2b02      	cmp	r3, #2
      ep = &hpcd->OUT_ep[RegVal & USB_OTG_GRXSTSP_EPNUM];
 80006a0:	f006 070f 	and.w	r7, r6, #15
      if (((RegVal & USB_OTG_GRXSTSP_PKTSTS) >> 17) ==  STS_DATA_UPDT)
 80006a4:	f000 83d1 	beq.w	8000e4a <HAL_PCD_IRQHandler+0x812>
      else if (((RegVal & USB_OTG_GRXSTSP_PKTSTS) >> 17) == STS_SETUP_UPDT)
 80006a8:	2b06      	cmp	r3, #6
 80006aa:	f000 830e 	beq.w	8000cca <HAL_PCD_IRQHandler+0x692>
      USB_UNMASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 80006ae:	6983      	ldr	r3, [r0, #24]
 80006b0:	f043 0310 	orr.w	r3, r3, #16
 80006b4:	6183      	str	r3, [r0, #24]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OEPINT))
 80006b6:	f004 ff27 	bl	8005508 <USB_ReadInterrupts>
 80006ba:	0307      	lsls	r7, r0, #12
 80006bc:	f100 828e 	bmi.w	8000bdc <HAL_PCD_IRQHandler+0x5a4>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IEPINT))
 80006c0:	6820      	ldr	r0, [r4, #0]
 80006c2:	f004 ff21 	bl	8005508 <USB_ReadInterrupts>
 80006c6:	0346      	lsls	r6, r0, #13
 80006c8:	f100 8236 	bmi.w	8000b38 <HAL_PCD_IRQHandler+0x500>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT))
 80006cc:	6820      	ldr	r0, [r4, #0]
 80006ce:	f004 ff1b 	bl	8005508 <USB_ReadInterrupts>
 80006d2:	2800      	cmp	r0, #0
 80006d4:	f2c0 81a7 	blt.w	8000a26 <HAL_PCD_IRQHandler+0x3ee>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP))
 80006d8:	6820      	ldr	r0, [r4, #0]
 80006da:	f004 ff15 	bl	8005508 <USB_ReadInterrupts>
 80006de:	0507      	lsls	r7, r0, #20
 80006e0:	f100 8162 	bmi.w	80009a8 <HAL_PCD_IRQHandler+0x370>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBRST))
 80006e4:	6820      	ldr	r0, [r4, #0]
 80006e6:	f004 ff0f 	bl	8005508 <USB_ReadInterrupts>
 80006ea:	04c0      	lsls	r0, r0, #19
 80006ec:	f100 81c5 	bmi.w	8000a7a <HAL_PCD_IRQHandler+0x442>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE))
 80006f0:	6820      	ldr	r0, [r4, #0]
 80006f2:	f004 ff09 	bl	8005508 <USB_ReadInterrupts>
 80006f6:	f410 5f00 	tst.w	r0, #8192	; 0x2000
      (void)USB_ActivateSetup(hpcd->Instance);
 80006fa:	6820      	ldr	r0, [r4, #0]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE))
 80006fc:	f040 81a6 	bne.w	8000a4c <HAL_PCD_IRQHandler+0x414>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SOF))
 8000700:	f004 ff02 	bl	8005508 <USB_ReadInterrupts>
 8000704:	0701      	lsls	r1, r0, #28
 8000706:	f100 820e 	bmi.w	8000b26 <HAL_PCD_IRQHandler+0x4ee>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_BOUTNAKEFF))
 800070a:	6820      	ldr	r0, [r4, #0]
 800070c:	f004 fefc 	bl	8005508 <USB_ReadInterrupts>
 8000710:	0602      	lsls	r2, r0, #24
 8000712:	d571      	bpl.n	80007f8 <HAL_PCD_IRQHandler+0x1c0>
      USBx->GINTMSK &= ~USB_OTG_GINTMSK_GONAKEFFM;
 8000714:	69aa      	ldr	r2, [r5, #24]
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8000716:	6863      	ldr	r3, [r4, #4]
      USBx->GINTMSK &= ~USB_OTG_GINTMSK_GONAKEFFM;
 8000718:	f022 0280 	bic.w	r2, r2, #128	; 0x80
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800071c:	2b01      	cmp	r3, #1
      USBx->GINTMSK &= ~USB_OTG_GINTMSK_GONAKEFFM;
 800071e:	61aa      	str	r2, [r5, #24]
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8000720:	d96a      	bls.n	80007f8 <HAL_PCD_IRQHandler+0x1c0>
        if (hpcd->OUT_ep[epnum].is_iso_incomplete == 1U)
 8000722:	f894 22a3 	ldrb.w	r2, [r4, #675]	; 0x2a3
 8000726:	2a01      	cmp	r2, #1
 8000728:	f000 83e3 	beq.w	8000ef2 <HAL_PCD_IRQHandler+0x8ba>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800072c:	2b02      	cmp	r3, #2
 800072e:	d963      	bls.n	80007f8 <HAL_PCD_IRQHandler+0x1c0>
        if (hpcd->OUT_ep[epnum].is_iso_incomplete == 1U)
 8000730:	f894 22c7 	ldrb.w	r2, [r4, #711]	; 0x2c7
 8000734:	2a01      	cmp	r2, #1
 8000736:	f000 83eb 	beq.w	8000f10 <HAL_PCD_IRQHandler+0x8d8>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800073a:	2b03      	cmp	r3, #3
 800073c:	d95c      	bls.n	80007f8 <HAL_PCD_IRQHandler+0x1c0>
        if (hpcd->OUT_ep[epnum].is_iso_incomplete == 1U)
 800073e:	f894 22eb 	ldrb.w	r2, [r4, #747]	; 0x2eb
 8000742:	2a01      	cmp	r2, #1
 8000744:	f000 82ba 	beq.w	8000cbc <HAL_PCD_IRQHandler+0x684>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8000748:	2b04      	cmp	r3, #4
 800074a:	d955      	bls.n	80007f8 <HAL_PCD_IRQHandler+0x1c0>
        if (hpcd->OUT_ep[epnum].is_iso_incomplete == 1U)
 800074c:	f894 230f 	ldrb.w	r2, [r4, #783]	; 0x30f
 8000750:	2a01      	cmp	r2, #1
 8000752:	f000 82cd 	beq.w	8000cf0 <HAL_PCD_IRQHandler+0x6b8>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8000756:	2b05      	cmp	r3, #5
 8000758:	d94e      	bls.n	80007f8 <HAL_PCD_IRQHandler+0x1c0>
        if (hpcd->OUT_ep[epnum].is_iso_incomplete == 1U)
 800075a:	f894 2333 	ldrb.w	r2, [r4, #819]	; 0x333
 800075e:	2a01      	cmp	r2, #1
 8000760:	f000 83ee 	beq.w	8000f40 <HAL_PCD_IRQHandler+0x908>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8000764:	2b06      	cmp	r3, #6
 8000766:	d947      	bls.n	80007f8 <HAL_PCD_IRQHandler+0x1c0>
        if (hpcd->OUT_ep[epnum].is_iso_incomplete == 1U)
 8000768:	f894 2357 	ldrb.w	r2, [r4, #855]	; 0x357
 800076c:	2a01      	cmp	r2, #1
 800076e:	f000 83ee 	beq.w	8000f4e <HAL_PCD_IRQHandler+0x916>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8000772:	2b07      	cmp	r3, #7
 8000774:	d940      	bls.n	80007f8 <HAL_PCD_IRQHandler+0x1c0>
        if (hpcd->OUT_ep[epnum].is_iso_incomplete == 1U)
 8000776:	f894 237b 	ldrb.w	r2, [r4, #891]	; 0x37b
 800077a:	2a01      	cmp	r2, #1
 800077c:	f000 83f3 	beq.w	8000f66 <HAL_PCD_IRQHandler+0x92e>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8000780:	2b08      	cmp	r3, #8
 8000782:	d939      	bls.n	80007f8 <HAL_PCD_IRQHandler+0x1c0>
        if (hpcd->OUT_ep[epnum].is_iso_incomplete == 1U)
 8000784:	f894 239f 	ldrb.w	r2, [r4, #927]	; 0x39f
 8000788:	2a01      	cmp	r2, #1
 800078a:	f000 83f3 	beq.w	8000f74 <HAL_PCD_IRQHandler+0x93c>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800078e:	2b09      	cmp	r3, #9
 8000790:	d932      	bls.n	80007f8 <HAL_PCD_IRQHandler+0x1c0>
        if (hpcd->OUT_ep[epnum].is_iso_incomplete == 1U)
 8000792:	f894 23c3 	ldrb.w	r2, [r4, #963]	; 0x3c3
 8000796:	2a01      	cmp	r2, #1
 8000798:	f000 83f3 	beq.w	8000f82 <HAL_PCD_IRQHandler+0x94a>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800079c:	2b0a      	cmp	r3, #10
 800079e:	d92b      	bls.n	80007f8 <HAL_PCD_IRQHandler+0x1c0>
        if (hpcd->OUT_ep[epnum].is_iso_incomplete == 1U)
 80007a0:	f894 23e7 	ldrb.w	r2, [r4, #999]	; 0x3e7
 80007a4:	2a01      	cmp	r2, #1
 80007a6:	f000 83f3 	beq.w	8000f90 <HAL_PCD_IRQHandler+0x958>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 80007aa:	2b0b      	cmp	r3, #11
 80007ac:	d924      	bls.n	80007f8 <HAL_PCD_IRQHandler+0x1c0>
        if (hpcd->OUT_ep[epnum].is_iso_incomplete == 1U)
 80007ae:	f894 240b 	ldrb.w	r2, [r4, #1035]	; 0x40b
 80007b2:	2a01      	cmp	r2, #1
 80007b4:	f000 83f3 	beq.w	8000f9e <HAL_PCD_IRQHandler+0x966>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 80007b8:	2b0c      	cmp	r3, #12
 80007ba:	d91d      	bls.n	80007f8 <HAL_PCD_IRQHandler+0x1c0>
        if (hpcd->OUT_ep[epnum].is_iso_incomplete == 1U)
 80007bc:	f894 242f 	ldrb.w	r2, [r4, #1071]	; 0x42f
 80007c0:	2a01      	cmp	r2, #1
 80007c2:	f000 83f3 	beq.w	8000fac <HAL_PCD_IRQHandler+0x974>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 80007c6:	2b0d      	cmp	r3, #13
 80007c8:	d916      	bls.n	80007f8 <HAL_PCD_IRQHandler+0x1c0>
        if (hpcd->OUT_ep[epnum].is_iso_incomplete == 1U)
 80007ca:	f894 2453 	ldrb.w	r2, [r4, #1107]	; 0x453
 80007ce:	2a01      	cmp	r2, #1
 80007d0:	f000 8417 	beq.w	8001002 <HAL_PCD_IRQHandler+0x9ca>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 80007d4:	2b0e      	cmp	r3, #14
 80007d6:	d90f      	bls.n	80007f8 <HAL_PCD_IRQHandler+0x1c0>
        if (hpcd->OUT_ep[epnum].is_iso_incomplete == 1U)
 80007d8:	f894 2477 	ldrb.w	r2, [r4, #1143]	; 0x477
 80007dc:	2a01      	cmp	r2, #1
 80007de:	f000 841e 	beq.w	800101e <HAL_PCD_IRQHandler+0x9e6>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 80007e2:	2b0f      	cmp	r3, #15
 80007e4:	d908      	bls.n	80007f8 <HAL_PCD_IRQHandler+0x1c0>
        if (hpcd->OUT_ep[epnum].is_iso_incomplete == 1U)
 80007e6:	f894 349b 	ldrb.w	r3, [r4, #1179]	; 0x49b
 80007ea:	2b01      	cmp	r3, #1
 80007ec:	d104      	bne.n	80007f8 <HAL_PCD_IRQHandler+0x1c0>
  {
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
  }

  /* Stop Xfer */
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 80007ee:	6820      	ldr	r0, [r4, #0]
 80007f0:	f504 6193 	add.w	r1, r4, #1176	; 0x498
 80007f4:	f004 fd7c 	bl	80052f0 <USB_EPStopXfer>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR))
 80007f8:	6820      	ldr	r0, [r4, #0]
 80007fa:	f004 fe85 	bl	8005508 <USB_ReadInterrupts>
 80007fe:	02c3      	lsls	r3, r0, #11
 8000800:	f140 80d0 	bpl.w	80009a4 <HAL_PCD_IRQHandler+0x36c>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8000804:	6863      	ldr	r3, [r4, #4]
 8000806:	2b01      	cmp	r3, #1
 8000808:	f240 80ae 	bls.w	8000968 <HAL_PCD_IRQHandler+0x330>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 800080c:	f894 2064 	ldrb.w	r2, [r4, #100]	; 0x64
        RegVal = USBx_INEP(epnum)->DIEPCTL;
 8000810:	f8d5 1920 	ldr.w	r1, [r5, #2336]	; 0x920
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 8000814:	2a01      	cmp	r2, #1
 8000816:	f000 8236 	beq.w	8000c86 <HAL_PCD_IRQHandler+0x64e>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800081a:	2b02      	cmp	r3, #2
 800081c:	f000 80a4 	beq.w	8000968 <HAL_PCD_IRQHandler+0x330>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 8000820:	f894 2088 	ldrb.w	r2, [r4, #136]	; 0x88
        RegVal = USBx_INEP(epnum)->DIEPCTL;
 8000824:	f8d5 1940 	ldr.w	r1, [r5, #2368]	; 0x940
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 8000828:	2a01      	cmp	r2, #1
 800082a:	f000 8238 	beq.w	8000c9e <HAL_PCD_IRQHandler+0x666>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800082e:	2b03      	cmp	r3, #3
 8000830:	f000 809a 	beq.w	8000968 <HAL_PCD_IRQHandler+0x330>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 8000834:	f894 20ac 	ldrb.w	r2, [r4, #172]	; 0xac
        RegVal = USBx_INEP(epnum)->DIEPCTL;
 8000838:	f8d5 1960 	ldr.w	r1, [r5, #2400]	; 0x960
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 800083c:	2a01      	cmp	r2, #1
 800083e:	f000 8233 	beq.w	8000ca8 <HAL_PCD_IRQHandler+0x670>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8000842:	2b04      	cmp	r3, #4
 8000844:	f000 8090 	beq.w	8000968 <HAL_PCD_IRQHandler+0x330>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 8000848:	f894 20d0 	ldrb.w	r2, [r4, #208]	; 0xd0
        RegVal = USBx_INEP(epnum)->DIEPCTL;
 800084c:	f8d5 1980 	ldr.w	r1, [r5, #2432]	; 0x980
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 8000850:	2a01      	cmp	r2, #1
 8000852:	f000 822e 	beq.w	8000cb2 <HAL_PCD_IRQHandler+0x67a>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8000856:	2b05      	cmp	r3, #5
 8000858:	f000 8086 	beq.w	8000968 <HAL_PCD_IRQHandler+0x330>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 800085c:	f894 20f4 	ldrb.w	r2, [r4, #244]	; 0xf4
        RegVal = USBx_INEP(epnum)->DIEPCTL;
 8000860:	f8d5 19a0 	ldr.w	r1, [r5, #2464]	; 0x9a0
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 8000864:	2a01      	cmp	r2, #1
 8000866:	d103      	bne.n	8000870 <HAL_PCD_IRQHandler+0x238>
 8000868:	2900      	cmp	r1, #0
          hpcd->IN_ep[epnum].is_iso_incomplete = 1U;
 800086a:	bfb8      	it	lt
 800086c:	f884 20f3 	strblt.w	r2, [r4, #243]	; 0xf3
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8000870:	2b06      	cmp	r3, #6
 8000872:	d079      	beq.n	8000968 <HAL_PCD_IRQHandler+0x330>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 8000874:	f894 2118 	ldrb.w	r2, [r4, #280]	; 0x118
        RegVal = USBx_INEP(epnum)->DIEPCTL;
 8000878:	f8d5 19c0 	ldr.w	r1, [r5, #2496]	; 0x9c0
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 800087c:	2a01      	cmp	r2, #1
 800087e:	d103      	bne.n	8000888 <HAL_PCD_IRQHandler+0x250>
 8000880:	2900      	cmp	r1, #0
          hpcd->IN_ep[epnum].is_iso_incomplete = 1U;
 8000882:	bfb8      	it	lt
 8000884:	f884 2117 	strblt.w	r2, [r4, #279]	; 0x117
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8000888:	2b07      	cmp	r3, #7
 800088a:	d06d      	beq.n	8000968 <HAL_PCD_IRQHandler+0x330>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 800088c:	f894 213c 	ldrb.w	r2, [r4, #316]	; 0x13c
        RegVal = USBx_INEP(epnum)->DIEPCTL;
 8000890:	f8d5 19e0 	ldr.w	r1, [r5, #2528]	; 0x9e0
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 8000894:	2a01      	cmp	r2, #1
 8000896:	d103      	bne.n	80008a0 <HAL_PCD_IRQHandler+0x268>
 8000898:	2900      	cmp	r1, #0
          hpcd->IN_ep[epnum].is_iso_incomplete = 1U;
 800089a:	bfb8      	it	lt
 800089c:	f884 213b 	strblt.w	r2, [r4, #315]	; 0x13b
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 80008a0:	2b08      	cmp	r3, #8
 80008a2:	d061      	beq.n	8000968 <HAL_PCD_IRQHandler+0x330>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 80008a4:	f894 2160 	ldrb.w	r2, [r4, #352]	; 0x160
        RegVal = USBx_INEP(epnum)->DIEPCTL;
 80008a8:	f8d5 1a00 	ldr.w	r1, [r5, #2560]	; 0xa00
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 80008ac:	2a01      	cmp	r2, #1
 80008ae:	d103      	bne.n	80008b8 <HAL_PCD_IRQHandler+0x280>
 80008b0:	2900      	cmp	r1, #0
          hpcd->IN_ep[epnum].is_iso_incomplete = 1U;
 80008b2:	bfb8      	it	lt
 80008b4:	f884 215f 	strblt.w	r2, [r4, #351]	; 0x15f
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 80008b8:	2b09      	cmp	r3, #9
 80008ba:	d055      	beq.n	8000968 <HAL_PCD_IRQHandler+0x330>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 80008bc:	f894 2184 	ldrb.w	r2, [r4, #388]	; 0x184
        RegVal = USBx_INEP(epnum)->DIEPCTL;
 80008c0:	f8d5 1a20 	ldr.w	r1, [r5, #2592]	; 0xa20
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 80008c4:	2a01      	cmp	r2, #1
 80008c6:	d103      	bne.n	80008d0 <HAL_PCD_IRQHandler+0x298>
 80008c8:	2900      	cmp	r1, #0
          hpcd->IN_ep[epnum].is_iso_incomplete = 1U;
 80008ca:	bfb8      	it	lt
 80008cc:	f884 2183 	strblt.w	r2, [r4, #387]	; 0x183
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 80008d0:	2b0a      	cmp	r3, #10
 80008d2:	d049      	beq.n	8000968 <HAL_PCD_IRQHandler+0x330>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 80008d4:	f894 21a8 	ldrb.w	r2, [r4, #424]	; 0x1a8
        RegVal = USBx_INEP(epnum)->DIEPCTL;
 80008d8:	f8d5 1a40 	ldr.w	r1, [r5, #2624]	; 0xa40
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 80008dc:	2a01      	cmp	r2, #1
 80008de:	d103      	bne.n	80008e8 <HAL_PCD_IRQHandler+0x2b0>
 80008e0:	2900      	cmp	r1, #0
          hpcd->IN_ep[epnum].is_iso_incomplete = 1U;
 80008e2:	bfb8      	it	lt
 80008e4:	f884 21a7 	strblt.w	r2, [r4, #423]	; 0x1a7
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 80008e8:	2b0b      	cmp	r3, #11
 80008ea:	d03d      	beq.n	8000968 <HAL_PCD_IRQHandler+0x330>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 80008ec:	f894 21cc 	ldrb.w	r2, [r4, #460]	; 0x1cc
        RegVal = USBx_INEP(epnum)->DIEPCTL;
 80008f0:	f8d5 1a60 	ldr.w	r1, [r5, #2656]	; 0xa60
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 80008f4:	2a01      	cmp	r2, #1
 80008f6:	d103      	bne.n	8000900 <HAL_PCD_IRQHandler+0x2c8>
 80008f8:	2900      	cmp	r1, #0
          hpcd->IN_ep[epnum].is_iso_incomplete = 1U;
 80008fa:	bfb8      	it	lt
 80008fc:	f884 21cb 	strblt.w	r2, [r4, #459]	; 0x1cb
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8000900:	2b0c      	cmp	r3, #12
 8000902:	d031      	beq.n	8000968 <HAL_PCD_IRQHandler+0x330>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 8000904:	f894 21f0 	ldrb.w	r2, [r4, #496]	; 0x1f0
        RegVal = USBx_INEP(epnum)->DIEPCTL;
 8000908:	f8d5 1a80 	ldr.w	r1, [r5, #2688]	; 0xa80
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 800090c:	2a01      	cmp	r2, #1
 800090e:	d103      	bne.n	8000918 <HAL_PCD_IRQHandler+0x2e0>
 8000910:	2900      	cmp	r1, #0
          hpcd->IN_ep[epnum].is_iso_incomplete = 1U;
 8000912:	bfb8      	it	lt
 8000914:	f884 21ef 	strblt.w	r2, [r4, #495]	; 0x1ef
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8000918:	2b0d      	cmp	r3, #13
 800091a:	d025      	beq.n	8000968 <HAL_PCD_IRQHandler+0x330>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 800091c:	f894 2214 	ldrb.w	r2, [r4, #532]	; 0x214
        RegVal = USBx_INEP(epnum)->DIEPCTL;
 8000920:	f8d5 1aa0 	ldr.w	r1, [r5, #2720]	; 0xaa0
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 8000924:	2a01      	cmp	r2, #1
 8000926:	d103      	bne.n	8000930 <HAL_PCD_IRQHandler+0x2f8>
 8000928:	2900      	cmp	r1, #0
          hpcd->IN_ep[epnum].is_iso_incomplete = 1U;
 800092a:	bfb8      	it	lt
 800092c:	f884 2213 	strblt.w	r2, [r4, #531]	; 0x213
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8000930:	2b0e      	cmp	r3, #14
 8000932:	d019      	beq.n	8000968 <HAL_PCD_IRQHandler+0x330>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 8000934:	f894 2238 	ldrb.w	r2, [r4, #568]	; 0x238
        RegVal = USBx_INEP(epnum)->DIEPCTL;
 8000938:	f8d5 1ac0 	ldr.w	r1, [r5, #2752]	; 0xac0
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 800093c:	2a01      	cmp	r2, #1
 800093e:	d103      	bne.n	8000948 <HAL_PCD_IRQHandler+0x310>
 8000940:	2900      	cmp	r1, #0
          hpcd->IN_ep[epnum].is_iso_incomplete = 1U;
 8000942:	bfb8      	it	lt
 8000944:	f884 2237 	strblt.w	r2, [r4, #567]	; 0x237
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8000948:	2b0f      	cmp	r3, #15
 800094a:	d00d      	beq.n	8000968 <HAL_PCD_IRQHandler+0x330>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 800094c:	f894 225c 	ldrb.w	r2, [r4, #604]	; 0x25c
        RegVal = USBx_INEP(epnum)->DIEPCTL;
 8000950:	f8d5 1ae0 	ldr.w	r1, [r5, #2784]	; 0xae0
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 8000954:	2a01      	cmp	r2, #1
 8000956:	d103      	bne.n	8000960 <HAL_PCD_IRQHandler+0x328>
 8000958:	2900      	cmp	r1, #0
          hpcd->IN_ep[epnum].is_iso_incomplete = 1U;
 800095a:	bfb8      	it	lt
 800095c:	f884 225b 	strblt.w	r2, [r4, #603]	; 0x25b
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8000960:	2b10      	cmp	r3, #16
 8000962:	d001      	beq.n	8000968 <HAL_PCD_IRQHandler+0x330>
        RegVal = USBx_INEP(epnum)->DIEPCTL;
 8000964:	f8d5 3b00 	ldr.w	r3, [r5, #2816]	; 0xb00
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR);
 8000968:	6820      	ldr	r0, [r4, #0]
 800096a:	6943      	ldr	r3, [r0, #20]
 800096c:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 8000970:	6143      	str	r3, [r0, #20]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT))
 8000972:	f004 fdc9 	bl	8005508 <USB_ReadInterrupts>
 8000976:	0287      	lsls	r7, r0, #10
 8000978:	d421      	bmi.n	80009be <HAL_PCD_IRQHandler+0x386>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT);
 800097a:	6820      	ldr	r0, [r4, #0]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT))
 800097c:	f004 fdc4 	bl	8005508 <USB_ReadInterrupts>
 8000980:	0040      	lsls	r0, r0, #1
 8000982:	f100 80c7 	bmi.w	8000b14 <HAL_PCD_IRQHandler+0x4dc>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OTGINT))
 8000986:	6820      	ldr	r0, [r4, #0]
 8000988:	f004 fdbe 	bl	8005508 <USB_ReadInterrupts>
 800098c:	0741      	lsls	r1, r0, #29
 800098e:	f57f ae5c 	bpl.w	800064a <HAL_PCD_IRQHandler+0x12>
      RegVal = hpcd->Instance->GOTGINT;
 8000992:	6823      	ldr	r3, [r4, #0]
 8000994:	685d      	ldr	r5, [r3, #4]
      if ((RegVal & USB_OTG_GOTGINT_SEDET) == USB_OTG_GOTGINT_SEDET)
 8000996:	076a      	lsls	r2, r5, #29
 8000998:	f100 8278 	bmi.w	8000e8c <HAL_PCD_IRQHandler+0x854>
      hpcd->Instance->GOTGINT |= RegVal;
 800099c:	685a      	ldr	r2, [r3, #4]
 800099e:	432a      	orrs	r2, r5
 80009a0:	605a      	str	r2, [r3, #4]
 80009a2:	e652      	b.n	800064a <HAL_PCD_IRQHandler+0x12>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR);
 80009a4:	6820      	ldr	r0, [r4, #0]
 80009a6:	e7e4      	b.n	8000972 <HAL_PCD_IRQHandler+0x33a>
      if ((USBx_DEVICE->DSTS & USB_OTG_DSTS_SUSPSTS) == USB_OTG_DSTS_SUSPSTS)
 80009a8:	9b03      	ldr	r3, [sp, #12]
 80009aa:	689b      	ldr	r3, [r3, #8]
 80009ac:	07de      	lsls	r6, r3, #31
 80009ae:	f100 8269 	bmi.w	8000e84 <HAL_PCD_IRQHandler+0x84c>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP);
 80009b2:	6820      	ldr	r0, [r4, #0]
 80009b4:	6943      	ldr	r3, [r0, #20]
 80009b6:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 80009ba:	6143      	str	r3, [r0, #20]
 80009bc:	e693      	b.n	80006e6 <HAL_PCD_IRQHandler+0xae>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 80009be:	f8d4 c004 	ldr.w	ip, [r4, #4]
 80009c2:	f1bc 0f01 	cmp.w	ip, #1
 80009c6:	d928      	bls.n	8000a1a <HAL_PCD_IRQHandler+0x3e2>
 80009c8:	f505 6232 	add.w	r2, r5, #2848	; 0xb20
 80009cc:	4623      	mov	r3, r4
 80009ce:	2101      	movs	r1, #1
 80009d0:	e006      	b.n	80009e0 <HAL_PCD_IRQHandler+0x3a8>
 80009d2:	3101      	adds	r1, #1
 80009d4:	4561      	cmp	r1, ip
 80009d6:	f102 0220 	add.w	r2, r2, #32
 80009da:	f103 0324 	add.w	r3, r3, #36	; 0x24
 80009de:	d01c      	beq.n	8000a1a <HAL_PCD_IRQHandler+0x3e2>
        if ((hpcd->OUT_ep[epnum].type == EP_TYPE_ISOC) &&
 80009e0:	f893 02a4 	ldrb.w	r0, [r3, #676]	; 0x2a4
        RegVal = USBx_OUTEP(epnum)->DOEPCTL;
 80009e4:	6816      	ldr	r6, [r2, #0]
        if ((hpcd->OUT_ep[epnum].type == EP_TYPE_ISOC) &&
 80009e6:	2801      	cmp	r0, #1
 80009e8:	d1f3      	bne.n	80009d2 <HAL_PCD_IRQHandler+0x39a>
 80009ea:	2e00      	cmp	r6, #0
 80009ec:	daf1      	bge.n	80009d2 <HAL_PCD_IRQHandler+0x39a>
            ((RegVal & (0x1U << 16)) == (hpcd->FrameNumber & 0x1U)))
 80009ee:	f8d4 74fc 	ldr.w	r7, [r4, #1276]	; 0x4fc
 80009f2:	f406 3680 	and.w	r6, r6, #65536	; 0x10000
 80009f6:	f007 0701 	and.w	r7, r7, #1
            ((RegVal & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA) &&
 80009fa:	42be      	cmp	r6, r7
 80009fc:	d1e9      	bne.n	80009d2 <HAL_PCD_IRQHandler+0x39a>
          hpcd->OUT_ep[epnum].is_iso_incomplete = 1U;
 80009fe:	f883 02a3 	strb.w	r0, [r3, #675]	; 0x2a3
          USBx->GINTMSK |= USB_OTG_GINTMSK_GONAKEFFM;
 8000a02:	69a8      	ldr	r0, [r5, #24]
 8000a04:	f040 0080 	orr.w	r0, r0, #128	; 0x80
 8000a08:	61a8      	str	r0, [r5, #24]
          if ((USBx->GINTSTS & USB_OTG_GINTSTS_BOUTNAKEFF) == 0U)
 8000a0a:	6968      	ldr	r0, [r5, #20]
 8000a0c:	0606      	lsls	r6, r0, #24
 8000a0e:	d4e0      	bmi.n	80009d2 <HAL_PCD_IRQHandler+0x39a>
            USBx_DEVICE->DCTL |= USB_OTG_DCTL_SGONAK;
 8000a10:	9a03      	ldr	r2, [sp, #12]
 8000a12:	6853      	ldr	r3, [r2, #4]
 8000a14:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8000a18:	6053      	str	r3, [r2, #4]
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT);
 8000a1a:	6820      	ldr	r0, [r4, #0]
 8000a1c:	6943      	ldr	r3, [r0, #20]
 8000a1e:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8000a22:	6143      	str	r3, [r0, #20]
 8000a24:	e7aa      	b.n	800097c <HAL_PCD_IRQHandler+0x344>
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
 8000a26:	9a03      	ldr	r2, [sp, #12]
 8000a28:	6853      	ldr	r3, [r2, #4]
 8000a2a:	f023 0301 	bic.w	r3, r3, #1
 8000a2e:	6053      	str	r3, [r2, #4]
      if (hpcd->LPM_State == LPM_L1)
 8000a30:	f894 34f4 	ldrb.w	r3, [r4, #1268]	; 0x4f4
 8000a34:	2b01      	cmp	r3, #1
 8000a36:	f000 812b 	beq.w	8000c90 <HAL_PCD_IRQHandler+0x658>
        HAL_PCD_ResumeCallback(hpcd);
 8000a3a:	4620      	mov	r0, r4
 8000a3c:	f000 fe30 	bl	80016a0 <HAL_PCD_ResumeCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT);
 8000a40:	6820      	ldr	r0, [r4, #0]
 8000a42:	6943      	ldr	r3, [r0, #20]
 8000a44:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
 8000a48:	6143      	str	r3, [r0, #20]
 8000a4a:	e646      	b.n	80006da <HAL_PCD_IRQHandler+0xa2>
      (void)USB_ActivateSetup(hpcd->Instance);
 8000a4c:	f004 fd8e 	bl	800556c <USB_ActivateSetup>
      hpcd->Init.speed = USB_GetDevSpeed(hpcd->Instance);
 8000a50:	6820      	ldr	r0, [r4, #0]
 8000a52:	f004 f9db 	bl	8004e0c <USB_GetDevSpeed>
 8000a56:	60e0      	str	r0, [r4, #12]
      (void)USB_SetTurnaroundTime(hpcd->Instance,
 8000a58:	6826      	ldr	r6, [r4, #0]
 8000a5a:	f002 ff83 	bl	8003964 <HAL_RCC_GetHCLKFreq>
 8000a5e:	7b22      	ldrb	r2, [r4, #12]
 8000a60:	4601      	mov	r1, r0
 8000a62:	4630      	mov	r0, r6
 8000a64:	f003 ffa4 	bl	80049b0 <USB_SetTurnaroundTime>
      HAL_PCD_ResetCallback(hpcd);
 8000a68:	4620      	mov	r0, r4
 8000a6a:	f000 fe05 	bl	8001678 <HAL_PCD_ResetCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE);
 8000a6e:	6820      	ldr	r0, [r4, #0]
 8000a70:	6943      	ldr	r3, [r0, #20]
 8000a72:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8000a76:	6143      	str	r3, [r0, #20]
 8000a78:	e642      	b.n	8000700 <HAL_PCD_IRQHandler+0xc8>
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
 8000a7a:	9a03      	ldr	r2, [sp, #12]
      (void)USB_FlushTxFifo(hpcd->Instance, 0x10U);
 8000a7c:	6820      	ldr	r0, [r4, #0]
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
 8000a7e:	6853      	ldr	r3, [r2, #4]
 8000a80:	f023 0301 	bic.w	r3, r3, #1
 8000a84:	6053      	str	r3, [r2, #4]
      (void)USB_FlushTxFifo(hpcd->Instance, 0x10U);
 8000a86:	2110      	movs	r1, #16
 8000a88:	f004 f96e 	bl	8004d68 <USB_FlushTxFifo>
      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8000a8c:	6860      	ldr	r0, [r4, #4]
 8000a8e:	b1e0      	cbz	r0, 8000aca <HAL_PCD_IRQHandler+0x492>
 8000a90:	f505 6310 	add.w	r3, r5, #2304	; 0x900
        USBx_INEP(i)->DIEPINT = 0xFB7FU;
 8000a94:	f64f 317f 	movw	r1, #64383	; 0xfb7f
 8000a98:	6099      	str	r1, [r3, #8]
        USBx_INEP(i)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
 8000a9a:	681a      	ldr	r2, [r3, #0]
 8000a9c:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
 8000aa0:	601a      	str	r2, [r3, #0]
        USBx_OUTEP(i)->DOEPINT = 0xFB7FU;
 8000aa2:	f8c3 1208 	str.w	r1, [r3, #520]	; 0x208
        USBx_OUTEP(i)->DOEPCTL &= ~USB_OTG_DOEPCTL_STALL;
 8000aa6:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
 8000aaa:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
 8000aae:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
        USBx_OUTEP(i)->DOEPCTL |= USB_OTG_DOEPCTL_SNAK;
 8000ab2:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8000ab6:	f10b 0b01 	add.w	fp, fp, #1
        USBx_OUTEP(i)->DOEPCTL |= USB_OTG_DOEPCTL_SNAK;
 8000aba:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8000abe:	4583      	cmp	fp, r0
        USBx_OUTEP(i)->DOEPCTL |= USB_OTG_DOEPCTL_SNAK;
 8000ac0:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8000ac4:	f103 0320 	add.w	r3, r3, #32
 8000ac8:	d1e6      	bne.n	8000a98 <HAL_PCD_IRQHandler+0x460>
      USBx_DEVICE->DAINTMSK |= 0x10001U;
 8000aca:	9903      	ldr	r1, [sp, #12]
      if (hpcd->Init.use_dedicated_ep1 != 0U)
 8000acc:	6b22      	ldr	r2, [r4, #48]	; 0x30
      USBx_DEVICE->DAINTMSK |= 0x10001U;
 8000ace:	69cb      	ldr	r3, [r1, #28]
 8000ad0:	f043 1301 	orr.w	r3, r3, #65537	; 0x10001
 8000ad4:	61cb      	str	r3, [r1, #28]
      if (hpcd->Init.use_dedicated_ep1 != 0U)
 8000ad6:	2a00      	cmp	r2, #0
 8000ad8:	f040 80ca 	bne.w	8000c70 <HAL_PCD_IRQHandler+0x638>
        USBx_DEVICE->DOEPMSK |= USB_OTG_DOEPMSK_STUPM |
 8000adc:	694b      	ldr	r3, [r1, #20]
 8000ade:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8000ae2:	f043 032b 	orr.w	r3, r3, #43	; 0x2b
 8000ae6:	614b      	str	r3, [r1, #20]
        USBx_DEVICE->DIEPMSK |= USB_OTG_DIEPMSK_TOM |
 8000ae8:	690b      	ldr	r3, [r1, #16]
 8000aea:	f043 030b 	orr.w	r3, r3, #11
 8000aee:	610b      	str	r3, [r1, #16]
      USBx_DEVICE->DCFG &= ~USB_OTG_DCFG_DAD;
 8000af0:	f8d5 3800 	ldr.w	r3, [r5, #2048]	; 0x800
      (void)USB_EP0_OutStart(hpcd->Instance, (uint8_t)hpcd->Init.dma_enable,
 8000af4:	7c21      	ldrb	r1, [r4, #16]
 8000af6:	6820      	ldr	r0, [r4, #0]
      USBx_DEVICE->DCFG &= ~USB_OTG_DCFG_DAD;
 8000af8:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
 8000afc:	f8c5 3800 	str.w	r3, [r5, #2048]	; 0x800
      (void)USB_EP0_OutStart(hpcd->Instance, (uint8_t)hpcd->Init.dma_enable,
 8000b00:	f204 42c4 	addw	r2, r4, #1220	; 0x4c4
 8000b04:	f004 fd44 	bl	8005590 <USB_EP0_OutStart>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBRST);
 8000b08:	6820      	ldr	r0, [r4, #0]
 8000b0a:	6943      	ldr	r3, [r0, #20]
 8000b0c:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8000b10:	6143      	str	r3, [r0, #20]
 8000b12:	e5ee      	b.n	80006f2 <HAL_PCD_IRQHandler+0xba>
      HAL_PCD_ConnectCallback(hpcd);
 8000b14:	4620      	mov	r0, r4
 8000b16:	f000 fdcf 	bl	80016b8 <HAL_PCD_ConnectCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT);
 8000b1a:	6820      	ldr	r0, [r4, #0]
 8000b1c:	6943      	ldr	r3, [r0, #20]
 8000b1e:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
 8000b22:	6143      	str	r3, [r0, #20]
 8000b24:	e730      	b.n	8000988 <HAL_PCD_IRQHandler+0x350>
      HAL_PCD_SOFCallback(hpcd);
 8000b26:	4620      	mov	r0, r4
 8000b28:	f000 fda2 	bl	8001670 <HAL_PCD_SOFCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SOF);
 8000b2c:	6820      	ldr	r0, [r4, #0]
 8000b2e:	6943      	ldr	r3, [r0, #20]
 8000b30:	f003 0308 	and.w	r3, r3, #8
 8000b34:	6143      	str	r3, [r0, #20]
 8000b36:	e5e9      	b.n	800070c <HAL_PCD_IRQHandler+0xd4>
      ep_intr = USB_ReadDevAllInEpInterrupt(hpcd->Instance);
 8000b38:	6820      	ldr	r0, [r4, #0]
 8000b3a:	f004 fcf1 	bl	8005520 <USB_ReadDevAllInEpInterrupt>
      while (ep_intr != 0U)
 8000b3e:	4680      	mov	r8, r0
 8000b40:	2800      	cmp	r0, #0
 8000b42:	f43f adc3 	beq.w	80006cc <HAL_PCD_IRQHandler+0x94>
      epnum = 0U;
 8000b46:	f04f 0a00 	mov.w	sl, #0
          epint = USB_ReadDevInEPInterrupt(hpcd->Instance, (uint8_t)epnum);
 8000b4a:	6820      	ldr	r0, [r4, #0]
              ep->is_iso_incomplete = 0U;
 8000b4c:	9504      	str	r5, [sp, #16]
 8000b4e:	4627      	mov	r7, r4
 8000b50:	f505 6910 	add.w	r9, r5, #2304	; 0x900
 8000b54:	4656      	mov	r6, sl
 8000b56:	f8cd b014 	str.w	fp, [sp, #20]
 8000b5a:	e009      	b.n	8000b70 <HAL_PCD_IRQHandler+0x538>
      while (ep_intr != 0U)
 8000b5c:	ea5f 0858 	movs.w	r8, r8, lsr #1
        epnum++;
 8000b60:	f106 0601 	add.w	r6, r6, #1
      while (ep_intr != 0U)
 8000b64:	f107 0724 	add.w	r7, r7, #36	; 0x24
 8000b68:	f109 0920 	add.w	r9, r9, #32
 8000b6c:	f000 80c7 	beq.w	8000cfe <HAL_PCD_IRQHandler+0x6c6>
        if ((ep_intr & 0x1U) != 0U) /* In ITR */
 8000b70:	f018 0f01 	tst.w	r8, #1
 8000b74:	d0f2      	beq.n	8000b5c <HAL_PCD_IRQHandler+0x524>
          epint = USB_ReadDevInEPInterrupt(hpcd->Instance, (uint8_t)epnum);
 8000b76:	fa5f fa86 	uxtb.w	sl, r6
 8000b7a:	4651      	mov	r1, sl
 8000b7c:	f004 fce2 	bl	8005544 <USB_ReadDevInEPInterrupt>
          if ((epint & USB_OTG_DIEPINT_XFRC) == USB_OTG_DIEPINT_XFRC)
 8000b80:	07c2      	lsls	r2, r0, #31
          epint = USB_ReadDevInEPInterrupt(hpcd->Instance, (uint8_t)epnum);
 8000b82:	4605      	mov	r5, r0
          if ((epint & USB_OTG_DIEPINT_XFRC) == USB_OTG_DIEPINT_XFRC)
 8000b84:	d513      	bpl.n	8000bae <HAL_PCD_IRQHandler+0x576>
            USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8000b86:	9903      	ldr	r1, [sp, #12]
            fifoemptymsk = (uint32_t)(0x1UL << (epnum & EP_ADDR_MSK));
 8000b88:	2001      	movs	r0, #1
            USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8000b8a:	6b4b      	ldr	r3, [r1, #52]	; 0x34
            fifoemptymsk = (uint32_t)(0x1UL << (epnum & EP_ADDR_MSK));
 8000b8c:	f006 020f 	and.w	r2, r6, #15
 8000b90:	fa00 f202 	lsl.w	r2, r0, r2
            USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8000b94:	ea23 0302 	bic.w	r3, r3, r2
 8000b98:	634b      	str	r3, [r1, #52]	; 0x34
            if (hpcd->Init.dma_enable == 1U)
 8000b9a:	6921      	ldr	r1, [r4, #16]
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_XFRC);
 8000b9c:	f8c9 0008 	str.w	r0, [r9, #8]
            if (hpcd->Init.dma_enable == 1U)
 8000ba0:	4281      	cmp	r1, r0
 8000ba2:	f000 8178 	beq.w	8000e96 <HAL_PCD_IRQHandler+0x85e>
            HAL_PCD_DataInStageCallback(hpcd, (uint8_t)epnum);
 8000ba6:	4651      	mov	r1, sl
 8000ba8:	4620      	mov	r0, r4
 8000baa:	f000 fd57 	bl	800165c <HAL_PCD_DataInStageCallback>
          if ((epint & USB_OTG_DIEPINT_TOC) == USB_OTG_DIEPINT_TOC)
 8000bae:	072b      	lsls	r3, r5, #28
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_TOC);
 8000bb0:	bf44      	itt	mi
 8000bb2:	2308      	movmi	r3, #8
 8000bb4:	f8c9 3008 	strmi.w	r3, [r9, #8]
          if ((epint & USB_OTG_DIEPINT_ITTXFE) == USB_OTG_DIEPINT_ITTXFE)
 8000bb8:	06e8      	lsls	r0, r5, #27
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_ITTXFE);
 8000bba:	bf44      	itt	mi
 8000bbc:	2310      	movmi	r3, #16
 8000bbe:	f8c9 3008 	strmi.w	r3, [r9, #8]
          if ((epint & USB_OTG_DIEPINT_INEPNE) == USB_OTG_DIEPINT_INEPNE)
 8000bc2:	0669      	lsls	r1, r5, #25
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_INEPNE);
 8000bc4:	bf44      	itt	mi
 8000bc6:	2340      	movmi	r3, #64	; 0x40
 8000bc8:	f8c9 3008 	strmi.w	r3, [r9, #8]
          if ((epint & USB_OTG_DIEPINT_EPDISD) == USB_OTG_DIEPINT_EPDISD)
 8000bcc:	07aa      	lsls	r2, r5, #30
 8000bce:	f100 8130 	bmi.w	8000e32 <HAL_PCD_IRQHandler+0x7fa>
          if ((epint & USB_OTG_DIEPINT_TXFE) == USB_OTG_DIEPINT_TXFE)
 8000bd2:	062b      	lsls	r3, r5, #24
 8000bd4:	f100 80d7 	bmi.w	8000d86 <HAL_PCD_IRQHandler+0x74e>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT))
 8000bd8:	6820      	ldr	r0, [r4, #0]
 8000bda:	e7bf      	b.n	8000b5c <HAL_PCD_IRQHandler+0x524>
      ep_intr = USB_ReadDevAllOutEpInterrupt(hpcd->Instance);
 8000bdc:	6820      	ldr	r0, [r4, #0]
 8000bde:	f004 fc97 	bl	8005510 <USB_ReadDevAllOutEpInterrupt>
      while (ep_intr != 0U)
 8000be2:	4606      	mov	r6, r0
 8000be4:	2800      	cmp	r0, #0
 8000be6:	f43f ad6b 	beq.w	80006c0 <HAL_PCD_IRQHandler+0x88>
 8000bea:	f505 6730 	add.w	r7, r5, #2816	; 0xb00
 8000bee:	46a2      	mov	sl, r4
      epnum = 0U;
 8000bf0:	f04f 0900 	mov.w	r9, #0
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_NAK);
 8000bf4:	f8cd b010 	str.w	fp, [sp, #16]
 8000bf8:	e007      	b.n	8000c0a <HAL_PCD_IRQHandler+0x5d2>
      while (ep_intr != 0U)
 8000bfa:	0876      	lsrs	r6, r6, #1
        epnum++;
 8000bfc:	f109 0901 	add.w	r9, r9, #1
      while (ep_intr != 0U)
 8000c00:	f107 0720 	add.w	r7, r7, #32
 8000c04:	f10a 0a24 	add.w	sl, sl, #36	; 0x24
 8000c08:	d07c      	beq.n	8000d04 <HAL_PCD_IRQHandler+0x6cc>
        if ((ep_intr & 0x1U) != 0U)
 8000c0a:	07f0      	lsls	r0, r6, #31
 8000c0c:	d5f5      	bpl.n	8000bfa <HAL_PCD_IRQHandler+0x5c2>
          epint = USB_ReadDevOutEPInterrupt(hpcd->Instance, (uint8_t)epnum);
 8000c0e:	fa5f fb89 	uxtb.w	fp, r9
 8000c12:	6820      	ldr	r0, [r4, #0]
 8000c14:	4659      	mov	r1, fp
 8000c16:	f004 fc8b 	bl	8005530 <USB_ReadDevOutEPInterrupt>
          if ((epint & USB_OTG_DOEPINT_XFRC) == USB_OTG_DOEPINT_XFRC)
 8000c1a:	f010 0f01 	tst.w	r0, #1
          epint = USB_ReadDevOutEPInterrupt(hpcd->Instance, (uint8_t)epnum);
 8000c1e:	4680      	mov	r8, r0
          if ((epint & USB_OTG_DOEPINT_XFRC) == USB_OTG_DOEPINT_XFRC)
 8000c20:	f040 8092 	bne.w	8000d48 <HAL_PCD_IRQHandler+0x710>
          if ((epint & USB_OTG_DOEPINT_STUP) == USB_OTG_DOEPINT_STUP)
 8000c24:	f018 0f08 	tst.w	r8, #8
 8000c28:	d16f      	bne.n	8000d0a <HAL_PCD_IRQHandler+0x6d2>
          if ((epint & USB_OTG_DOEPINT_OTEPDIS) == USB_OTG_DOEPINT_OTEPDIS)
 8000c2a:	f018 0f10 	tst.w	r8, #16
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPDIS);
 8000c2e:	bf1c      	itt	ne
 8000c30:	2210      	movne	r2, #16
 8000c32:	60ba      	strne	r2, [r7, #8]
          if ((epint & USB_OTG_DOEPINT_EPDISD) == USB_OTG_DOEPINT_EPDISD)
 8000c34:	f018 0f02 	tst.w	r8, #2
 8000c38:	d00e      	beq.n	8000c58 <HAL_PCD_IRQHandler+0x620>
            if ((USBx->GINTSTS & USB_OTG_GINTSTS_BOUTNAKEFF) == USB_OTG_GINTSTS_BOUTNAKEFF)
 8000c3a:	696a      	ldr	r2, [r5, #20]
 8000c3c:	0611      	lsls	r1, r2, #24
 8000c3e:	d504      	bpl.n	8000c4a <HAL_PCD_IRQHandler+0x612>
              USBx_DEVICE->DCTL |= USB_OTG_DCTL_CGONAK;
 8000c40:	9b03      	ldr	r3, [sp, #12]
 8000c42:	685a      	ldr	r2, [r3, #4]
 8000c44:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8000c48:	605a      	str	r2, [r3, #4]
            if (ep->is_iso_incomplete == 1U)
 8000c4a:	f89a 227f 	ldrb.w	r2, [sl, #639]	; 0x27f
 8000c4e:	2a01      	cmp	r2, #1
 8000c50:	f000 8156 	beq.w	8000f00 <HAL_PCD_IRQHandler+0x8c8>
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_EPDISD);
 8000c54:	2302      	movs	r3, #2
 8000c56:	60bb      	str	r3, [r7, #8]
          if ((epint & USB_OTG_DOEPINT_OTEPSPR) == USB_OTG_DOEPINT_OTEPSPR)
 8000c58:	f018 0f20 	tst.w	r8, #32
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPSPR);
 8000c5c:	bf1c      	itt	ne
 8000c5e:	2320      	movne	r3, #32
 8000c60:	60bb      	strne	r3, [r7, #8]
          if ((epint & USB_OTG_DOEPINT_NAK) == USB_OTG_DOEPINT_NAK)
 8000c62:	f418 5f00 	tst.w	r8, #8192	; 0x2000
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_NAK);
 8000c66:	bf1c      	itt	ne
 8000c68:	f44f 5300 	movne.w	r3, #8192	; 0x2000
 8000c6c:	60bb      	strne	r3, [r7, #8]
 8000c6e:	e7c4      	b.n	8000bfa <HAL_PCD_IRQHandler+0x5c2>
        USBx_DEVICE->DOUTEP1MSK |= USB_OTG_DOEPMSK_STUPM |
 8000c70:	f8d1 3084 	ldr.w	r3, [r1, #132]	; 0x84
 8000c74:	f043 030b 	orr.w	r3, r3, #11
 8000c78:	f8c1 3084 	str.w	r3, [r1, #132]	; 0x84
        USBx_DEVICE->DINEP1MSK |= USB_OTG_DIEPMSK_TOM |
 8000c7c:	6c4b      	ldr	r3, [r1, #68]	; 0x44
 8000c7e:	f043 030b 	orr.w	r3, r3, #11
 8000c82:	644b      	str	r3, [r1, #68]	; 0x44
 8000c84:	e734      	b.n	8000af0 <HAL_PCD_IRQHandler+0x4b8>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 8000c86:	2900      	cmp	r1, #0
          hpcd->IN_ep[epnum].is_iso_incomplete = 1U;
 8000c88:	bfb8      	it	lt
 8000c8a:	f884 2063 	strblt.w	r2, [r4, #99]	; 0x63
 8000c8e:	e5c4      	b.n	800081a <HAL_PCD_IRQHandler+0x1e2>
        hpcd->LPM_State = LPM_L0;
 8000c90:	2100      	movs	r1, #0
 8000c92:	f884 14f4 	strb.w	r1, [r4, #1268]	; 0x4f4
        HAL_PCDEx_LPM_Callback(hpcd, PCD_LPM_L0_ACTIVE);
 8000c96:	4620      	mov	r0, r4
 8000c98:	f002 fba8 	bl	80033ec <HAL_PCDEx_LPM_Callback>
 8000c9c:	e6d0      	b.n	8000a40 <HAL_PCD_IRQHandler+0x408>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 8000c9e:	2900      	cmp	r1, #0
          hpcd->IN_ep[epnum].is_iso_incomplete = 1U;
 8000ca0:	bfb8      	it	lt
 8000ca2:	f884 2087 	strblt.w	r2, [r4, #135]	; 0x87
 8000ca6:	e5c2      	b.n	800082e <HAL_PCD_IRQHandler+0x1f6>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 8000ca8:	2900      	cmp	r1, #0
          hpcd->IN_ep[epnum].is_iso_incomplete = 1U;
 8000caa:	bfb8      	it	lt
 8000cac:	f884 20ab 	strblt.w	r2, [r4, #171]	; 0xab
 8000cb0:	e5c7      	b.n	8000842 <HAL_PCD_IRQHandler+0x20a>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 8000cb2:	2900      	cmp	r1, #0
          hpcd->IN_ep[epnum].is_iso_incomplete = 1U;
 8000cb4:	bfb8      	it	lt
 8000cb6:	f884 20cf 	strblt.w	r2, [r4, #207]	; 0xcf
 8000cba:	e5cc      	b.n	8000856 <HAL_PCD_IRQHandler+0x21e>
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 8000cbc:	6820      	ldr	r0, [r4, #0]
 8000cbe:	f504 713a 	add.w	r1, r4, #744	; 0x2e8
 8000cc2:	f004 fb15 	bl	80052f0 <USB_EPStopXfer>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8000cc6:	6863      	ldr	r3, [r4, #4]
 8000cc8:	e53e      	b.n	8000748 <HAL_PCD_IRQHandler+0x110>
        (void)USB_ReadPacket(USBx, (uint8_t *)hpcd->Setup, 8U);
 8000cca:	2208      	movs	r2, #8
 8000ccc:	f204 41c4 	addw	r1, r4, #1220	; 0x4c4
 8000cd0:	4628      	mov	r0, r5
        ep->xfer_count += (RegVal & USB_OTG_GRXSTSP_BCNT) >> 4;
 8000cd2:	eb07 07c7 	add.w	r7, r7, r7, lsl #3
        (void)USB_ReadPacket(USBx, (uint8_t *)hpcd->Setup, 8U);
 8000cd6:	f004 fb65 	bl	80053a4 <USB_ReadPacket>
        ep->xfer_count += (RegVal & USB_OTG_GRXSTSP_BCNT) >> 4;
 8000cda:	eb04 0287 	add.w	r2, r4, r7, lsl #2
 8000cde:	f3c6 130a 	ubfx	r3, r6, #4, #11
 8000ce2:	f8d2 129c 	ldr.w	r1, [r2, #668]	; 0x29c
      USB_UNMASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 8000ce6:	6820      	ldr	r0, [r4, #0]
        ep->xfer_count += (RegVal & USB_OTG_GRXSTSP_BCNT) >> 4;
 8000ce8:	440b      	add	r3, r1
 8000cea:	f8c2 329c 	str.w	r3, [r2, #668]	; 0x29c
 8000cee:	e4de      	b.n	80006ae <HAL_PCD_IRQHandler+0x76>
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 8000cf0:	6820      	ldr	r0, [r4, #0]
 8000cf2:	f504 7143 	add.w	r1, r4, #780	; 0x30c
 8000cf6:	f004 fafb 	bl	80052f0 <USB_EPStopXfer>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8000cfa:	6863      	ldr	r3, [r4, #4]
 8000cfc:	e52b      	b.n	8000756 <HAL_PCD_IRQHandler+0x11e>
 8000cfe:	e9dd 5b04 	ldrd	r5, fp, [sp, #16]
 8000d02:	e4e4      	b.n	80006ce <HAL_PCD_IRQHandler+0x96>
 8000d04:	f8dd b010 	ldr.w	fp, [sp, #16]
 8000d08:	e4da      	b.n	80006c0 <HAL_PCD_IRQHandler+0x88>
  * @param  epnum endpoint number
  * @retval HAL status
  */
static HAL_StatusTypeDef PCD_EP_OutSetupPacket_int(PCD_HandleTypeDef *hpcd, uint32_t epnum)
{
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 8000d0a:	6821      	ldr	r1, [r4, #0]
  uint32_t USBx_BASE = (uint32_t)USBx;
  uint32_t gSNPSiD = *(__IO uint32_t *)(&USBx->CID + 0x1U);
  uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;

  if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 8000d0c:	4bab      	ldr	r3, [pc, #684]	; (8000fbc <HAL_PCD_IRQHandler+0x984>)
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STUP);
 8000d0e:	2208      	movs	r2, #8
 8000d10:	60ba      	str	r2, [r7, #8]
  uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;
 8000d12:	f501 6230 	add.w	r2, r1, #2816	; 0xb00
  uint32_t gSNPSiD = *(__IO uint32_t *)(&USBx->CID + 0x1U);
 8000d16:	6c09      	ldr	r1, [r1, #64]	; 0x40
  uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;
 8000d18:	eb02 1249 	add.w	r2, r2, r9, lsl #5
  if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 8000d1c:	4299      	cmp	r1, r3
  uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;
 8000d1e:	6890      	ldr	r0, [r2, #8]
  if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 8000d20:	f240 80ca 	bls.w	8000eb8 <HAL_PCD_IRQHandler+0x880>
 8000d24:	0400      	lsls	r0, r0, #16
 8000d26:	d502      	bpl.n	8000d2e <HAL_PCD_IRQHandler+0x6f6>
      ((DoepintReg & USB_OTG_DOEPINT_STPKTRX) == USB_OTG_DOEPINT_STPKTRX))
  {
    CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);
 8000d28:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8000d2c:	6091      	str	r1, [r2, #8]

  /* Inform the upper layer that a setup packet is available */
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
  hpcd->SetupStageCallback(hpcd);
#else
  HAL_PCD_SetupStageCallback(hpcd);
 8000d2e:	4620      	mov	r0, r4
 8000d30:	f000 fc84 	bl	800163c <HAL_PCD_SetupStageCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

  if ((gSNPSiD > USB_OTG_CORE_ID_300A) && (hpcd->Init.dma_enable == 1U))
 8000d34:	6921      	ldr	r1, [r4, #16]
 8000d36:	2901      	cmp	r1, #1
 8000d38:	f47f af77 	bne.w	8000c2a <HAL_PCD_IRQHandler+0x5f2>
  {
    (void)USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
 8000d3c:	6820      	ldr	r0, [r4, #0]
 8000d3e:	f204 42c4 	addw	r2, r4, #1220	; 0x4c4
 8000d42:	f004 fc25 	bl	8005590 <USB_EP0_OutStart>
 8000d46:	e770      	b.n	8000c2a <HAL_PCD_IRQHandler+0x5f2>
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 8000d48:	6820      	ldr	r0, [r4, #0]
  if (hpcd->Init.dma_enable == 1U)
 8000d4a:	6921      	ldr	r1, [r4, #16]
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_XFRC);
 8000d4c:	2201      	movs	r2, #1
 8000d4e:	60ba      	str	r2, [r7, #8]
  uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;
 8000d50:	f500 6230 	add.w	r2, r0, #2816	; 0xb00
 8000d54:	eb02 1249 	add.w	r2, r2, r9, lsl #5
  if (hpcd->Init.dma_enable == 1U)
 8000d58:	2901      	cmp	r1, #1
  uint32_t gSNPSiD = *(__IO uint32_t *)(&USBx->CID + 0x1U);
 8000d5a:	f8d0 c040 	ldr.w	ip, [r0, #64]	; 0x40
  uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;
 8000d5e:	6893      	ldr	r3, [r2, #8]
  if (hpcd->Init.dma_enable == 1U)
 8000d60:	f000 80ae 	beq.w	8000ec0 <HAL_PCD_IRQHandler+0x888>
    if (gSNPSiD == USB_OTG_CORE_ID_310A)
 8000d64:	4996      	ldr	r1, [pc, #600]	; (8000fc0 <HAL_PCD_IRQHandler+0x988>)
 8000d66:	458c      	cmp	ip, r1
 8000d68:	f000 80d9 	beq.w	8000f1e <HAL_PCD_IRQHandler+0x8e6>
      if ((epnum == 0U) && (hpcd->OUT_ep[epnum].xfer_len == 0U))
 8000d6c:	f1b9 0f00 	cmp.w	r9, #0
 8000d70:	d104      	bne.n	8000d7c <HAL_PCD_IRQHandler+0x744>
 8000d72:	f8d4 2294 	ldr.w	r2, [r4, #660]	; 0x294
 8000d76:	2a00      	cmp	r2, #0
 8000d78:	f000 814b 	beq.w	8001012 <HAL_PCD_IRQHandler+0x9da>
      HAL_PCD_DataOutStageCallback(hpcd, (uint8_t)epnum);
 8000d7c:	4659      	mov	r1, fp
 8000d7e:	4620      	mov	r0, r4
 8000d80:	f000 fc62 	bl	8001648 <HAL_PCD_DataOutStageCallback>
 8000d84:	e74e      	b.n	8000c24 <HAL_PCD_IRQHandler+0x5ec>
  if (ep->xfer_count > ep->xfer_len)
 8000d86:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8000d88:	6d7d      	ldr	r5, [r7, #84]	; 0x54
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 8000d8a:	f8d4 b000 	ldr.w	fp, [r4]
  if (ep->xfer_count > ep->xfer_len)
 8000d8e:	42ab      	cmp	r3, r5
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 8000d90:	4658      	mov	r0, fp
  if (ep->xfer_count > ep->xfer_len)
 8000d92:	f63f aee3 	bhi.w	8000b5c <HAL_PCD_IRQHandler+0x524>
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 8000d96:	f50b 6210 	add.w	r2, fp, #2304	; 0x900
 8000d9a:	eb02 1246 	add.w	r2, r2, r6, lsl #5
 8000d9e:	4611      	mov	r1, r2
 8000da0:	4696      	mov	lr, r2
  len32b = (len + 3U) / 4U;
 8000da2:	6cba      	ldr	r2, [r7, #72]	; 0x48
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 8000da4:	6989      	ldr	r1, [r1, #24]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8000da6:	f8cd b01c 	str.w	fp, [sp, #28]
  len = ep->xfer_len - ep->xfer_count;
 8000daa:	eba5 0c03 	sub.w	ip, r5, r3
  len32b = (len + 3U) / 4U;
 8000dae:	4562      	cmp	r2, ip
 8000db0:	bf28      	it	cs
 8000db2:	4662      	movcs	r2, ip
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 8000db4:	b289      	uxth	r1, r1
  len32b = (len + 3U) / 4U;
 8000db6:	3203      	adds	r2, #3
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 8000db8:	ebb1 0f92 	cmp.w	r1, r2, lsr #2
 8000dbc:	f0c0 8095 	bcc.w	8000eea <HAL_PCD_IRQHandler+0x8b2>
 8000dc0:	4652      	mov	r2, sl
 8000dc2:	9606      	str	r6, [sp, #24]
 8000dc4:	46ca      	mov	sl, r9
 8000dc6:	4626      	mov	r6, r4
 8000dc8:	46c1      	mov	r9, r8
 8000dca:	4674      	mov	r4, lr
 8000dcc:	4690      	mov	r8, r2
 8000dce:	e019      	b.n	8000e04 <HAL_PCD_IRQHandler+0x7cc>
    len = ep->xfer_len - ep->xfer_count;
 8000dd0:	1aed      	subs	r5, r5, r3
    if (len > ep->maxpacket)
 8000dd2:	6cbb      	ldr	r3, [r7, #72]	; 0x48
    (void)USB_WritePacket(USBx, ep->xfer_buff, (uint8_t)epnum, (uint16_t)len,
 8000dd4:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
 8000dd6:	429d      	cmp	r5, r3
 8000dd8:	bf28      	it	cs
 8000dda:	461d      	movcs	r5, r3
 8000ddc:	7c33      	ldrb	r3, [r6, #16]
 8000dde:	9300      	str	r3, [sp, #0]
 8000de0:	4642      	mov	r2, r8
 8000de2:	b2ab      	uxth	r3, r5
 8000de4:	4658      	mov	r0, fp
 8000de6:	f004 fac7 	bl	8005378 <USB_WritePacket>
    ep->xfer_buff  += len;
 8000dea:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 8000dec:	69a1      	ldr	r1, [r4, #24]
    ep->xfer_buff  += len;
 8000dee:	442b      	add	r3, r5
 8000df0:	64fb      	str	r3, [r7, #76]	; 0x4c
    ep->xfer_count += len;
 8000df2:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 8000df4:	b289      	uxth	r1, r1
    ep->xfer_count += len;
 8000df6:	442b      	add	r3, r5
    len32b = (len + 3U) / 4U;
 8000df8:	3503      	adds	r5, #3
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 8000dfa:	ebb1 0f95 	cmp.w	r1, r5, lsr #2
    ep->xfer_count += len;
 8000dfe:	65fb      	str	r3, [r7, #92]	; 0x5c
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 8000e00:	d36b      	bcc.n	8000eda <HAL_PCD_IRQHandler+0x8a2>
         (ep->xfer_count < ep->xfer_len) && (ep->xfer_len != 0U))
 8000e02:	6d7d      	ldr	r5, [r7, #84]	; 0x54
 8000e04:	42ab      	cmp	r3, r5
 8000e06:	d3e3      	bcc.n	8000dd0 <HAL_PCD_IRQHandler+0x798>
 8000e08:	4634      	mov	r4, r6
 8000e0a:	9e06      	ldr	r6, [sp, #24]
 8000e0c:	f8d4 b000 	ldr.w	fp, [r4]
 8000e10:	46c8      	mov	r8, r9
 8000e12:	46d1      	mov	r9, sl
    USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8000e14:	9b07      	ldr	r3, [sp, #28]
    fifoemptymsk = (uint32_t)(0x1UL << (epnum & EP_ADDR_MSK));
 8000e16:	f006 020f 	and.w	r2, r6, #15
    USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8000e1a:	f503 6100 	add.w	r1, r3, #2048	; 0x800
    fifoemptymsk = (uint32_t)(0x1UL << (epnum & EP_ADDR_MSK));
 8000e1e:	2501      	movs	r5, #1
    USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8000e20:	f8d3 3834 	ldr.w	r3, [r3, #2100]	; 0x834
    fifoemptymsk = (uint32_t)(0x1UL << (epnum & EP_ADDR_MSK));
 8000e24:	fa05 f202 	lsl.w	r2, r5, r2
    USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8000e28:	ea23 0302 	bic.w	r3, r3, r2
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT))
 8000e2c:	4658      	mov	r0, fp
    USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8000e2e:	634b      	str	r3, [r1, #52]	; 0x34
 8000e30:	e694      	b.n	8000b5c <HAL_PCD_IRQHandler+0x524>
            (void)USB_FlushTxFifo(USBx, epnum);
 8000e32:	9804      	ldr	r0, [sp, #16]
 8000e34:	4631      	mov	r1, r6
 8000e36:	f003 ff97 	bl	8004d68 <USB_FlushTxFifo>
            if (ep->is_iso_incomplete == 1U)
 8000e3a:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 8000e3e:	2b01      	cmp	r3, #1
 8000e40:	d075      	beq.n	8000f2e <HAL_PCD_IRQHandler+0x8f6>
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_EPDISD);
 8000e42:	2302      	movs	r3, #2
 8000e44:	f8c9 3008 	str.w	r3, [r9, #8]
 8000e48:	e6c3      	b.n	8000bd2 <HAL_PCD_IRQHandler+0x59a>
        if ((RegVal & USB_OTG_GRXSTSP_BCNT) != 0U)
 8000e4a:	f647 73f0 	movw	r3, #32752	; 0x7ff0
 8000e4e:	421e      	tst	r6, r3
 8000e50:	f43f ac2d 	beq.w	80006ae <HAL_PCD_IRQHandler+0x76>
          (void)USB_ReadPacket(USBx, ep->xfer_buff,
 8000e54:	eb07 07c7 	add.w	r7, r7, r7, lsl #3
 8000e58:	eb04 0787 	add.w	r7, r4, r7, lsl #2
 8000e5c:	f3c6 120a 	ubfx	r2, r6, #4, #11
 8000e60:	f8d7 128c 	ldr.w	r1, [r7, #652]	; 0x28c
 8000e64:	4628      	mov	r0, r5
 8000e66:	4616      	mov	r6, r2
 8000e68:	f004 fa9c 	bl	80053a4 <USB_ReadPacket>
          ep->xfer_buff += (RegVal & USB_OTG_GRXSTSP_BCNT) >> 4;
 8000e6c:	f8d7 328c 	ldr.w	r3, [r7, #652]	; 0x28c
      USB_UNMASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 8000e70:	6820      	ldr	r0, [r4, #0]
          ep->xfer_buff += (RegVal & USB_OTG_GRXSTSP_BCNT) >> 4;
 8000e72:	4433      	add	r3, r6
 8000e74:	f8c7 328c 	str.w	r3, [r7, #652]	; 0x28c
          ep->xfer_count += (RegVal & USB_OTG_GRXSTSP_BCNT) >> 4;
 8000e78:	f8d7 329c 	ldr.w	r3, [r7, #668]	; 0x29c
 8000e7c:	4433      	add	r3, r6
 8000e7e:	f8c7 329c 	str.w	r3, [r7, #668]	; 0x29c
 8000e82:	e414      	b.n	80006ae <HAL_PCD_IRQHandler+0x76>
        HAL_PCD_SuspendCallback(hpcd);
 8000e84:	4620      	mov	r0, r4
 8000e86:	f000 fc07 	bl	8001698 <HAL_PCD_SuspendCallback>
 8000e8a:	e592      	b.n	80009b2 <HAL_PCD_IRQHandler+0x37a>
        HAL_PCD_DisconnectCallback(hpcd);
 8000e8c:	4620      	mov	r0, r4
 8000e8e:	f000 fc17 	bl	80016c0 <HAL_PCD_DisconnectCallback>
      hpcd->Instance->GOTGINT |= RegVal;
 8000e92:	6823      	ldr	r3, [r4, #0]
 8000e94:	e582      	b.n	800099c <HAL_PCD_IRQHandler+0x364>
              hpcd->IN_ep[epnum].xfer_buff += hpcd->IN_ep[epnum].maxpacket;
 8000e96:	e9d7 2312 	ldrd	r2, r3, [r7, #72]	; 0x48
 8000e9a:	4413      	add	r3, r2
 8000e9c:	64fb      	str	r3, [r7, #76]	; 0x4c
              if ((epnum == 0U) && (hpcd->IN_ep[epnum].xfer_len == 0U))
 8000e9e:	2e00      	cmp	r6, #0
 8000ea0:	f47f ae81 	bne.w	8000ba6 <HAL_PCD_IRQHandler+0x56e>
 8000ea4:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8000ea6:	2b00      	cmp	r3, #0
 8000ea8:	f47f ae7d 	bne.w	8000ba6 <HAL_PCD_IRQHandler+0x56e>
                (void)USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
 8000eac:	6820      	ldr	r0, [r4, #0]
 8000eae:	f204 42c4 	addw	r2, r4, #1220	; 0x4c4
 8000eb2:	f004 fb6d 	bl	8005590 <USB_EP0_OutStart>
 8000eb6:	e676      	b.n	8000ba6 <HAL_PCD_IRQHandler+0x56e>
  HAL_PCD_SetupStageCallback(hpcd);
 8000eb8:	4620      	mov	r0, r4
 8000eba:	f000 fbbf 	bl	800163c <HAL_PCD_SetupStageCallback>
  if ((gSNPSiD > USB_OTG_CORE_ID_300A) && (hpcd->Init.dma_enable == 1U))
 8000ebe:	e6b4      	b.n	8000c2a <HAL_PCD_IRQHandler+0x5f2>
    if ((DoepintReg & USB_OTG_DOEPINT_STUP) == USB_OTG_DOEPINT_STUP) /* Class C */
 8000ec0:	0719      	lsls	r1, r3, #28
 8000ec2:	d54b      	bpl.n	8000f5c <HAL_PCD_IRQHandler+0x924>
      if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 8000ec4:	493d      	ldr	r1, [pc, #244]	; (8000fbc <HAL_PCD_IRQHandler+0x984>)
 8000ec6:	458c      	cmp	ip, r1
 8000ec8:	f67f aeac 	bls.w	8000c24 <HAL_PCD_IRQHandler+0x5ec>
 8000ecc:	0418      	lsls	r0, r3, #16
 8000ece:	f57f aea9 	bpl.w	8000c24 <HAL_PCD_IRQHandler+0x5ec>
        CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);
 8000ed2:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8000ed6:	6091      	str	r1, [r2, #8]
 8000ed8:	e6a4      	b.n	8000c24 <HAL_PCD_IRQHandler+0x5ec>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT))
 8000eda:	4634      	mov	r4, r6
  if (ep->xfer_len <= ep->xfer_count)
 8000edc:	6d7d      	ldr	r5, [r7, #84]	; 0x54
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT))
 8000ede:	f8d4 b000 	ldr.w	fp, [r4]
 8000ee2:	9e06      	ldr	r6, [sp, #24]
 8000ee4:	46c8      	mov	r8, r9
 8000ee6:	4658      	mov	r0, fp
 8000ee8:	46d1      	mov	r9, sl
  if (ep->xfer_len <= ep->xfer_count)
 8000eea:	42ab      	cmp	r3, r5
 8000eec:	f4ff ae36 	bcc.w	8000b5c <HAL_PCD_IRQHandler+0x524>
 8000ef0:	e790      	b.n	8000e14 <HAL_PCD_IRQHandler+0x7dc>
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 8000ef2:	6820      	ldr	r0, [r4, #0]
 8000ef4:	f504 7128 	add.w	r1, r4, #672	; 0x2a0
 8000ef8:	f004 f9fa 	bl	80052f0 <USB_EPStopXfer>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8000efc:	6863      	ldr	r3, [r4, #4]
 8000efe:	e415      	b.n	800072c <HAL_PCD_IRQHandler+0xf4>
              ep->is_iso_incomplete = 0U;
 8000f00:	2300      	movs	r3, #0
              HAL_PCD_ISOOUTIncompleteCallback(hpcd, (uint8_t)epnum);
 8000f02:	4659      	mov	r1, fp
              ep->is_iso_incomplete = 0U;
 8000f04:	f88a 327f 	strb.w	r3, [sl, #639]	; 0x27f
              HAL_PCD_ISOOUTIncompleteCallback(hpcd, (uint8_t)epnum);
 8000f08:	4620      	mov	r0, r4
 8000f0a:	f000 fbcd 	bl	80016a8 <HAL_PCD_ISOOUTIncompleteCallback>
 8000f0e:	e6a1      	b.n	8000c54 <HAL_PCD_IRQHandler+0x61c>
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 8000f10:	6820      	ldr	r0, [r4, #0]
 8000f12:	f504 7131 	add.w	r1, r4, #708	; 0x2c4
 8000f16:	f004 f9eb 	bl	80052f0 <USB_EPStopXfer>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8000f1a:	6863      	ldr	r3, [r4, #4]
 8000f1c:	e40d      	b.n	800073a <HAL_PCD_IRQHandler+0x102>
      if ((DoepintReg & USB_OTG_DOEPINT_STPKTRX) == USB_OTG_DOEPINT_STPKTRX)
 8000f1e:	0419      	lsls	r1, r3, #16
 8000f20:	d4d7      	bmi.n	8000ed2 <HAL_PCD_IRQHandler+0x89a>
        if ((DoepintReg & USB_OTG_DOEPINT_OTEPSPR) == USB_OTG_DOEPINT_OTEPSPR)
 8000f22:	069b      	lsls	r3, r3, #26
 8000f24:	f57f af2a 	bpl.w	8000d7c <HAL_PCD_IRQHandler+0x744>
          CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPSPR);
 8000f28:	2120      	movs	r1, #32
 8000f2a:	6091      	str	r1, [r2, #8]
        HAL_PCD_DataOutStageCallback(hpcd, (uint8_t)epnum);
 8000f2c:	e726      	b.n	8000d7c <HAL_PCD_IRQHandler+0x744>
              ep->is_iso_incomplete = 0U;
 8000f2e:	f04f 0300 	mov.w	r3, #0
 8000f32:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
              HAL_PCD_ISOINIncompleteCallback(hpcd, (uint8_t)epnum);
 8000f36:	4651      	mov	r1, sl
 8000f38:	4620      	mov	r0, r4
 8000f3a:	f000 fbb9 	bl	80016b0 <HAL_PCD_ISOINIncompleteCallback>
 8000f3e:	e780      	b.n	8000e42 <HAL_PCD_IRQHandler+0x80a>
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 8000f40:	6820      	ldr	r0, [r4, #0]
 8000f42:	f504 714c 	add.w	r1, r4, #816	; 0x330
 8000f46:	f004 f9d3 	bl	80052f0 <USB_EPStopXfer>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8000f4a:	6863      	ldr	r3, [r4, #4]
 8000f4c:	e40a      	b.n	8000764 <HAL_PCD_IRQHandler+0x12c>
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 8000f4e:	6820      	ldr	r0, [r4, #0]
 8000f50:	f504 7155 	add.w	r1, r4, #852	; 0x354
 8000f54:	f004 f9cc 	bl	80052f0 <USB_EPStopXfer>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8000f58:	6863      	ldr	r3, [r4, #4]
 8000f5a:	e40a      	b.n	8000772 <HAL_PCD_IRQHandler+0x13a>
    else if ((DoepintReg & USB_OTG_DOEPINT_OTEPSPR) == USB_OTG_DOEPINT_OTEPSPR) /* Class E */
 8000f5c:	0699      	lsls	r1, r3, #26
 8000f5e:	d531      	bpl.n	8000fc4 <HAL_PCD_IRQHandler+0x98c>
      CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPSPR);
 8000f60:	2120      	movs	r1, #32
 8000f62:	6091      	str	r1, [r2, #8]
 8000f64:	e65e      	b.n	8000c24 <HAL_PCD_IRQHandler+0x5ec>
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 8000f66:	6820      	ldr	r0, [r4, #0]
 8000f68:	f504 715e 	add.w	r1, r4, #888	; 0x378
 8000f6c:	f004 f9c0 	bl	80052f0 <USB_EPStopXfer>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8000f70:	6863      	ldr	r3, [r4, #4]
 8000f72:	e405      	b.n	8000780 <HAL_PCD_IRQHandler+0x148>
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 8000f74:	6820      	ldr	r0, [r4, #0]
 8000f76:	f504 7167 	add.w	r1, r4, #924	; 0x39c
 8000f7a:	f004 f9b9 	bl	80052f0 <USB_EPStopXfer>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8000f7e:	6863      	ldr	r3, [r4, #4]
 8000f80:	e405      	b.n	800078e <HAL_PCD_IRQHandler+0x156>
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 8000f82:	6820      	ldr	r0, [r4, #0]
 8000f84:	f504 7170 	add.w	r1, r4, #960	; 0x3c0
 8000f88:	f004 f9b2 	bl	80052f0 <USB_EPStopXfer>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8000f8c:	6863      	ldr	r3, [r4, #4]
 8000f8e:	e405      	b.n	800079c <HAL_PCD_IRQHandler+0x164>
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 8000f90:	6820      	ldr	r0, [r4, #0]
 8000f92:	f504 7179 	add.w	r1, r4, #996	; 0x3e4
 8000f96:	f004 f9ab 	bl	80052f0 <USB_EPStopXfer>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8000f9a:	6863      	ldr	r3, [r4, #4]
 8000f9c:	e405      	b.n	80007aa <HAL_PCD_IRQHandler+0x172>
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 8000f9e:	6820      	ldr	r0, [r4, #0]
 8000fa0:	f504 6181 	add.w	r1, r4, #1032	; 0x408
 8000fa4:	f004 f9a4 	bl	80052f0 <USB_EPStopXfer>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8000fa8:	6863      	ldr	r3, [r4, #4]
 8000faa:	e405      	b.n	80007b8 <HAL_PCD_IRQHandler+0x180>
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 8000fac:	6820      	ldr	r0, [r4, #0]
 8000fae:	f204 412c 	addw	r1, r4, #1068	; 0x42c
 8000fb2:	f004 f99d 	bl	80052f0 <USB_EPStopXfer>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8000fb6:	6863      	ldr	r3, [r4, #4]
 8000fb8:	e405      	b.n	80007c6 <HAL_PCD_IRQHandler+0x18e>
 8000fba:	bf00      	nop
 8000fbc:	4f54300a 	.word	0x4f54300a
 8000fc0:	4f54310a 	.word	0x4f54310a
    else if ((DoepintReg & (USB_OTG_DOEPINT_STUP | USB_OTG_DOEPINT_OTEPSPR)) == 0U)
 8000fc4:	f013 0f28 	tst.w	r3, #40	; 0x28
 8000fc8:	f47f ae2c 	bne.w	8000c24 <HAL_PCD_IRQHandler+0x5ec>
      if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 8000fcc:	491b      	ldr	r1, [pc, #108]	; (800103c <HAL_PCD_IRQHandler+0xa04>)
 8000fce:	458c      	cmp	ip, r1
 8000fd0:	d902      	bls.n	8000fd8 <HAL_PCD_IRQHandler+0x9a0>
 8000fd2:	041b      	lsls	r3, r3, #16
 8000fd4:	f53f af7d 	bmi.w	8000ed2 <HAL_PCD_IRQHandler+0x89a>
        ep->xfer_count = ep->xfer_size - (USBx_OUTEP(epnum)->DOEPTSIZ & USB_OTG_DOEPTSIZ_XFRSIZ);
 8000fd8:	6911      	ldr	r1, [r2, #16]
 8000fda:	f8da 2298 	ldr.w	r2, [sl, #664]	; 0x298
 8000fde:	f3c1 0112 	ubfx	r1, r1, #0, #19
 8000fe2:	1a52      	subs	r2, r2, r1
 8000fe4:	f8ca 229c 	str.w	r2, [sl, #668]	; 0x29c
        if (epnum == 0U)
 8000fe8:	f1b9 0f00 	cmp.w	r9, #0
 8000fec:	f47f aec6 	bne.w	8000d7c <HAL_PCD_IRQHandler+0x744>
          if (ep->xfer_len == 0U)
 8000ff0:	f8d4 1294 	ldr.w	r1, [r4, #660]	; 0x294
 8000ff4:	b1d9      	cbz	r1, 800102e <HAL_PCD_IRQHandler+0x9f6>
            ep->xfer_buff += ep->xfer_count;
 8000ff6:	f8d4 128c 	ldr.w	r1, [r4, #652]	; 0x28c
 8000ffa:	440a      	add	r2, r1
 8000ffc:	f8c4 228c 	str.w	r2, [r4, #652]	; 0x28c
        HAL_PCD_DataOutStageCallback(hpcd, (uint8_t)epnum);
 8001000:	e6bc      	b.n	8000d7c <HAL_PCD_IRQHandler+0x744>
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 8001002:	6820      	ldr	r0, [r4, #0]
 8001004:	f504 618a 	add.w	r1, r4, #1104	; 0x450
 8001008:	f004 f972 	bl	80052f0 <USB_EPStopXfer>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800100c:	6863      	ldr	r3, [r4, #4]
 800100e:	f7ff bbe1 	b.w	80007d4 <HAL_PCD_IRQHandler+0x19c>
        (void)USB_EP0_OutStart(hpcd->Instance, 0U, (uint8_t *)hpcd->Setup);
 8001012:	f204 42c4 	addw	r2, r4, #1220	; 0x4c4
 8001016:	4649      	mov	r1, r9
 8001018:	f004 faba 	bl	8005590 <USB_EP0_OutStart>
 800101c:	e6ae      	b.n	8000d7c <HAL_PCD_IRQHandler+0x744>
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 800101e:	6820      	ldr	r0, [r4, #0]
 8001020:	f204 4174 	addw	r1, r4, #1140	; 0x474
 8001024:	f004 f964 	bl	80052f0 <USB_EPStopXfer>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8001028:	6863      	ldr	r3, [r4, #4]
 800102a:	f7ff bbda 	b.w	80007e2 <HAL_PCD_IRQHandler+0x1aa>
            (void)USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
 800102e:	f204 42c4 	addw	r2, r4, #1220	; 0x4c4
 8001032:	2101      	movs	r1, #1
 8001034:	f004 faac 	bl	8005590 <USB_EP0_OutStart>
 8001038:	e6a0      	b.n	8000d7c <HAL_PCD_IRQHandler+0x744>
 800103a:	bf00      	nop
 800103c:	4f54300a 	.word	0x4f54300a

08001040 <HAL_PCD_SetAddress>:
  __HAL_LOCK(hpcd);
 8001040:	f890 24bc 	ldrb.w	r2, [r0, #1212]	; 0x4bc
 8001044:	2a01      	cmp	r2, #1
 8001046:	d00d      	beq.n	8001064 <HAL_PCD_SetAddress+0x24>
{
 8001048:	b510      	push	{r4, lr}
 800104a:	4604      	mov	r4, r0
  __HAL_LOCK(hpcd);
 800104c:	2201      	movs	r2, #1
  (void)USB_SetDevAddress(hpcd->Instance, address);
 800104e:	6800      	ldr	r0, [r0, #0]
  __HAL_LOCK(hpcd);
 8001050:	f884 24bc 	strb.w	r2, [r4, #1212]	; 0x4bc
  hpcd->USB_Address = address;
 8001054:	f884 1038 	strb.w	r1, [r4, #56]	; 0x38
  (void)USB_SetDevAddress(hpcd->Instance, address);
 8001058:	f004 fa26 	bl	80054a8 <USB_SetDevAddress>
  __HAL_UNLOCK(hpcd);
 800105c:	2000      	movs	r0, #0
 800105e:	f884 04bc 	strb.w	r0, [r4, #1212]	; 0x4bc
}
 8001062:	bd10      	pop	{r4, pc}
  __HAL_LOCK(hpcd);
 8001064:	2002      	movs	r0, #2
}
 8001066:	4770      	bx	lr

08001068 <HAL_PCD_EP_Open>:
{
 8001068:	b510      	push	{r4, lr}
 800106a:	f001 0e0f 	and.w	lr, r1, #15
  if ((ep_addr & 0x80U) == 0x80U)
 800106e:	0609      	lsls	r1, r1, #24
{
 8001070:	4604      	mov	r4, r0
  if ((ep_addr & 0x80U) == 0x80U)
 8001072:	d427      	bmi.n	80010c4 <HAL_PCD_EP_Open+0x5c>
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 8001074:	f04f 0c24 	mov.w	ip, #36	; 0x24
 8001078:	fb0c 0c0e 	mla	ip, ip, lr, r0
 800107c:	f50c 711f 	add.w	r1, ip, #636	; 0x27c
    ep->is_in = 0U;
 8001080:	eb0e 0cce 	add.w	ip, lr, lr, lsl #3
 8001084:	eb00 0c8c 	add.w	ip, r0, ip, lsl #2
 8001088:	2000      	movs	r0, #0
 800108a:	f88c 027d 	strb.w	r0, [ip, #637]	; 0x27d
  ep->maxpacket = ep_mps;
 800108e:	60ca      	str	r2, [r1, #12]
  if (ep->is_in != 0U)
 8001090:	784a      	ldrb	r2, [r1, #1]
  ep->num = ep_addr & EP_ADDR_MSK;
 8001092:	f881 e000 	strb.w	lr, [r1]
  ep->type = ep_type;
 8001096:	710b      	strb	r3, [r1, #4]
  if (ep->is_in != 0U)
 8001098:	b10a      	cbz	r2, 800109e <HAL_PCD_EP_Open+0x36>
    ep->tx_fifo_num = ep->num;
 800109a:	f8a1 e008 	strh.w	lr, [r1, #8]
  if (ep_type == EP_TYPE_BULK)
 800109e:	2b02      	cmp	r3, #2
    ep->data_pid_start = 0U;
 80010a0:	bf04      	itt	eq
 80010a2:	2300      	moveq	r3, #0
 80010a4:	714b      	strbeq	r3, [r1, #5]
  __HAL_LOCK(hpcd);
 80010a6:	f894 34bc 	ldrb.w	r3, [r4, #1212]	; 0x4bc
 80010aa:	2b01      	cmp	r3, #1
 80010ac:	d018      	beq.n	80010e0 <HAL_PCD_EP_Open+0x78>
 80010ae:	2301      	movs	r3, #1
 80010b0:	f884 34bc 	strb.w	r3, [r4, #1212]	; 0x4bc
  (void)USB_ActivateEndpoint(hpcd->Instance, ep);
 80010b4:	6820      	ldr	r0, [r4, #0]
 80010b6:	f003 feb5 	bl	8004e24 <USB_ActivateEndpoint>
  __HAL_UNLOCK(hpcd);
 80010ba:	2300      	movs	r3, #0
 80010bc:	f884 34bc 	strb.w	r3, [r4, #1212]	; 0x4bc
  return ret;
 80010c0:	4618      	mov	r0, r3
}
 80010c2:	bd10      	pop	{r4, pc}
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 80010c4:	2024      	movs	r0, #36	; 0x24
 80010c6:	fb00 400e 	mla	r0, r0, lr, r4
 80010ca:	f100 013c 	add.w	r1, r0, #60	; 0x3c
    ep->is_in = 1U;
 80010ce:	eb0e 00ce 	add.w	r0, lr, lr, lsl #3
 80010d2:	eb04 0080 	add.w	r0, r4, r0, lsl #2
 80010d6:	f04f 0c01 	mov.w	ip, #1
 80010da:	f880 c03d 	strb.w	ip, [r0, #61]	; 0x3d
 80010de:	e7d6      	b.n	800108e <HAL_PCD_EP_Open+0x26>
  __HAL_LOCK(hpcd);
 80010e0:	2002      	movs	r0, #2
}
 80010e2:	bd10      	pop	{r4, pc}

080010e4 <HAL_PCD_EP_Close>:
  if ((ep_addr & 0x80U) == 0x80U)
 80010e4:	f001 030f 	and.w	r3, r1, #15
    ep->is_in = 1U;
 80010e8:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
  if ((ep_addr & 0x80U) == 0x80U)
 80010ec:	f011 0f80 	tst.w	r1, #128	; 0x80
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 80010f0:	f04f 0124 	mov.w	r1, #36	; 0x24
{
 80010f4:	b510      	push	{r4, lr}
    ep->is_in = 1U;
 80010f6:	eb00 0282 	add.w	r2, r0, r2, lsl #2
{
 80010fa:	4604      	mov	r4, r0
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 80010fc:	fb01 0103 	mla	r1, r1, r3, r0
  if ((ep_addr & 0x80U) == 0x80U)
 8001100:	d113      	bne.n	800112a <HAL_PCD_EP_Close+0x46>
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 8001102:	f501 711f 	add.w	r1, r1, #636	; 0x27c
    ep->is_in = 0U;
 8001106:	2000      	movs	r0, #0
 8001108:	f882 027d 	strb.w	r0, [r2, #637]	; 0x27d
  ep->num   = ep_addr & EP_ADDR_MSK;
 800110c:	700b      	strb	r3, [r1, #0]
  __HAL_LOCK(hpcd);
 800110e:	f894 34bc 	ldrb.w	r3, [r4, #1212]	; 0x4bc
 8001112:	2b01      	cmp	r3, #1
 8001114:	d012      	beq.n	800113c <HAL_PCD_EP_Close+0x58>
 8001116:	2301      	movs	r3, #1
  (void)USB_DeactivateEndpoint(hpcd->Instance, ep);
 8001118:	6820      	ldr	r0, [r4, #0]
  __HAL_LOCK(hpcd);
 800111a:	f884 34bc 	strb.w	r3, [r4, #1212]	; 0x4bc
  (void)USB_DeactivateEndpoint(hpcd->Instance, ep);
 800111e:	f003 fecd 	bl	8004ebc <USB_DeactivateEndpoint>
  __HAL_UNLOCK(hpcd);
 8001122:	2000      	movs	r0, #0
 8001124:	f884 04bc 	strb.w	r0, [r4, #1212]	; 0x4bc
}
 8001128:	bd10      	pop	{r4, pc}
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 800112a:	313c      	adds	r1, #60	; 0x3c
    ep->is_in = 1U;
 800112c:	2001      	movs	r0, #1
 800112e:	f882 003d 	strb.w	r0, [r2, #61]	; 0x3d
  ep->num   = ep_addr & EP_ADDR_MSK;
 8001132:	700b      	strb	r3, [r1, #0]
  __HAL_LOCK(hpcd);
 8001134:	f894 34bc 	ldrb.w	r3, [r4, #1212]	; 0x4bc
 8001138:	2b01      	cmp	r3, #1
 800113a:	d1ec      	bne.n	8001116 <HAL_PCD_EP_Close+0x32>
 800113c:	2002      	movs	r0, #2
}
 800113e:	bd10      	pop	{r4, pc}

08001140 <HAL_PCD_EP_Receive>:
{
 8001140:	b510      	push	{r4, lr}
 8001142:	f001 040f 	and.w	r4, r1, #15
  ep->xfer_buff = pBuf;
 8001146:	eb04 0cc4 	add.w	ip, r4, r4, lsl #3
 800114a:	eb00 0c8c 	add.w	ip, r0, ip, lsl #2
  ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 800114e:	2124      	movs	r1, #36	; 0x24
  ep->xfer_len = len;
 8001150:	f8cc 3294 	str.w	r3, [ip, #660]	; 0x294
  ep->xfer_count = 0U;
 8001154:	2300      	movs	r3, #0
  ep->xfer_buff = pBuf;
 8001156:	f8cc 228c 	str.w	r2, [ip, #652]	; 0x28c
  ep->num = ep_addr & EP_ADDR_MSK;
 800115a:	f88c 427c 	strb.w	r4, [ip, #636]	; 0x27c
  ep->xfer_count = 0U;
 800115e:	f8cc 329c 	str.w	r3, [ip, #668]	; 0x29c
  ep->is_in = 0U;
 8001162:	f88c 327d 	strb.w	r3, [ip, #637]	; 0x27d
  if (hpcd->Init.dma_enable == 1U)
 8001166:	6903      	ldr	r3, [r0, #16]
  ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 8001168:	fb01 0104 	mla	r1, r1, r4, r0
  if (hpcd->Init.dma_enable == 1U)
 800116c:	2b01      	cmp	r3, #1
    ep->dma_addr = (uint32_t)pBuf;
 800116e:	bf08      	it	eq
 8001170:	f8cc 2290 	streq.w	r2, [ip, #656]	; 0x290
    (void)USB_EP0StartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);
 8001174:	6800      	ldr	r0, [r0, #0]
  ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 8001176:	f501 711f 	add.w	r1, r1, #636	; 0x27c
    (void)USB_EP0StartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);
 800117a:	b2da      	uxtb	r2, r3
  if ((ep_addr & EP_ADDR_MSK) == 0U)
 800117c:	b91c      	cbnz	r4, 8001186 <HAL_PCD_EP_Receive+0x46>
    (void)USB_EP0StartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);
 800117e:	f004 f80b 	bl	8005198 <USB_EP0StartXfer>
}
 8001182:	2000      	movs	r0, #0
 8001184:	bd10      	pop	{r4, pc}
    (void)USB_EPStartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);
 8001186:	f003 fefb 	bl	8004f80 <USB_EPStartXfer>
}
 800118a:	2000      	movs	r0, #0
 800118c:	bd10      	pop	{r4, pc}
 800118e:	bf00      	nop

08001190 <HAL_PCD_EP_Transmit>:
{
 8001190:	b510      	push	{r4, lr}
 8001192:	f001 040f 	and.w	r4, r1, #15
  ep->xfer_buff = pBuf;
 8001196:	eb04 0cc4 	add.w	ip, r4, r4, lsl #3
 800119a:	eb00 0c8c 	add.w	ip, r0, ip, lsl #2
  ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 800119e:	2124      	movs	r1, #36	; 0x24
  ep->xfer_len = len;
 80011a0:	f8cc 3054 	str.w	r3, [ip, #84]	; 0x54
  ep->xfer_count = 0U;
 80011a4:	2300      	movs	r3, #0
 80011a6:	f8cc 305c 	str.w	r3, [ip, #92]	; 0x5c
  ep->is_in = 1U;
 80011aa:	2301      	movs	r3, #1
  ep->xfer_buff = pBuf;
 80011ac:	f8cc 204c 	str.w	r2, [ip, #76]	; 0x4c
  ep->num = ep_addr & EP_ADDR_MSK;
 80011b0:	f88c 403c 	strb.w	r4, [ip, #60]	; 0x3c
  ep->is_in = 1U;
 80011b4:	f88c 303d 	strb.w	r3, [ip, #61]	; 0x3d
  if (hpcd->Init.dma_enable == 1U)
 80011b8:	6903      	ldr	r3, [r0, #16]
  ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 80011ba:	fb01 0104 	mla	r1, r1, r4, r0
  if (hpcd->Init.dma_enable == 1U)
 80011be:	2b01      	cmp	r3, #1
    ep->dma_addr = (uint32_t)pBuf;
 80011c0:	bf08      	it	eq
 80011c2:	f8cc 2050 	streq.w	r2, [ip, #80]	; 0x50
    (void)USB_EP0StartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);
 80011c6:	6800      	ldr	r0, [r0, #0]
  ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 80011c8:	313c      	adds	r1, #60	; 0x3c
    (void)USB_EP0StartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);
 80011ca:	b2da      	uxtb	r2, r3
  if ((ep_addr & EP_ADDR_MSK) == 0U)
 80011cc:	b91c      	cbnz	r4, 80011d6 <HAL_PCD_EP_Transmit+0x46>
    (void)USB_EP0StartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);
 80011ce:	f003 ffe3 	bl	8005198 <USB_EP0StartXfer>
}
 80011d2:	2000      	movs	r0, #0
 80011d4:	bd10      	pop	{r4, pc}
    (void)USB_EPStartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);
 80011d6:	f003 fed3 	bl	8004f80 <USB_EPStartXfer>
}
 80011da:	2000      	movs	r0, #0
 80011dc:	bd10      	pop	{r4, pc}
 80011de:	bf00      	nop

080011e0 <HAL_PCD_EP_SetStall>:
{
 80011e0:	b538      	push	{r3, r4, r5, lr}
  if (((uint32_t)ep_addr & EP_ADDR_MSK) > hpcd->Init.dev_endpoints)
 80011e2:	6843      	ldr	r3, [r0, #4]
 80011e4:	f001 050f 	and.w	r5, r1, #15
 80011e8:	429d      	cmp	r5, r3
 80011ea:	d833      	bhi.n	8001254 <HAL_PCD_EP_SetStall+0x74>
  if ((0x80U & ep_addr) == 0x80U)
 80011ec:	060b      	lsls	r3, r1, #24
 80011ee:	4604      	mov	r4, r0
 80011f0:	d41c      	bmi.n	800122c <HAL_PCD_EP_SetStall+0x4c>
    ep->is_in = 0U;
 80011f2:	eb01 03c1 	add.w	r3, r1, r1, lsl #3
    ep = &hpcd->OUT_ep[ep_addr];
 80011f6:	2224      	movs	r2, #36	; 0x24
 80011f8:	fb02 0101 	mla	r1, r2, r1, r0
    ep->is_in = 0U;
 80011fc:	eb00 0383 	add.w	r3, r0, r3, lsl #2
    ep = &hpcd->OUT_ep[ep_addr];
 8001200:	f501 711f 	add.w	r1, r1, #636	; 0x27c
    ep->is_in = 0U;
 8001204:	2200      	movs	r2, #0
 8001206:	f883 227d 	strb.w	r2, [r3, #637]	; 0x27d
  ep->is_stall = 1U;
 800120a:	2301      	movs	r3, #1
 800120c:	708b      	strb	r3, [r1, #2]
  ep->num = ep_addr & EP_ADDR_MSK;
 800120e:	700d      	strb	r5, [r1, #0]
  __HAL_LOCK(hpcd);
 8001210:	f894 24bc 	ldrb.w	r2, [r4, #1212]	; 0x4bc
 8001214:	429a      	cmp	r2, r3
 8001216:	d01b      	beq.n	8001250 <HAL_PCD_EP_SetStall+0x70>
  (void)USB_EPSetStall(hpcd->Instance, ep);
 8001218:	6820      	ldr	r0, [r4, #0]
  __HAL_LOCK(hpcd);
 800121a:	f884 34bc 	strb.w	r3, [r4, #1212]	; 0x4bc
  (void)USB_EPSetStall(hpcd->Instance, ep);
 800121e:	f004 f8e9 	bl	80053f4 <USB_EPSetStall>
  if ((ep_addr & EP_ADDR_MSK) == 0U)
 8001222:	b1cd      	cbz	r5, 8001258 <HAL_PCD_EP_SetStall+0x78>
  __HAL_UNLOCK(hpcd);
 8001224:	2000      	movs	r0, #0
 8001226:	f884 04bc 	strb.w	r0, [r4, #1212]	; 0x4bc
}
 800122a:	bd38      	pop	{r3, r4, r5, pc}
    ep->is_in = 1U;
 800122c:	eb05 03c5 	add.w	r3, r5, r5, lsl #3
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8001230:	2124      	movs	r1, #36	; 0x24
 8001232:	fb01 0105 	mla	r1, r1, r5, r0
    ep->is_in = 1U;
 8001236:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 800123a:	2201      	movs	r2, #1
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 800123c:	313c      	adds	r1, #60	; 0x3c
    ep->is_in = 1U;
 800123e:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
  ep->is_stall = 1U;
 8001242:	2301      	movs	r3, #1
 8001244:	708b      	strb	r3, [r1, #2]
  ep->num = ep_addr & EP_ADDR_MSK;
 8001246:	700d      	strb	r5, [r1, #0]
  __HAL_LOCK(hpcd);
 8001248:	f894 24bc 	ldrb.w	r2, [r4, #1212]	; 0x4bc
 800124c:	429a      	cmp	r2, r3
 800124e:	d1e3      	bne.n	8001218 <HAL_PCD_EP_SetStall+0x38>
 8001250:	2002      	movs	r0, #2
}
 8001252:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_ERROR;
 8001254:	2001      	movs	r0, #1
}
 8001256:	bd38      	pop	{r3, r4, r5, pc}
    (void)USB_EP0_OutStart(hpcd->Instance, (uint8_t)hpcd->Init.dma_enable, (uint8_t *)hpcd->Setup);
 8001258:	7c21      	ldrb	r1, [r4, #16]
 800125a:	6820      	ldr	r0, [r4, #0]
 800125c:	f204 42c4 	addw	r2, r4, #1220	; 0x4c4
 8001260:	f004 f996 	bl	8005590 <USB_EP0_OutStart>
 8001264:	e7de      	b.n	8001224 <HAL_PCD_EP_SetStall+0x44>
 8001266:	bf00      	nop

08001268 <HAL_PCD_EP_ClrStall>:
  if (((uint32_t)ep_addr & 0x0FU) > hpcd->Init.dev_endpoints)
 8001268:	6842      	ldr	r2, [r0, #4]
{
 800126a:	b538      	push	{r3, r4, r5, lr}
 800126c:	f001 030f 	and.w	r3, r1, #15
  if (((uint32_t)ep_addr & 0x0FU) > hpcd->Init.dev_endpoints)
 8001270:	4293      	cmp	r3, r2
 8001272:	d82e      	bhi.n	80012d2 <HAL_PCD_EP_ClrStall+0x6a>
    ep->is_in = 1U;
 8001274:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
  if ((0x80U & ep_addr) == 0x80U)
 8001278:	f011 0f80 	tst.w	r1, #128	; 0x80
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 800127c:	f04f 0124 	mov.w	r1, #36	; 0x24
 8001280:	4604      	mov	r4, r0
    ep->is_in = 1U;
 8001282:	eb00 0282 	add.w	r2, r0, r2, lsl #2
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8001286:	fb01 0103 	mla	r1, r1, r3, r0
  if ((0x80U & ep_addr) == 0x80U)
 800128a:	d115      	bne.n	80012b8 <HAL_PCD_EP_ClrStall+0x50>
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 800128c:	f501 711f 	add.w	r1, r1, #636	; 0x27c
    ep->is_in = 0U;
 8001290:	2000      	movs	r0, #0
  ep->is_stall = 0U;
 8001292:	2500      	movs	r5, #0
    ep->is_in = 0U;
 8001294:	f882 027d 	strb.w	r0, [r2, #637]	; 0x27d
  ep->is_stall = 0U;
 8001298:	708d      	strb	r5, [r1, #2]
  ep->num = ep_addr & EP_ADDR_MSK;
 800129a:	700b      	strb	r3, [r1, #0]
  __HAL_LOCK(hpcd);
 800129c:	f894 34bc 	ldrb.w	r3, [r4, #1212]	; 0x4bc
 80012a0:	2b01      	cmp	r3, #1
 80012a2:	d014      	beq.n	80012ce <HAL_PCD_EP_ClrStall+0x66>
 80012a4:	2301      	movs	r3, #1
  (void)USB_EPClearStall(hpcd->Instance, ep);
 80012a6:	6820      	ldr	r0, [r4, #0]
  __HAL_LOCK(hpcd);
 80012a8:	f884 34bc 	strb.w	r3, [r4, #1212]	; 0x4bc
  (void)USB_EPClearStall(hpcd->Instance, ep);
 80012ac:	f004 f8d0 	bl	8005450 <USB_EPClearStall>
  __HAL_UNLOCK(hpcd);
 80012b0:	f884 54bc 	strb.w	r5, [r4, #1212]	; 0x4bc
  return HAL_OK;
 80012b4:	4628      	mov	r0, r5
}
 80012b6:	bd38      	pop	{r3, r4, r5, pc}
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 80012b8:	313c      	adds	r1, #60	; 0x3c
    ep->is_in = 1U;
 80012ba:	2001      	movs	r0, #1
  ep->is_stall = 0U;
 80012bc:	2500      	movs	r5, #0
    ep->is_in = 1U;
 80012be:	f882 003d 	strb.w	r0, [r2, #61]	; 0x3d
  ep->is_stall = 0U;
 80012c2:	708d      	strb	r5, [r1, #2]
  ep->num = ep_addr & EP_ADDR_MSK;
 80012c4:	700b      	strb	r3, [r1, #0]
  __HAL_LOCK(hpcd);
 80012c6:	f894 34bc 	ldrb.w	r3, [r4, #1212]	; 0x4bc
 80012ca:	2b01      	cmp	r3, #1
 80012cc:	d1ea      	bne.n	80012a4 <HAL_PCD_EP_ClrStall+0x3c>
 80012ce:	2002      	movs	r0, #2
}
 80012d0:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_ERROR;
 80012d2:	2001      	movs	r0, #1
}
 80012d4:	bd38      	pop	{r3, r4, r5, pc}
 80012d6:	bf00      	nop

080012d8 <HAL_PCD_EP_Flush>:
  __HAL_LOCK(hpcd);
 80012d8:	f890 34bc 	ldrb.w	r3, [r0, #1212]	; 0x4bc
 80012dc:	2b01      	cmp	r3, #1
 80012de:	d015      	beq.n	800130c <HAL_PCD_EP_Flush+0x34>
 80012e0:	2301      	movs	r3, #1
{
 80012e2:	b510      	push	{r4, lr}
  __HAL_LOCK(hpcd);
 80012e4:	f880 34bc 	strb.w	r3, [r0, #1212]	; 0x4bc
  if ((ep_addr & 0x80U) == 0x80U)
 80012e8:	060b      	lsls	r3, r1, #24
 80012ea:	4604      	mov	r4, r0
    (void)USB_FlushTxFifo(hpcd->Instance, (uint32_t)ep_addr & EP_ADDR_MSK);
 80012ec:	6800      	ldr	r0, [r0, #0]
  if ((ep_addr & 0x80U) == 0x80U)
 80012ee:	d405      	bmi.n	80012fc <HAL_PCD_EP_Flush+0x24>
    (void)USB_FlushRxFifo(hpcd->Instance);
 80012f0:	f003 fd64 	bl	8004dbc <USB_FlushRxFifo>
  __HAL_UNLOCK(hpcd);
 80012f4:	2000      	movs	r0, #0
 80012f6:	f884 04bc 	strb.w	r0, [r4, #1212]	; 0x4bc
}
 80012fa:	bd10      	pop	{r4, pc}
    (void)USB_FlushTxFifo(hpcd->Instance, (uint32_t)ep_addr & EP_ADDR_MSK);
 80012fc:	f001 010f 	and.w	r1, r1, #15
 8001300:	f003 fd32 	bl	8004d68 <USB_FlushTxFifo>
  __HAL_UNLOCK(hpcd);
 8001304:	2000      	movs	r0, #0
 8001306:	f884 04bc 	strb.w	r0, [r4, #1212]	; 0x4bc
}
 800130a:	bd10      	pop	{r4, pc}
  __HAL_LOCK(hpcd);
 800130c:	2002      	movs	r0, #2
}
 800130e:	4770      	bx	lr

08001310 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack    		 /* set stack pointer */
 8001310:	f8df d034 	ldr.w	sp, [pc, #52]	; 8001348 <LoopFillZerobss+0x14>

/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
 8001314:	2100      	movs	r1, #0
  b  LoopCopyDataInit
 8001316:	e003      	b.n	8001320 <LoopCopyDataInit>

08001318 <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
 8001318:	4b0c      	ldr	r3, [pc, #48]	; (800134c <LoopFillZerobss+0x18>)
  ldr  r3, [r3, r1]
 800131a:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
 800131c:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
 800131e:	3104      	adds	r1, #4

08001320 <LoopCopyDataInit>:
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 8001320:	480b      	ldr	r0, [pc, #44]	; (8001350 <LoopFillZerobss+0x1c>)
  ldr  r3, =_edata
 8001322:	4b0c      	ldr	r3, [pc, #48]	; (8001354 <LoopFillZerobss+0x20>)
  adds  r2, r0, r1
 8001324:	1842      	adds	r2, r0, r1
  cmp  r2, r3
 8001326:	429a      	cmp	r2, r3
  bcc  CopyDataInit
 8001328:	d3f6      	bcc.n	8001318 <CopyDataInit>
  ldr  r2, =_sbss
 800132a:	4a0b      	ldr	r2, [pc, #44]	; (8001358 <LoopFillZerobss+0x24>)
  b  LoopFillZerobss
 800132c:	e002      	b.n	8001334 <LoopFillZerobss>

0800132e <FillZerobss>:
/* Zero fill the bss segment. */  
FillZerobss:
  movs  r3, #0
 800132e:	2300      	movs	r3, #0
  str  r3, [r2], #4
 8001330:	f842 3b04 	str.w	r3, [r2], #4

08001334 <LoopFillZerobss>:
    
LoopFillZerobss:
  ldr  r3, = _ebss
 8001334:	4b09      	ldr	r3, [pc, #36]	; (800135c <LoopFillZerobss+0x28>)
  cmp  r2, r3
 8001336:	429a      	cmp	r2, r3
  bcc  FillZerobss
 8001338:	d3f9      	bcc.n	800132e <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit   
 800133a:	f001 f933 	bl	80025a4 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 800133e:	f007 fe21 	bl	8008f84 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 8001342:	f000 f89f 	bl	8001484 <main>
  bx  lr    
 8001346:	4770      	bx	lr
  ldr   sp, =_estack    		 /* set stack pointer */
 8001348:	20018000 	.word	0x20018000
  ldr  r3, =_sidata
 800134c:	08009d58 	.word	0x08009d58
  ldr  r0, =_sdata
 8001350:	20000000 	.word	0x20000000
  ldr  r3, =_edata
 8001354:	2000052c 	.word	0x2000052c
  ldr  r2, =_sbss
 8001358:	20000530 	.word	0x20000530
  ldr  r3, = _ebss
 800135c:	200028f0 	.word	0x200028f0

08001360 <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 8001360:	e7fe      	b.n	8001360 <ADC_IRQHandler>
	...

08001364 <CCA02M2_AUDIO_IN_HalfTransfer_CallBack>:
 8001364:	4a07      	ldr	r2, [pc, #28]	; (8001384 <CCA02M2_AUDIO_IN_HalfTransfer_CallBack+0x20>)
 8001366:	b508      	push	{r3, lr}
 8001368:	2000      	movs	r0, #0
 800136a:	f102 01c0 	add.w	r1, r2, #192	; 0xc0
 800136e:	f000 fe3d 	bl	8001fec <CCA02M2_AUDIO_IN_PDMToPCM>
 8001372:	b100      	cbz	r0, 8001376 <CCA02M2_AUDIO_IN_HalfTransfer_CallBack+0x12>
 8001374:	e7fe      	b.n	8001374 <CCA02M2_AUDIO_IN_HalfTransfer_CallBack+0x10>
 8001376:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 800137a:	4802      	ldr	r0, [pc, #8]	; (8001384 <CCA02M2_AUDIO_IN_HalfTransfer_CallBack+0x20>)
 800137c:	2160      	movs	r1, #96	; 0x60
 800137e:	f000 b917 	b.w	80015b0 <Send_Audio_to_USB>
 8001382:	bf00      	nop
 8001384:	2000054c 	.word	0x2000054c

08001388 <CCA02M2_AUDIO_IN_TransferComplete_CallBack>:
  * @retval None
  */

void AudioProcess(void)
{
  if (CCA02M2_AUDIO_IN_PDMToPCM(CCA02M2_AUDIO_INSTANCE, (uint16_t *)PDM_Buffer, PCM_Buffer) != BSP_ERROR_NONE)
 8001388:	4a07      	ldr	r2, [pc, #28]	; (80013a8 <CCA02M2_AUDIO_IN_TransferComplete_CallBack+0x20>)
{
 800138a:	b508      	push	{r3, lr}
  if (CCA02M2_AUDIO_IN_PDMToPCM(CCA02M2_AUDIO_INSTANCE, (uint16_t *)PDM_Buffer, PCM_Buffer) != BSP_ERROR_NONE)
 800138c:	2000      	movs	r0, #0
 800138e:	f102 01c0 	add.w	r1, r2, #192	; 0xc0
 8001392:	f000 fe2b 	bl	8001fec <CCA02M2_AUDIO_IN_PDMToPCM>
 8001396:	b100      	cbz	r0, 800139a <CCA02M2_AUDIO_IN_TransferComplete_CallBack+0x12>



void Error_Handler(void)
{
  while (1);
 8001398:	e7fe      	b.n	8001398 <CCA02M2_AUDIO_IN_TransferComplete_CallBack+0x10>
}
 800139a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  Send_Audio_to_USB((int16_t *)PCM_Buffer, (AUDIO_IN_SAMPLING_FREQUENCY / 1000)*AUDIO_IN_CHANNELS * N_MS);
 800139e:	4802      	ldr	r0, [pc, #8]	; (80013a8 <CCA02M2_AUDIO_IN_TransferComplete_CallBack+0x20>)
 80013a0:	2160      	movs	r1, #96	; 0x60
 80013a2:	f000 b905 	b.w	80015b0 <Send_Audio_to_USB>
 80013a6:	bf00      	nop
 80013a8:	2000054c 	.word	0x2000054c

080013ac <Init_Acquisition_Peripherals>:
  MicParams.BitsPerSample = 16;
 80013ac:	4b0b      	ldr	r3, [pc, #44]	; (80013dc <Init_Acquisition_Peripherals+0x30>)
 80013ae:	2210      	movs	r2, #16
{
 80013b0:	b510      	push	{r4, lr}
  MicParams.Device = AUDIO_IN_DIGITAL_MIC;
 80013b2:	24f0      	movs	r4, #240	; 0xf0
  MicParams.BitsPerSample = 16;
 80013b4:	f8c3 26c8 	str.w	r2, [r3, #1736]	; 0x6c8
  MicParams.ChannelsNbr = ChnlNbrIn;
 80013b8:	f8c3 16cc 	str.w	r1, [r3, #1740]	; 0x6cc
  MicParams.Volume = AUDIO_VOLUME_INPUT;
 80013bc:	2240      	movs	r2, #64	; 0x40
  MicParams.SampleRate = AudioFreq;
 80013be:	f8c3 06c4 	str.w	r0, [r3, #1732]	; 0x6c4
  if (CCA02M2_AUDIO_IN_Init(CCA02M2_AUDIO_INSTANCE, &MicParams) != BSP_ERROR_NONE)
 80013c2:	f503 61d8 	add.w	r1, r3, #1728	; 0x6c0
 80013c6:	2000      	movs	r0, #0
  MicParams.Device = AUDIO_IN_DIGITAL_MIC;
 80013c8:	f8c3 46c0 	str.w	r4, [r3, #1728]	; 0x6c0
  MicParams.Volume = AUDIO_VOLUME_INPUT;
 80013cc:	f8c3 26d0 	str.w	r2, [r3, #1744]	; 0x6d0
  if (CCA02M2_AUDIO_IN_Init(CCA02M2_AUDIO_INSTANCE, &MicParams) != BSP_ERROR_NONE)
 80013d0:	f000 fbf6 	bl	8001bc0 <CCA02M2_AUDIO_IN_Init>
 80013d4:	b900      	cbnz	r0, 80013d8 <Init_Acquisition_Peripherals+0x2c>
}
 80013d6:	bd10      	pop	{r4, pc}
  while (1);
 80013d8:	e7fe      	b.n	80013d8 <Init_Acquisition_Peripherals+0x2c>
 80013da:	bf00      	nop
 80013dc:	2000054c 	.word	0x2000054c

080013e0 <Start_Acquisition>:
{
 80013e0:	b508      	push	{r3, lr}
  if (CCA02M2_AUDIO_IN_Record(CCA02M2_AUDIO_INSTANCE, (uint8_t *) PDM_Buffer, AUDIO_IN_BUFFER_SIZE) != BSP_ERROR_NONE)
 80013e2:	4904      	ldr	r1, [pc, #16]	; (80013f4 <Start_Acquisition+0x14>)
 80013e4:	2260      	movs	r2, #96	; 0x60
 80013e6:	2000      	movs	r0, #0
 80013e8:	f000 fe7c 	bl	80020e4 <CCA02M2_AUDIO_IN_Record>
 80013ec:	b900      	cbnz	r0, 80013f0 <Start_Acquisition+0x10>
}
 80013ee:	bd08      	pop	{r3, pc}
  while (1);
 80013f0:	e7fe      	b.n	80013f0 <Start_Acquisition+0x10>
 80013f2:	bf00      	nop
 80013f4:	2000060c 	.word	0x2000060c

080013f8 <SystemClock_Config>:
  * @brief  System Clock Configuration
  * @param  None
  * @retval None
  */
void SystemClock_Config(void)
{
 80013f8:	b530      	push	{r4, r5, lr}
 80013fa:	b095      	sub	sp, #84	; 0x54
  RCC_ClkInitTypeDef RCC_ClkInitStruct;
  RCC_OscInitTypeDef RCC_OscInitStruct;

  /* Enable Power Control clock */
  __PWR_CLK_ENABLE();
 80013fc:	2400      	movs	r4, #0
 80013fe:	4b1f      	ldr	r3, [pc, #124]	; (800147c <SystemClock_Config+0x84>)
 8001400:	9400      	str	r4, [sp, #0]
 8001402:	6c19      	ldr	r1, [r3, #64]	; 0x40

  /* The voltage scaling allows optimizing the power consumption when the device is
  clocked below the maximum system frequency, to update the voltage scaling value
  regarding system frequency refer to product datasheet.  */
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE2);
 8001404:	4a1e      	ldr	r2, [pc, #120]	; (8001480 <SystemClock_Config+0x88>)
  __PWR_CLK_ENABLE();
 8001406:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
 800140a:	6419      	str	r1, [r3, #64]	; 0x40
 800140c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800140e:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8001412:	9300      	str	r3, [sp, #0]
 8001414:	9b00      	ldr	r3, [sp, #0]
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE2);
 8001416:	9401      	str	r4, [sp, #4]
 8001418:	6813      	ldr	r3, [r2, #0]
 800141a:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
 800141e:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8001422:	6013      	str	r3, [r2, #0]
 8001424:	6813      	ldr	r3, [r2, #0]
 8001426:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
 800142a:	9301      	str	r3, [sp, #4]

  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 800142c:	2502      	movs	r5, #2
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 800142e:	2001      	movs	r0, #1
 8001430:	f44f 3180 	mov.w	r1, #65536	; 0x10000
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 8001434:	f44f 0280 	mov.w	r2, #4194304	; 0x400000
  RCC_OscInitStruct.PLL.PLLM = 8;
 8001438:	2308      	movs	r3, #8
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 800143a:	e9cd 0108 	strd	r0, r1, [sp, #32]
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 800143e:	e9cd 520e 	strd	r5, r2, [sp, #56]	; 0x38
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE2);
 8001442:	9801      	ldr	r0, [sp, #4]
  RCC_OscInitStruct.PLL.PLLM = 8;
 8001444:	9310      	str	r3, [sp, #64]	; 0x40
  RCC_OscInitStruct.PLL.PLLN = 336;
 8001446:	f44f 71a8 	mov.w	r1, #336	; 0x150
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV4;
 800144a:	2204      	movs	r2, #4
  RCC_OscInitStruct.PLL.PLLQ = 7;
 800144c:	2307      	movs	r3, #7
  (void)HAL_RCC_OscConfig(&RCC_OscInitStruct);
 800144e:	a808      	add	r0, sp, #32
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV4;
 8001450:	e9cd 1211 	strd	r1, r2, [sp, #68]	; 0x44
  RCC_OscInitStruct.PLL.PLLQ = 7;
 8001454:	9313      	str	r3, [sp, #76]	; 0x4c
  (void)HAL_RCC_OscConfig(&RCC_OscInitStruct);
 8001456:	f001 ffcb 	bl	80033f0 <HAL_RCC_OscConfig>

  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
 800145a:	220d      	movs	r2, #13
 800145c:	2302      	movs	r3, #2
 800145e:	e9cd 2302 	strd	r2, r3, [sp, #8]
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
  (void)HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2);
 8001462:	4629      	mov	r1, r5
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
 8001464:	2200      	movs	r2, #0
 8001466:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  (void)HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2);
 800146a:	a802      	add	r0, sp, #8
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
 800146c:	e9cd 2304 	strd	r2, r3, [sp, #16]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 8001470:	9406      	str	r4, [sp, #24]
  (void)HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2);
 8001472:	f002 f9d9 	bl	8003828 <HAL_RCC_ClockConfig>
}
 8001476:	b015      	add	sp, #84	; 0x54
 8001478:	bd30      	pop	{r4, r5, pc}
 800147a:	bf00      	nop
 800147c:	40023800 	.word	0x40023800
 8001480:	40007000 	.word	0x40007000

08001484 <main>:
  * @brief  Main program
  * @param  None
  * @retval None
  */
int main(void)
{
 8001484:	b508      	push	{r3, lr}
  /* STM32F4xx HAL library initialization:
  - Configure the Flash prefetch, instruction and Data caches
  - Configure the Systick to generate an interrupt each 1 msec
  - Global MSP (MCU Support Package) initialization
  */
  HAL_Init();
 8001486:	f001 f8d9 	bl	800263c <HAL_Init>

  /* Configure the system clock */
  SystemClock_Config();
 800148a:	f7ff ffb5 	bl	80013f8 <SystemClock_Config>
  /* Initialize USB descriptor basing on channels number and sampling frequency */
  USBD_AUDIO_Init_Microphone_Descriptor(&hUSBDDevice, AUDIO_IN_SAMPLING_FREQUENCY, AUDIO_IN_CHANNELS);
 800148e:	480f      	ldr	r0, [pc, #60]	; (80014cc <main+0x48>)
 8001490:	2202      	movs	r2, #2
 8001492:	f64b 3180 	movw	r1, #48000	; 0xbb80
 8001496:	f004 faad 	bl	80059f4 <USBD_AUDIO_Init_Microphone_Descriptor>
  /* Init Device Library */
  USBD_Init(&hUSBDDevice, &AUDIO_Desc, 0);
 800149a:	2200      	movs	r2, #0
 800149c:	490c      	ldr	r1, [pc, #48]	; (80014d0 <main+0x4c>)
 800149e:	480b      	ldr	r0, [pc, #44]	; (80014cc <main+0x48>)
 80014a0:	f005 f808 	bl	80064b4 <USBD_Init>
  /* Add Supported Class */
  USBD_RegisterClass(&hUSBDDevice, &USBD_AUDIO);
 80014a4:	490b      	ldr	r1, [pc, #44]	; (80014d4 <main+0x50>)
 80014a6:	4809      	ldr	r0, [pc, #36]	; (80014cc <main+0x48>)
 80014a8:	f005 f818 	bl	80064dc <USBD_RegisterClass>
  /* Add Interface callbacks for AUDIO Class */
  USBD_AUDIO_RegisterInterface(&hUSBDDevice, &USBD_AUDIO_fops);
 80014ac:	490a      	ldr	r1, [pc, #40]	; (80014d8 <main+0x54>)
 80014ae:	4807      	ldr	r0, [pc, #28]	; (80014cc <main+0x48>)
 80014b0:	f004 fa9a 	bl	80059e8 <USBD_AUDIO_RegisterInterface>
  /* Start Device Process */
  USBD_Start(&hUSBDDevice);
 80014b4:	4805      	ldr	r0, [pc, #20]	; (80014cc <main+0x48>)
 80014b6:	f005 f82d 	bl	8006514 <USBD_Start>

  /* Start audio acquisition and streaming */
#ifdef DISABLE_USB_DRIVEN_ACQUISITION
  Init_Acquisition_Peripherals(AUDIO_IN_SAMPLING_FREQUENCY, AUDIO_IN_CHANNELS, 0);
 80014ba:	2200      	movs	r2, #0
 80014bc:	2102      	movs	r1, #2
 80014be:	f64b 3080 	movw	r0, #48000	; 0xbb80
 80014c2:	f7ff ff73 	bl	80013ac <Init_Acquisition_Peripherals>
  Start_Acquisition();
 80014c6:	f7ff ff8b 	bl	80013e0 <Start_Acquisition>
#endif

  while (1)
 80014ca:	e7fe      	b.n	80014ca <main+0x46>
 80014cc:	20000c20 	.word	0x20000c20
 80014d0:	2000003c 	.word	0x2000003c
 80014d4:	20000090 	.word	0x20000090
 80014d8:	20000000 	.word	0x20000000

080014dc <NMI_Handler>:
  * @param  None
  * @retval None
  */
void NMI_Handler(void)
{
}
 80014dc:	4770      	bx	lr
 80014de:	bf00      	nop

080014e0 <HardFault_Handler>:
  * @retval None
  */
void HardFault_Handler(void)
{
  /* Go to infinite loop when Hard Fault exception occurs */
  while (1)
 80014e0:	e7fe      	b.n	80014e0 <HardFault_Handler>
 80014e2:	bf00      	nop

080014e4 <SVC_Handler>:
 80014e4:	4770      	bx	lr
 80014e6:	bf00      	nop

080014e8 <DebugMon_Handler>:
 80014e8:	4770      	bx	lr
 80014ea:	bf00      	nop

080014ec <PendSV_Handler>:
 80014ec:	4770      	bx	lr
 80014ee:	bf00      	nop

080014f0 <SysTick_Handler>:
  * @param  None
  * @retval None
  */
void SysTick_Handler(void)
{
  HAL_IncTick();
 80014f0:	f001 b8be 	b.w	8002670 <HAL_IncTick>

080014f4 <OTG_FS_IRQHandler>:
  * @param  None
  * @retval None
  */
void USB_IRQHandler(void)
{
  HAL_PCD_IRQHandler(&hpcd);
 80014f4:	4801      	ldr	r0, [pc, #4]	; (80014fc <OTG_FS_IRQHandler+0x8>)
 80014f6:	f7ff b89f 	b.w	8000638 <HAL_PCD_IRQHandler>
 80014fa:	bf00      	nop
 80014fc:	20000f04 	.word	0x20000f04

08001500 <DMA1_Stream3_IRQHandler>:
  * @param  None
  * @retval None
  */
void AUDIO_IN_I2S_IRQHandler(void)
{
  HAL_DMA_IRQHandler(hAudioInI2s.hdmarx);
 8001500:	4b01      	ldr	r3, [pc, #4]	; (8001508 <DMA1_Stream3_IRQHandler+0x8>)
 8001502:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
 8001504:	f001 ba6a 	b.w	80029dc <HAL_DMA_IRQHandler>
 8001508:	200019c4 	.word	0x200019c4

0800150c <_sbrk>:
{
  extern char end asm("end");
  static char *heap_end;
  char *prev_heap_end;

  if (heap_end == 0)
 800150c:	4a0b      	ldr	r2, [pc, #44]	; (800153c <_sbrk+0x30>)
{
 800150e:	b508      	push	{r3, lr}
 8001510:	4603      	mov	r3, r0
  if (heap_end == 0)
 8001512:	6810      	ldr	r0, [r2, #0]
 8001514:	b128      	cbz	r0, 8001522 <_sbrk+0x16>
  {
    heap_end = &end;
  }

  prev_heap_end = heap_end;
  if (heap_end + incr > stack_ptr)
 8001516:	4403      	add	r3, r0
 8001518:	4669      	mov	r1, sp
 800151a:	428b      	cmp	r3, r1
 800151c:	d807      	bhi.n	800152e <_sbrk+0x22>
//    abort();
    errno = ENOMEM;
    return (caddr_t) -1;
  }

  heap_end += incr;
 800151e:	6013      	str	r3, [r2, #0]

  return (caddr_t) prev_heap_end;
}
 8001520:	bd08      	pop	{r3, pc}
    heap_end = &end;
 8001522:	4807      	ldr	r0, [pc, #28]	; (8001540 <_sbrk+0x34>)
 8001524:	6010      	str	r0, [r2, #0]
  if (heap_end + incr > stack_ptr)
 8001526:	4403      	add	r3, r0
 8001528:	4669      	mov	r1, sp
 800152a:	428b      	cmp	r3, r1
 800152c:	d9f7      	bls.n	800151e <_sbrk+0x12>
    errno = ENOMEM;
 800152e:	f007 fd23 	bl	8008f78 <__errno>
 8001532:	230c      	movs	r3, #12
 8001534:	6003      	str	r3, [r0, #0]
    return (caddr_t) -1;
 8001536:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
 800153a:	bd08      	pop	{r3, pc}
 800153c:	20000efc 	.word	0x20000efc
 8001540:	200028f0 	.word	0x200028f0

08001544 <Audio_Init>:
#ifndef DISABLE_USB_DRIVEN_ACQUISITION
  return CCA02M2_AUDIO_IN_Init(CCA02M2_AUDIO_INSTANCE, &MicParams);
#else
  return BSP_ERROR_NONE;
#endif  /* DISABLE_USB_DRIVEN_ACQUISITION */
}
 8001544:	2000      	movs	r0, #0
 8001546:	4770      	bx	lr

08001548 <Audio_DeInit>:
  * @retval BSP_ERROR_NONE in case of success, AUDIO_ERROR otherwise
  */
static int8_t Audio_DeInit(uint32_t options)
{
  return BSP_ERROR_NONE;
}
 8001548:	2000      	movs	r0, #0
 800154a:	4770      	bx	lr

0800154c <Audio_Record>:
#ifndef DISABLE_USB_DRIVEN_ACQUISITION
  return CCA02M2_AUDIO_IN_Record(CCA02M2_AUDIO_INSTANCE, (uint8_t *) PDM_Buffer, 0);
#else
  return BSP_ERROR_NONE;
#endif  /* DISABLE_USB_DRIVEN_ACQUISITION */
}
 800154c:	2000      	movs	r0, #0
 800154e:	4770      	bx	lr

08001550 <Audio_MuteCtl>:
  * @retval BSP_ERROR_NONE in case of success, AUDIO_ERROR otherwise
  */
static int8_t Audio_MuteCtl(uint8_t cmd)
{
  return BSP_ERROR_NONE;
}
 8001550:	2000      	movs	r0, #0
 8001552:	4770      	bx	lr

08001554 <Audio_VolumeCtl>:
{
 8001554:	b510      	push	{r4, lr}
  uint32_t j = 0;
 8001556:	2200      	movs	r2, #0
 8001558:	4c10      	ldr	r4, [pc, #64]	; (800159c <Audio_VolumeCtl+0x48>)
 800155a:	f500 4300 	add.w	r3, r0, #32768	; 0x8000
 800155e:	e001      	b.n	8001564 <Audio_VolumeCtl+0x10>
  while (j < 64 && abs(Volume - vol_table[j]) > abs(Volume - vol_table[j + 1]))
 8001560:	2a40      	cmp	r2, #64	; 0x40
 8001562:	d014      	beq.n	800158e <Audio_VolumeCtl+0x3a>
 8001564:	f934 1f02 	ldrsh.w	r1, [r4, #2]!
 8001568:	ea83 7ee3 	eor.w	lr, r3, r3, asr #31
 800156c:	ebae 7ee3 	sub.w	lr, lr, r3, asr #31
 8001570:	1a43      	subs	r3, r0, r1
 8001572:	ea83 7ce3 	eor.w	ip, r3, r3, asr #31
 8001576:	ebac 7ce3 	sub.w	ip, ip, r3, asr #31
 800157a:	45e6      	cmp	lr, ip
 800157c:	4611      	mov	r1, r2
 800157e:	f102 0201 	add.w	r2, r2, #1
 8001582:	dced      	bgt.n	8001560 <Audio_VolumeCtl+0xc>
  return CCA02M2_AUDIO_IN_SetVolume(mic_instance, j);
 8001584:	2000      	movs	r0, #0
 8001586:	f000 fdf1 	bl	800216c <CCA02M2_AUDIO_IN_SetVolume>
}
 800158a:	b240      	sxtb	r0, r0
 800158c:	bd10      	pop	{r4, pc}
 800158e:	4611      	mov	r1, r2
  return CCA02M2_AUDIO_IN_SetVolume(mic_instance, j);
 8001590:	2000      	movs	r0, #0
 8001592:	f000 fdeb 	bl	800216c <CCA02M2_AUDIO_IN_SetVolume>
}
 8001596:	b240      	sxtb	r0, r0
 8001598:	bd10      	pop	{r4, pc}
 800159a:	bf00      	nop
 800159c:	08009a34 	.word	0x08009a34

080015a0 <Audio_CommandMgr>:
 80015a0:	2000      	movs	r0, #0
 80015a2:	4770      	bx	lr

080015a4 <Audio_Stop>:
 80015a4:	2000      	movs	r0, #0
 80015a6:	4770      	bx	lr

080015a8 <Audio_Pause>:
 80015a8:	2000      	movs	r0, #0
 80015aa:	4770      	bx	lr

080015ac <Audio_Resume>:
 80015ac:	2000      	movs	r0, #0
 80015ae:	4770      	bx	lr

080015b0 <Send_Audio_to_USB>:
  *       the function. E.g.: assuming a Sampling frequency of 16 KHz and 1 channel,
  *       you can pass 16 PCM samples if the function is called each millisecond,
  *       32 samples if called every 2 milliseconds and so on.
  */
void Send_Audio_to_USB(int16_t *audioData, uint16_t PCMSamples)
{
 80015b0:	4603      	mov	r3, r0
 80015b2:	460a      	mov	r2, r1
  USBD_AUDIO_Data_Transfer(&hUSBDDevice, (int16_t *)audioData, PCMSamples);
 80015b4:	4801      	ldr	r0, [pc, #4]	; (80015bc <Send_Audio_to_USB+0xc>)
 80015b6:	4619      	mov	r1, r3
 80015b8:	f004 b99a 	b.w	80058f0 <USBD_AUDIO_Data_Transfer>
 80015bc:	20000c20 	.word	0x20000c20

080015c0 <HAL_PCD_MspInit>:
void HAL_PCD_MspInit(PCD_HandleTypeDef *hpcd)
{
  /* Note: On STM32F401-Discovery board only USB OTG FS core is supported. */
  GPIO_InitTypeDef  GPIO_InitStruct;

  if (hpcd->Instance == USB_OTG_FS)
 80015c0:	6803      	ldr	r3, [r0, #0]
 80015c2:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
 80015c6:	d000      	beq.n	80015ca <HAL_PCD_MspInit+0xa>
 80015c8:	4770      	bx	lr
{
 80015ca:	b530      	push	{r4, r5, lr}
 80015cc:	b089      	sub	sp, #36	; 0x24
  {
    /* Configure USB FS GPIOs */
    __GPIOA_CLK_ENABLE();
 80015ce:	4c19      	ldr	r4, [pc, #100]	; (8001634 <HAL_PCD_MspInit+0x74>)
    GPIO_InitStruct.Pin = GPIO_PIN_11 | GPIO_PIN_12;
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80015d0:	4819      	ldr	r0, [pc, #100]	; (8001638 <HAL_PCD_MspInit+0x78>)
    __GPIOA_CLK_ENABLE();
 80015d2:	2500      	movs	r5, #0
 80015d4:	9500      	str	r5, [sp, #0]
 80015d6:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80015d8:	f043 0301 	orr.w	r3, r3, #1
 80015dc:	6323      	str	r3, [r4, #48]	; 0x30
 80015de:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80015e0:	f003 0301 	and.w	r3, r3, #1
 80015e4:	9300      	str	r3, [sp, #0]
    GPIO_InitStruct.Pin = GPIO_PIN_11 | GPIO_PIN_12;
 80015e6:	f44f 52c0 	mov.w	r2, #6144	; 0x1800
 80015ea:	2302      	movs	r3, #2
 80015ec:	e9cd 2302 	strd	r2, r3, [sp, #8]
 80015f0:	2200      	movs	r2, #0
 80015f2:	2303      	movs	r3, #3
 80015f4:	e9cd 2304 	strd	r2, r3, [sp, #16]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80015f8:	a902      	add	r1, sp, #8
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
 80015fa:	230a      	movs	r3, #10
    __GPIOA_CLK_ENABLE();
 80015fc:	9a00      	ldr	r2, [sp, #0]
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
 80015fe:	9306      	str	r3, [sp, #24]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8001600:	f001 fadc 	bl	8002bbc <HAL_GPIO_Init>

    /* Enable USB FS Clocks */
    __USB_OTG_FS_CLK_ENABLE();
 8001604:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8001606:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800160a:	6363      	str	r3, [r4, #52]	; 0x34
 800160c:	9501      	str	r5, [sp, #4]
 800160e:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8001610:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8001614:	6463      	str	r3, [r4, #68]	; 0x44
 8001616:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8001618:	f403 4380 	and.w	r3, r3, #16384	; 0x4000

    /* Set USBFS Interrupt to the lowest priority */
    HAL_NVIC_SetPriority(OTG_FS_IRQn, 5, 0);
 800161c:	462a      	mov	r2, r5
 800161e:	2105      	movs	r1, #5
    __USB_OTG_FS_CLK_ENABLE();
 8001620:	9301      	str	r3, [sp, #4]
    HAL_NVIC_SetPriority(OTG_FS_IRQn, 5, 0);
 8001622:	2043      	movs	r0, #67	; 0x43
    __USB_OTG_FS_CLK_ENABLE();
 8001624:	9b01      	ldr	r3, [sp, #4]
    HAL_NVIC_SetPriority(OTG_FS_IRQn, 5, 0);
 8001626:	f001 f859 	bl	80026dc <HAL_NVIC_SetPriority>

    /* Enable USBFS Interrupt */
    HAL_NVIC_EnableIRQ(OTG_FS_IRQn);
 800162a:	2043      	movs	r0, #67	; 0x43
 800162c:	f001 f894 	bl	8002758 <HAL_NVIC_EnableIRQ>
  }
}
 8001630:	b009      	add	sp, #36	; 0x24
 8001632:	bd30      	pop	{r4, r5, pc}
 8001634:	40023800 	.word	0x40023800
 8001638:	40020000 	.word	0x40020000

0800163c <HAL_PCD_SetupStageCallback>:
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_SetupStageCallback(PCD_HandleTypeDef *hpcd)
{
  USBD_LL_SetupStage(hpcd->pData, (uint8_t *)hpcd->Setup);
 800163c:	f200 41c4 	addw	r1, r0, #1220	; 0x4c4
 8001640:	f8d0 0508 	ldr.w	r0, [r0, #1288]	; 0x508
 8001644:	f004 bf7a 	b.w	800653c <USBD_LL_SetupStage>

08001648 <HAL_PCD_DataOutStageCallback>:
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_DataOutStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
{
  USBD_LL_DataOutStage(hpcd->pData, epnum, hpcd->OUT_ep[epnum].xfer_buff);
 8001648:	eb01 03c1 	add.w	r3, r1, r1, lsl #3
 800164c:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 8001650:	f8d0 0508 	ldr.w	r0, [r0, #1288]	; 0x508
 8001654:	f8d3 228c 	ldr.w	r2, [r3, #652]	; 0x28c
 8001658:	f004 bfa0 	b.w	800659c <USBD_LL_DataOutStage>

0800165c <HAL_PCD_DataInStageCallback>:
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_DataInStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
{
  USBD_LL_DataInStage(hpcd->pData, epnum, hpcd->IN_ep[epnum].xfer_buff);
 800165c:	eb01 03c1 	add.w	r3, r1, r1, lsl #3
 8001660:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 8001664:	f8d0 0508 	ldr.w	r0, [r0, #1288]	; 0x508
 8001668:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800166a:	f004 bfd1 	b.w	8006610 <USBD_LL_DataInStage>
 800166e:	bf00      	nop

08001670 <HAL_PCD_SOFCallback>:
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_SOFCallback(PCD_HandleTypeDef *hpcd)
{
  USBD_LL_SOF(hpcd->pData);
 8001670:	f8d0 0508 	ldr.w	r0, [r0, #1288]	; 0x508
 8001674:	f005 b870 	b.w	8006758 <USBD_LL_SOF>

08001678 <HAL_PCD_ResetCallback>:
  * @brief  SOF callback.
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_ResetCallback(PCD_HandleTypeDef *hpcd)
{
 8001678:	b510      	push	{r4, lr}
  USBD_SpeedTypeDef speed = USBD_SPEED_FULL;

  /*Set USB Current Speed*/
  switch (hpcd->Init.speed)
 800167a:	68c1      	ldr	r1, [r0, #12]
{
 800167c:	4604      	mov	r4, r0

    default:
      speed = USBD_SPEED_FULL;
      break;
  }
  USBD_LL_SetSpeed(hpcd->pData, speed);
 800167e:	3900      	subs	r1, #0
 8001680:	f8d0 0508 	ldr.w	r0, [r0, #1288]	; 0x508
 8001684:	bf18      	it	ne
 8001686:	2101      	movne	r1, #1
 8001688:	f005 f84a 	bl	8006720 <USBD_LL_SetSpeed>

  /*Reset Device*/
  USBD_LL_Reset(hpcd->pData);
 800168c:	f8d4 0508 	ldr.w	r0, [r4, #1288]	; 0x508
}
 8001690:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  USBD_LL_Reset(hpcd->pData);
 8001694:	f005 b816 	b.w	80066c4 <USBD_LL_Reset>

08001698 <HAL_PCD_SuspendCallback>:
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_SuspendCallback(PCD_HandleTypeDef *hpcd)
{
  USBD_LL_Suspend(hpcd->pData);
 8001698:	f8d0 0508 	ldr.w	r0, [r0, #1288]	; 0x508
 800169c:	f005 b844 	b.w	8006728 <USBD_LL_Suspend>

080016a0 <HAL_PCD_ResumeCallback>:
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_ResumeCallback(PCD_HandleTypeDef *hpcd)
{
  USBD_LL_Resume(hpcd->pData);
 80016a0:	f8d0 0508 	ldr.w	r0, [r0, #1288]	; 0x508
 80016a4:	f005 b84c 	b.w	8006740 <USBD_LL_Resume>

080016a8 <HAL_PCD_ISOOUTIncompleteCallback>:
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_ISOOUTIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
{
  USBD_LL_IsoOUTIncomplete(hpcd->pData, epnum);
 80016a8:	f8d0 0508 	ldr.w	r0, [r0, #1288]	; 0x508
 80016ac:	f005 b87a 	b.w	80067a4 <USBD_LL_IsoOUTIncomplete>

080016b0 <HAL_PCD_ISOINIncompleteCallback>:
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_ISOINIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
{
  USBD_LL_IsoINIncomplete(hpcd->pData, epnum);
 80016b0:	f8d0 0508 	ldr.w	r0, [r0, #1288]	; 0x508
 80016b4:	f005 b860 	b.w	8006778 <USBD_LL_IsoINIncomplete>

080016b8 <HAL_PCD_ConnectCallback>:
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_ConnectCallback(PCD_HandleTypeDef *hpcd)
{
  USBD_LL_DevConnected(hpcd->pData);
 80016b8:	f8d0 0508 	ldr.w	r0, [r0, #1288]	; 0x508
 80016bc:	f005 b888 	b.w	80067d0 <USBD_LL_DevConnected>

080016c0 <HAL_PCD_DisconnectCallback>:
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_DisconnectCallback(PCD_HandleTypeDef *hpcd)
{
  USBD_LL_DevDisconnected(hpcd->pData);
 80016c0:	f8d0 0508 	ldr.w	r0, [r0, #1288]	; 0x508
 80016c4:	f005 b886 	b.w	80067d4 <USBD_LL_DevDisconnected>

080016c8 <USBD_LL_Init>:
  *         Initialize the Low Level portion of the Device driver.
  * @param  pdev: Device handle
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_Init(USBD_HandleTypeDef *pdev)
{
 80016c8:	b570      	push	{r4, r5, r6, lr}
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80016ca:	4b15      	ldr	r3, [pc, #84]	; (8001720 <USBD_LL_Init+0x58>)
  /* Change Systick prioity */
  NVIC_SetPriority(SysTick_IRQn, 0);

  /*Set LL Driver parameters */
  hpcd.Instance = USB_OTG_FS;
 80016cc:	4c15      	ldr	r4, [pc, #84]	; (8001724 <USBD_LL_Init+0x5c>)
 80016ce:	2500      	movs	r5, #0
 80016d0:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
 80016d4:	f883 5023 	strb.w	r5, [r3, #35]	; 0x23
  hpcd.Init.dev_endpoints = 3;
  hpcd.Init.use_dedicated_ep1 = 0;
  hpcd.Init.ep0_mps = 0x40;
 80016d8:	2640      	movs	r6, #64	; 0x40
  hpcd.Init.dma_enable = 0;
  hpcd.Init.low_power_enable = 0;
  hpcd.Init.phy_itface = PCD_PHY_EMBEDDED;
 80016da:	2302      	movs	r3, #2
  hpcd.Init.Sof_enable = 0;
  hpcd.Init.speed = PCD_SPEED_FULL;
  hpcd.Init.vbus_sensing_enable = 0;
  /* Link The driver to the stack */
  hpcd.pData = pdev;
 80016dc:	f8c4 0508 	str.w	r0, [r4, #1288]	; 0x508
  hpcd.Instance = USB_OTG_FS;
 80016e0:	6022      	str	r2, [r4, #0]
  pdev->pData = &hpcd;
 80016e2:	f8c0 42c8 	str.w	r4, [r0, #712]	; 0x2c8
  hpcd.Init.dev_endpoints = 3;
 80016e6:	2203      	movs	r2, #3
  /*Initialize LL Driver */
  HAL_PCD_Init(&hpcd);
 80016e8:	4620      	mov	r0, r4
  hpcd.Init.Sof_enable = 0;
 80016ea:	e9c4 3506 	strd	r3, r5, [r4, #24]
  hpcd.Init.speed = PCD_SPEED_FULL;
 80016ee:	60e3      	str	r3, [r4, #12]
  hpcd.Init.dev_endpoints = 3;
 80016f0:	6062      	str	r2, [r4, #4]
  hpcd.Init.dma_enable = 0;
 80016f2:	e9c4 5604 	strd	r5, r6, [r4, #16]
  hpcd.Init.use_dedicated_ep1 = 0;
 80016f6:	6325      	str	r5, [r4, #48]	; 0x30
  hpcd.Init.low_power_enable = 0;
 80016f8:	6225      	str	r5, [r4, #32]
  hpcd.Init.vbus_sensing_enable = 0;
 80016fa:	62e5      	str	r5, [r4, #44]	; 0x2c
  HAL_PCD_Init(&hpcd);
 80016fc:	f7fe feee 	bl	80004dc <HAL_PCD_Init>

  HAL_PCD_SetRxFiFo(&hpcd, 0x80);
 8001700:	2180      	movs	r1, #128	; 0x80
 8001702:	4620      	mov	r0, r4
 8001704:	f001 fe6e 	bl	80033e4 <HAL_PCDEx_SetRxFiFo>
  HAL_PCD_SetTxFiFo(&hpcd, 0, 0x40);
 8001708:	4632      	mov	r2, r6
 800170a:	4629      	mov	r1, r5
 800170c:	4620      	mov	r0, r4
 800170e:	f001 fe3f 	bl	8003390 <HAL_PCDEx_SetTxFiFo>
  HAL_PCD_SetTxFiFo(&hpcd, 1, 0x64);
 8001712:	2264      	movs	r2, #100	; 0x64
 8001714:	2101      	movs	r1, #1
 8001716:	4620      	mov	r0, r4
 8001718:	f001 fe3a 	bl	8003390 <HAL_PCDEx_SetTxFiFo>


  return USBD_OK;
}
 800171c:	4628      	mov	r0, r5
 800171e:	bd70      	pop	{r4, r5, r6, pc}
 8001720:	e000ed00 	.word	0xe000ed00
 8001724:	20000f04 	.word	0x20000f04

08001728 <USBD_LL_Start>:
  *         Start the Low Level portion of the Device driver.
  * @param  pdev: Device handle
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_Start(USBD_HandleTypeDef *pdev)
{
 8001728:	b508      	push	{r3, lr}
  HAL_PCD_Start(pdev->pData);
 800172a:	f8d0 02c8 	ldr.w	r0, [r0, #712]	; 0x2c8
 800172e:	f7fe ff63 	bl	80005f8 <HAL_PCD_Start>
  return USBD_OK;
}
 8001732:	2000      	movs	r0, #0
 8001734:	bd08      	pop	{r3, pc}
 8001736:	bf00      	nop

08001738 <USBD_LL_OpenEP>:
  * @param  ep_type: Endpoint Type
  * @param  ep_mps: Endpoint Max Packet Size
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_OpenEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr, uint8_t ep_type, uint16_t ep_mps)
{
 8001738:	b508      	push	{r3, lr}
 800173a:	4694      	mov	ip, r2
  HAL_PCD_EP_Open(pdev->pData,
 800173c:	f8d0 02c8 	ldr.w	r0, [r0, #712]	; 0x2c8
{
 8001740:	461a      	mov	r2, r3
  HAL_PCD_EP_Open(pdev->pData,
 8001742:	4663      	mov	r3, ip
 8001744:	f7ff fc90 	bl	8001068 <HAL_PCD_EP_Open>
                  ep_addr,
                  ep_mps,
                  ep_type);

  return USBD_OK;
}
 8001748:	2000      	movs	r0, #0
 800174a:	bd08      	pop	{r3, pc}

0800174c <USBD_LL_CloseEP>:
  * @param  pdev: device handle
  * @param  ep_addr: Endpoint Number
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_CloseEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 800174c:	b508      	push	{r3, lr}
  HAL_PCD_EP_Close(pdev->pData, ep_addr);
 800174e:	f8d0 02c8 	ldr.w	r0, [r0, #712]	; 0x2c8
 8001752:	f7ff fcc7 	bl	80010e4 <HAL_PCD_EP_Close>
  return USBD_OK;
}
 8001756:	2000      	movs	r0, #0
 8001758:	bd08      	pop	{r3, pc}
 800175a:	bf00      	nop

0800175c <USBD_LL_FlushEP>:
  * @param  pdev: device handle
  * @param  ep_addr: Endpoint Number
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_FlushEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 800175c:	b508      	push	{r3, lr}
  HAL_PCD_EP_Flush(pdev->pData, ep_addr);
 800175e:	f8d0 02c8 	ldr.w	r0, [r0, #712]	; 0x2c8
 8001762:	f7ff fdb9 	bl	80012d8 <HAL_PCD_EP_Flush>
  return USBD_OK;
}
 8001766:	2000      	movs	r0, #0
 8001768:	bd08      	pop	{r3, pc}
 800176a:	bf00      	nop

0800176c <USBD_LL_StallEP>:
  * @param  pdev: device handle
  * @param  ep_addr: Endpoint Number
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_StallEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 800176c:	b508      	push	{r3, lr}
  HAL_PCD_EP_SetStall(pdev->pData, ep_addr);
 800176e:	f8d0 02c8 	ldr.w	r0, [r0, #712]	; 0x2c8
 8001772:	f7ff fd35 	bl	80011e0 <HAL_PCD_EP_SetStall>
  return USBD_OK;
}
 8001776:	2000      	movs	r0, #0
 8001778:	bd08      	pop	{r3, pc}
 800177a:	bf00      	nop

0800177c <USBD_LL_ClearStallEP>:
  * @param  pdev: device handle
  * @param  ep_addr: Endpoint Number
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_ClearStallEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 800177c:	b508      	push	{r3, lr}
  HAL_PCD_EP_ClrStall(pdev->pData, ep_addr);
 800177e:	f8d0 02c8 	ldr.w	r0, [r0, #712]	; 0x2c8
 8001782:	f7ff fd71 	bl	8001268 <HAL_PCD_EP_ClrStall>
  return USBD_OK;
}
 8001786:	2000      	movs	r0, #0
 8001788:	bd08      	pop	{r3, pc}
 800178a:	bf00      	nop

0800178c <USBD_LL_IsStallEP>:
  */
uint8_t USBD_LL_IsStallEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
  PCD_HandleTypeDef *hpcd = pdev->pData;

  if ((ep_addr & 0x80) == 0x80)
 800178c:	060a      	lsls	r2, r1, #24
  PCD_HandleTypeDef *hpcd = pdev->pData;
 800178e:	f8d0 32c8 	ldr.w	r3, [r0, #712]	; 0x2c8
  if ((ep_addr & 0x80) == 0x80)
 8001792:	d406      	bmi.n	80017a2 <USBD_LL_IsStallEP+0x16>
  {
    return hpcd->IN_ep[ep_addr & 0x7F].is_stall;
  }
  else
  {
    return hpcd->OUT_ep[ep_addr & 0x7F].is_stall;
 8001794:	eb01 01c1 	add.w	r1, r1, r1, lsl #3
 8001798:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 800179c:	f891 027e 	ldrb.w	r0, [r1, #638]	; 0x27e
  }
}
 80017a0:	4770      	bx	lr
    return hpcd->IN_ep[ep_addr & 0x7F].is_stall;
 80017a2:	f001 017f 	and.w	r1, r1, #127	; 0x7f
 80017a6:	eb01 01c1 	add.w	r1, r1, r1, lsl #3
 80017aa:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 80017ae:	f891 003e 	ldrb.w	r0, [r1, #62]	; 0x3e
 80017b2:	4770      	bx	lr

080017b4 <USBD_LL_SetUSBAddress>:
  * @param  pdev: device handle
  * @param  ep_addr: Endpoint Number
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_SetUSBAddress(USBD_HandleTypeDef *pdev, uint8_t dev_addr)
{
 80017b4:	b508      	push	{r3, lr}
  HAL_PCD_SetAddress(pdev->pData, dev_addr);
 80017b6:	f8d0 02c8 	ldr.w	r0, [r0, #712]	; 0x2c8
 80017ba:	f7ff fc41 	bl	8001040 <HAL_PCD_SetAddress>
  return USBD_OK;
}
 80017be:	2000      	movs	r0, #0
 80017c0:	bd08      	pop	{r3, pc}
 80017c2:	bf00      	nop

080017c4 <USBD_LL_Transmit>:
  * @param  pbuf:pointer to data to be sent
  * @param  size: data size
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_Transmit(USBD_HandleTypeDef *pdev, uint8_t ep_addr, uint8_t *pbuf, uint32_t size)
{
 80017c4:	b508      	push	{r3, lr}
  HAL_PCD_EP_Transmit(pdev->pData, ep_addr, pbuf, size);
 80017c6:	f8d0 02c8 	ldr.w	r0, [r0, #712]	; 0x2c8
 80017ca:	f7ff fce1 	bl	8001190 <HAL_PCD_EP_Transmit>
  return USBD_OK;
}
 80017ce:	2000      	movs	r0, #0
 80017d0:	bd08      	pop	{r3, pc}
 80017d2:	bf00      	nop

080017d4 <USBD_LL_PrepareReceive>:
  * @param  pbuf:pointer to data to be received
  * @param  size: data size
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_PrepareReceive(USBD_HandleTypeDef *pdev, uint8_t ep_addr, uint8_t *pbuf, uint32_t size)
{
 80017d4:	b508      	push	{r3, lr}
  HAL_PCD_EP_Receive(pdev->pData, ep_addr, pbuf, size);
 80017d6:	f8d0 02c8 	ldr.w	r0, [r0, #712]	; 0x2c8
 80017da:	f7ff fcb1 	bl	8001140 <HAL_PCD_EP_Receive>
  return USBD_OK;
}
 80017de:	2000      	movs	r0, #0
 80017e0:	bd08      	pop	{r3, pc}
 80017e2:	bf00      	nop

080017e4 <USBD_AUDIO_DeviceDescriptor>:
  * @param  length: Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t *USBD_AUDIO_DeviceDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
  *length = sizeof(hUSBDDeviceDesc);
 80017e4:	2312      	movs	r3, #18
  return hUSBDDeviceDesc;
}
 80017e6:	4801      	ldr	r0, [pc, #4]	; (80017ec <USBD_AUDIO_DeviceDescriptor+0x8>)
  *length = sizeof(hUSBDDeviceDesc);
 80017e8:	800b      	strh	r3, [r1, #0]
}
 80017ea:	4770      	bx	lr
 80017ec:	20000024 	.word	0x20000024

080017f0 <USBD_AUDIO_LangIDStrDescriptor>:
  * @param  length: Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t *USBD_AUDIO_LangIDStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
  *length = sizeof(USBD_LangIDDesc);
 80017f0:	2304      	movs	r3, #4
  return USBD_LangIDDesc;
}
 80017f2:	4801      	ldr	r0, [pc, #4]	; (80017f8 <USBD_AUDIO_LangIDStrDescriptor+0x8>)
  *length = sizeof(USBD_LangIDDesc);
 80017f4:	800b      	strh	r3, [r1, #0]
}
 80017f6:	4770      	bx	lr
 80017f8:	20000038 	.word	0x20000038

080017fc <USBD_AUDIO_ManufacturerStrDescriptor>:
  * @param  speed: Current device speed
  * @param  length: Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t *USBD_AUDIO_ManufacturerStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 80017fc:	b510      	push	{r4, lr}
  USBD_GetString((uint8_t *)USBD_MANUFACTURER_STRING, USBD_StrDesc, length);
 80017fe:	4c04      	ldr	r4, [pc, #16]	; (8001810 <USBD_AUDIO_ManufacturerStrDescriptor+0x14>)
 8001800:	4804      	ldr	r0, [pc, #16]	; (8001814 <USBD_AUDIO_ManufacturerStrDescriptor+0x18>)
{
 8001802:	460a      	mov	r2, r1
  USBD_GetString((uint8_t *)USBD_MANUFACTURER_STRING, USBD_StrDesc, length);
 8001804:	4621      	mov	r1, r4
 8001806:	f005 fab3 	bl	8006d70 <USBD_GetString>
  return USBD_StrDesc;
}
 800180a:	4620      	mov	r0, r4
 800180c:	bd10      	pop	{r4, pc}
 800180e:	bf00      	nop
 8001810:	20001410 	.word	0x20001410
 8001814:	08009c94 	.word	0x08009c94

08001818 <USBD_AUDIO_ProductStrDescriptor>:
{
 8001818:	460a      	mov	r2, r1
 800181a:	b508      	push	{r3, lr}
    USBD_GetString((uint8_t *)USBD_PRODUCT_HS_STRING, USBD_StrDesc, length);
 800181c:	4905      	ldr	r1, [pc, #20]	; (8001834 <USBD_AUDIO_ProductStrDescriptor+0x1c>)
  if (speed == 0)
 800181e:	b920      	cbnz	r0, 800182a <USBD_AUDIO_ProductStrDescriptor+0x12>
    USBD_GetString((uint8_t *)USBD_PRODUCT_HS_STRING, USBD_StrDesc, length);
 8001820:	4805      	ldr	r0, [pc, #20]	; (8001838 <USBD_AUDIO_ProductStrDescriptor+0x20>)
 8001822:	f005 faa5 	bl	8006d70 <USBD_GetString>
}
 8001826:	4803      	ldr	r0, [pc, #12]	; (8001834 <USBD_AUDIO_ProductStrDescriptor+0x1c>)
 8001828:	bd08      	pop	{r3, pc}
    USBD_GetString((uint8_t *)USBD_PRODUCT_FS_STRING, USBD_StrDesc, length);
 800182a:	4804      	ldr	r0, [pc, #16]	; (800183c <USBD_AUDIO_ProductStrDescriptor+0x24>)
 800182c:	f005 faa0 	bl	8006d70 <USBD_GetString>
}
 8001830:	4800      	ldr	r0, [pc, #0]	; (8001834 <USBD_AUDIO_ProductStrDescriptor+0x1c>)
 8001832:	bd08      	pop	{r3, pc}
 8001834:	20001410 	.word	0x20001410
 8001838:	08009ca8 	.word	0x08009ca8
 800183c:	08009ccc 	.word	0x08009ccc

08001840 <USBD_AUDIO_SerialStrDescriptor>:
  * @param  speed: Current device speed
  * @param  length: Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t *USBD_AUDIO_SerialStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 8001840:	460a      	mov	r2, r1
 8001842:	b508      	push	{r3, lr}
  if (speed == USBD_SPEED_HIGH)
  {
    USBD_GetString((uint8_t *)USBD_SERIALNUMBER_HS_STRING, USBD_StrDesc, length);
 8001844:	4905      	ldr	r1, [pc, #20]	; (800185c <USBD_AUDIO_SerialStrDescriptor+0x1c>)
  if (speed == USBD_SPEED_HIGH)
 8001846:	b920      	cbnz	r0, 8001852 <USBD_AUDIO_SerialStrDescriptor+0x12>
    USBD_GetString((uint8_t *)USBD_SERIALNUMBER_HS_STRING, USBD_StrDesc, length);
 8001848:	4805      	ldr	r0, [pc, #20]	; (8001860 <USBD_AUDIO_SerialStrDescriptor+0x20>)
 800184a:	f005 fa91 	bl	8006d70 <USBD_GetString>
  else
  {
    USBD_GetString((uint8_t *)USBD_SERIALNUMBER_FS_STRING, USBD_StrDesc, length);
  }
  return USBD_StrDesc;
}
 800184e:	4803      	ldr	r0, [pc, #12]	; (800185c <USBD_AUDIO_SerialStrDescriptor+0x1c>)
 8001850:	bd08      	pop	{r3, pc}
    USBD_GetString((uint8_t *)USBD_SERIALNUMBER_FS_STRING, USBD_StrDesc, length);
 8001852:	4804      	ldr	r0, [pc, #16]	; (8001864 <USBD_AUDIO_SerialStrDescriptor+0x24>)
 8001854:	f005 fa8c 	bl	8006d70 <USBD_GetString>
}
 8001858:	4800      	ldr	r0, [pc, #0]	; (800185c <USBD_AUDIO_SerialStrDescriptor+0x1c>)
 800185a:	bd08      	pop	{r3, pc}
 800185c:	20001410 	.word	0x20001410
 8001860:	08009cf0 	.word	0x08009cf0
 8001864:	08009d00 	.word	0x08009d00

08001868 <USBD_AUDIO_ConfigStrDescriptor>:
  * @param  speed: Current device speed
  * @param  length: Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t *USBD_AUDIO_ConfigStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 8001868:	b510      	push	{r4, lr}
  if (speed == USBD_SPEED_HIGH)
  {
    USBD_GetString((uint8_t *)USBD_CONFIGURATION_HS_STRING, USBD_StrDesc, length);
 800186a:	4c04      	ldr	r4, [pc, #16]	; (800187c <USBD_AUDIO_ConfigStrDescriptor+0x14>)
 800186c:	4804      	ldr	r0, [pc, #16]	; (8001880 <USBD_AUDIO_ConfigStrDescriptor+0x18>)
{
 800186e:	460a      	mov	r2, r1
    USBD_GetString((uint8_t *)USBD_CONFIGURATION_HS_STRING, USBD_StrDesc, length);
 8001870:	4621      	mov	r1, r4
 8001872:	f005 fa7d 	bl	8006d70 <USBD_GetString>
  else
  {
    USBD_GetString((uint8_t *)USBD_CONFIGURATION_FS_STRING, USBD_StrDesc, length);
  }
  return USBD_StrDesc;
}
 8001876:	4620      	mov	r0, r4
 8001878:	bd10      	pop	{r4, pc}
 800187a:	bf00      	nop
 800187c:	20001410 	.word	0x20001410
 8001880:	08009d10 	.word	0x08009d10

08001884 <USBD_AUDIO_InterfaceStrDescriptor>:
  * @param  speed: Current device speed
  * @param  length: Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t *USBD_AUDIO_InterfaceStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 8001884:	b510      	push	{r4, lr}
  if (speed == 0)
  {
    USBD_GetString((uint8_t *)USBD_INTERFACE_HS_STRING, USBD_StrDesc, length);
 8001886:	4c04      	ldr	r4, [pc, #16]	; (8001898 <USBD_AUDIO_InterfaceStrDescriptor+0x14>)
 8001888:	4804      	ldr	r0, [pc, #16]	; (800189c <USBD_AUDIO_InterfaceStrDescriptor+0x18>)
{
 800188a:	460a      	mov	r2, r1
    USBD_GetString((uint8_t *)USBD_INTERFACE_HS_STRING, USBD_StrDesc, length);
 800188c:	4621      	mov	r1, r4
 800188e:	f005 fa6f 	bl	8006d70 <USBD_GetString>
  else
  {
    USBD_GetString((uint8_t *)USBD_INTERFACE_FS_STRING, USBD_StrDesc, length);
  }
  return USBD_StrDesc;
}
 8001892:	4620      	mov	r0, r4
 8001894:	bd10      	pop	{r4, pc}
 8001896:	bf00      	nop
 8001898:	20001410 	.word	0x20001410
 800189c:	08009d20 	.word	0x08009d20

080018a0 <MX_I2S_IN_ClockConfig>:
* @note   This API is called by CCA02M2_AUDIO_IN_Init() 
*         Being __weak it can be overwritten by the application     
* @retval HAL_OK if no problem during execution, HAL_ERROR otherwise
*/
__weak HAL_StatusTypeDef MX_I2S_IN_ClockConfig(I2S_HandleTypeDef *hi2s, uint32_t PDM_rate)
{ 
 80018a0:	b510      	push	{r4, lr}
 80018a2:	b086      	sub	sp, #24
  UNUSED(hi2s);
  
  HAL_StatusTypeDef ret = HAL_OK;
  /*I2S PLL Configuration*/
  RCC_PeriphCLKInitTypeDef rccclkinit;
  HAL_RCCEx_GetPeriphCLKConfig(&rccclkinit); 
 80018a4:	a801      	add	r0, sp, #4
{ 
 80018a6:	460c      	mov	r4, r1
  HAL_RCCEx_GetPeriphCLKConfig(&rccclkinit); 
 80018a8:	f002 f90c 	bl	8003ac4 <HAL_RCCEx_GetPeriphCLKConfig>
 80018ac:	490c      	ldr	r1, [pc, #48]	; (80018e0 <MX_I2S_IN_ClockConfig+0x40>)
  
#if defined(STM32F446xx)
  rccclkinit.PLLI2S.PLLI2SQ = 2;
  rccclkinit.PLLI2SDivQ = 1;
#endif
  if ((PDM_rate % 1280U) == 0U)
 80018ae:	4b0d      	ldr	r3, [pc, #52]	; (80018e4 <MX_I2S_IN_ClockConfig+0x44>)
  HAL_RCCEx_GetPeriphCLKConfig(&rccclkinit); 
 80018b0:	fb01 f404 	mul.w	r4, r1, r4
 80018b4:	ea4f 2434 	mov.w	r4, r4, ror #8
#if defined(STM32F411xE) || defined (STM32F446xx)
    
    rccclkinit.PLLI2S.PLLI2SM = 8;
#endif
    rccclkinit.PLLI2S.PLLI2SN = 258;
    rccclkinit.PLLI2S.PLLI2SR = 3;
 80018b8:	429c      	cmp	r4, r3
 80018ba:	bf95      	itete	ls
 80018bc:	2105      	movls	r1, #5
 80018be:	2103      	movhi	r1, #3
 80018c0:	22c0      	movls	r2, #192	; 0xc0
 80018c2:	f44f 7281 	movhi.w	r2, #258	; 0x102
  }   
  
#if defined(STM32F446xx)
  rccclkinit.PeriphClockSelection = RCC_PERIPHCLK_I2S_APB2;
#else
  rccclkinit.PeriphClockSelection = RCC_PERIPHCLK_I2S;
 80018c6:	2301      	movs	r3, #1
#endif
  
  if(HAL_RCCEx_PeriphCLKConfig(&rccclkinit) != HAL_OK)
 80018c8:	a801      	add	r0, sp, #4
 80018ca:	e9cd 2102 	strd	r2, r1, [sp, #8]
  rccclkinit.PeriphClockSelection = RCC_PERIPHCLK_I2S;
 80018ce:	9301      	str	r3, [sp, #4]
  if(HAL_RCCEx_PeriphCLKConfig(&rccclkinit) != HAL_OK)
 80018d0:	f002 f84e 	bl	8003970 <HAL_RCCEx_PeriphCLKConfig>
  {
    ret = HAL_ERROR;
  }  
  return ret;
}
 80018d4:	3800      	subs	r0, #0
 80018d6:	bf18      	it	ne
 80018d8:	2001      	movne	r0, #1
 80018da:	b006      	add	sp, #24
 80018dc:	bd10      	pop	{r4, pc}
 80018de:	bf00      	nop
 80018e0:	cccccccd 	.word	0xcccccccd
 80018e4:	00333333 	.word	0x00333333

080018e8 <MX_SPI_Init>:



__weak HAL_StatusTypeDef MX_SPI_Init(SPI_HandleTypeDef* hspi, MX_SPI_Config *MXConfig)
{  
 80018e8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  static DMA_HandleTypeDef hdma_rx;
  HAL_StatusTypeDef ret = HAL_OK;
  
  hspi->Init.BaudRatePrescaler = MXConfig->BaudRatePrescaler; 
 80018ea:	698b      	ldr	r3, [r1, #24]
  hspi->Init.Direction         = MXConfig->Direction;         
 80018ec:	684a      	ldr	r2, [r1, #4]
  hspi->Init.BaudRatePrescaler = MXConfig->BaudRatePrescaler; 
 80018ee:	61c3      	str	r3, [r0, #28]
  hspi->Init.CLKPhase          = MXConfig->CLKPhase;          
 80018f0:	690b      	ldr	r3, [r1, #16]
 80018f2:	6143      	str	r3, [r0, #20]
  hspi->Init.CLKPolarity       = MXConfig->CLKPolarity;       
  hspi->Init.CRCCalculation    = MXConfig->CRCCalculation;    
  hspi->Init.CRCPolynomial     = MXConfig->CRCPolynomial;     
  hspi->Init.DataSize          = MXConfig->DataSize;          
 80018f4:	e9d1 7302 	ldrd	r7, r3, [r1, #8]
{  
 80018f8:	4605      	mov	r5, r0
  hspi->Init.Direction         = MXConfig->Direction;         
 80018fa:	6082      	str	r2, [r0, #8]
  hspi->Init.NSS               = MXConfig->NSS;               
  hspi->Init.TIMode            = MXConfig->TIMode;            
  hspi->Init.Mode              = MXConfig->Mode; 
  
  /* Configure the DMA handler for Transmission process */
  hdma_rx.Instance                 = AUDIO_IN_SPI_RX_DMA_STREAM;
 80018fc:	4c20      	ldr	r4, [pc, #128]	; (8001980 <MX_SPI_Init+0x98>)
  hspi->Init.CRCCalculation    = MXConfig->CRCCalculation;    
 80018fe:	6a4a      	ldr	r2, [r1, #36]	; 0x24
  hspi->Init.CLKPolarity       = MXConfig->CLKPolarity;       
 8001900:	6103      	str	r3, [r0, #16]
  hspi->Init.CRCPolynomial     = MXConfig->CRCPolynomial;     
 8001902:	6a8b      	ldr	r3, [r1, #40]	; 0x28
  hspi->Init.FirstBit          = MXConfig->FirstBit;         
 8001904:	f8d1 c01c 	ldr.w	ip, [r1, #28]
  hspi->Init.CRCCalculation    = MXConfig->CRCCalculation;    
 8001908:	6282      	str	r2, [r0, #40]	; 0x28
  hspi->Init.Mode              = MXConfig->Mode; 
 800190a:	680a      	ldr	r2, [r1, #0]
  hspi->Init.NSS               = MXConfig->NSS;               
 800190c:	6948      	ldr	r0, [r1, #20]
  hspi->Init.CRCPolynomial     = MXConfig->CRCPolynomial;     
 800190e:	62eb      	str	r3, [r5, #44]	; 0x2c
  hspi->Init.TIMode            = MXConfig->TIMode;            
 8001910:	6a0b      	ldr	r3, [r1, #32]
  hdma_rx.Instance                 = AUDIO_IN_SPI_RX_DMA_STREAM;
 8001912:	491c      	ldr	r1, [pc, #112]	; (8001984 <MX_SPI_Init+0x9c>)
 8001914:	f8c4 112c 	str.w	r1, [r4, #300]	; 0x12c
  hdma_rx.Init.Channel             = AUDIO_IN_SPI_RX_DMA_CHANNEL;
 8001918:	f04f 61c0 	mov.w	r1, #100663296	; 0x6000000
  hspi->Init.Mode              = MXConfig->Mode; 
 800191c:	606a      	str	r2, [r5, #4]
  hspi->Init.DataSize          = MXConfig->DataSize;          
 800191e:	60ef      	str	r7, [r5, #12]
  hdma_rx.Init.Channel             = AUDIO_IN_SPI_RX_DMA_CHANNEL;
 8001920:	f8c4 1130 	str.w	r1, [r4, #304]	; 0x130
  hdma_rx.Init.Direction           = DMA_PERIPH_TO_MEMORY;
  hdma_rx.Init.PeriphInc           = DMA_PINC_DISABLE;
  hdma_rx.Init.MemInc              = DMA_MINC_ENABLE;
  hdma_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;
 8001924:	f44f 6780 	mov.w	r7, #1024	; 0x400
 8001928:	f44f 6100 	mov.w	r1, #2048	; 0x800
  hspi->Init.FirstBit          = MXConfig->FirstBit;         
 800192c:	f8c5 c020 	str.w	ip, [r5, #32]
  hspi->Init.TIMode            = MXConfig->TIMode;            
 8001930:	626b      	str	r3, [r5, #36]	; 0x24
  hdma_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;
 8001932:	e9c4 714f 	strd	r7, r1, [r4, #316]	; 0x13c
  hdma_rx.Init.Direction           = DMA_PERIPH_TO_MEMORY;
 8001936:	2300      	movs	r3, #0
  hdma_rx.Init.MemDataAlignment    = DMA_MDATAALIGN_HALFWORD;
  hdma_rx.Init.Mode                = DMA_CIRCULAR;
 8001938:	f44f 5c00 	mov.w	ip, #8192	; 0x2000
 800193c:	f44f 7180 	mov.w	r1, #256	; 0x100
  hspi->Init.NSS               = MXConfig->NSS;               
 8001940:	61a8      	str	r0, [r5, #24]
  hdma_rx.Init.PeriphInc           = DMA_PINC_DISABLE;
 8001942:	e9c4 334d 	strd	r3, r3, [r4, #308]	; 0x134
  hdma_rx.Init.Mode                = DMA_CIRCULAR;
 8001946:	e9c4 c151 	strd	ip, r1, [r4, #324]	; 0x144
  hdma_rx.Init.FIFOThreshold       = DMA_FIFO_THRESHOLD_FULL;
  hdma_rx.Init.MemBurst            = DMA_MBURST_INC4;
  hdma_rx.Init.PeriphBurst         = DMA_PBURST_INC4;
  
  /* Configure the DMA Stream */ 
  if (HAL_DMA_Init(&hdma_rx) != HAL_OK)
 800194a:	f504 7696 	add.w	r6, r4, #300	; 0x12c
  hdma_rx.Init.FIFOMode            = DMA_FIFOMODE_DISABLE;
 800194e:	f8c4 3150 	str.w	r3, [r4, #336]	; 0x150
  hdma_rx.Init.Priority            = DMA_PRIORITY_HIGH;
 8001952:	f44f 3100 	mov.w	r1, #131072	; 0x20000
  hdma_rx.Init.FIFOThreshold       = DMA_FIFO_THRESHOLD_FULL;
 8001956:	2303      	movs	r3, #3
  hdma_rx.Init.Priority            = DMA_PRIORITY_HIGH;
 8001958:	f8c4 114c 	str.w	r1, [r4, #332]	; 0x14c
  hdma_rx.Init.MemBurst            = DMA_MBURST_INC4;
 800195c:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
  hdma_rx.Init.FIFOThreshold       = DMA_FIFO_THRESHOLD_FULL;
 8001960:	f8c4 3154 	str.w	r3, [r4, #340]	; 0x154
  if (HAL_DMA_Init(&hdma_rx) != HAL_OK)
 8001964:	4630      	mov	r0, r6
  hdma_rx.Init.PeriphBurst         = DMA_PBURST_INC4;
 8001966:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800196a:	e9c4 2356 	strd	r2, r3, [r4, #344]	; 0x158
  if (HAL_DMA_Init(&hdma_rx) != HAL_OK)
 800196e:	f000 ff1b 	bl	80027a8 <HAL_DMA_Init>
  
  /* Associate the initialized DMA handle to the the SPI handle */
  __HAL_LINKDMA(hspi, hdmarx, hdma_rx);      
  
  return ret;
}
 8001972:	3800      	subs	r0, #0
  __HAL_LINKDMA(hspi, hdmarx, hdma_rx);      
 8001974:	64ee      	str	r6, [r5, #76]	; 0x4c
 8001976:	f8c4 5164 	str.w	r5, [r4, #356]	; 0x164
}
 800197a:	bf18      	it	ne
 800197c:	2001      	movne	r0, #1
 800197e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8001980:	200014d8 	.word	0x200014d8
 8001984:	40026440 	.word	0x40026440

08001988 <MX_I2S_IN_Init>:


__weak HAL_StatusTypeDef MX_I2S_IN_Init(I2S_HandleTypeDef* hi2s, MX_I2S_IN_Config *MXConfig)
{
 8001988:	b5f0      	push	{r4, r5, r6, r7, lr}
 800198a:	e9d1 4203 	ldrd	r4, r2, [r1, #12]
 800198e:	e9d1 c701 	ldrd	ip, r7, [r1, #4]
 8001992:	e9d1 6505 	ldrd	r6, r5, [r1, #20]
 8001996:	4603      	mov	r3, r0
  hi2s->Init.DataFormat = MXConfig->DataFormat;
  hi2s->Init.AudioFreq = MXConfig->AudioFreq;
  hi2s->Init.ClockSource = MXConfig->ClockSource;
  hi2s->Init.CPOL = MXConfig->CPOL;
  hi2s->Init.MCLKOutput = MXConfig->MCLKOutput;
  hi2s->Init.Mode = MXConfig->Mode;
 8001998:	69c8      	ldr	r0, [r1, #28]
 800199a:	6809      	ldr	r1, [r1, #0]
 800199c:	615a      	str	r2, [r3, #20]
 800199e:	e9c3 7403 	strd	r7, r4, [r3, #12]
 80019a2:	e9c3 1c01 	strd	r1, ip, [r3, #4]
 80019a6:	e9c3 6506 	strd	r6, r5, [r3, #24]
{
 80019aa:	b083      	sub	sp, #12
#ifdef USE_STM32F4XX_NUCLEO
  hi2s->Init.FullDuplexMode = MXConfig->FullDuplexMode;  
#endif
  
  /* Enable the DMA clock */
  AUDIO_IN_I2S_DMAx_CLK_ENABLE();
 80019ac:	4a26      	ldr	r2, [pc, #152]	; (8001a48 <MX_I2S_IN_Init+0xc0>)
  hi2s->Init.Mode = MXConfig->Mode;
 80019ae:	6218      	str	r0, [r3, #32]
  AUDIO_IN_I2S_DMAx_CLK_ENABLE();
 80019b0:	2400      	movs	r4, #0
 80019b2:	9401      	str	r4, [sp, #4]
 80019b4:	6b11      	ldr	r1, [r2, #48]	; 0x30
  
  if(hi2s->Instance == AUDIO_IN_I2S_INSTANCE)
 80019b6:	4825      	ldr	r0, [pc, #148]	; (8001a4c <MX_I2S_IN_Init+0xc4>)
  AUDIO_IN_I2S_DMAx_CLK_ENABLE();
 80019b8:	f441 1100 	orr.w	r1, r1, #2097152	; 0x200000
 80019bc:	6311      	str	r1, [r2, #48]	; 0x30
 80019be:	6b12      	ldr	r2, [r2, #48]	; 0x30
 80019c0:	f402 1200 	and.w	r2, r2, #2097152	; 0x200000
 80019c4:	9201      	str	r2, [sp, #4]
  if(hi2s->Instance == AUDIO_IN_I2S_INSTANCE)
 80019c6:	681a      	ldr	r2, [r3, #0]
  AUDIO_IN_I2S_DMAx_CLK_ENABLE();
 80019c8:	9901      	ldr	r1, [sp, #4]
  if(hi2s->Instance == AUDIO_IN_I2S_INSTANCE)
 80019ca:	4282      	cmp	r2, r0
 80019cc:	d00b      	beq.n	80019e6 <MX_I2S_IN_Init+0x5e>
      ret = HAL_ERROR;
    }    
    /* Configure the DMA Stream */
    if (HAL_DMA_Init(&hdma_i2sRx) != HAL_OK)
    {
      ret = HAL_ERROR;
 80019ce:	2401      	movs	r4, #1
  else
  {
    ret = HAL_ERROR;
  }  
  /* I2S DMA IRQ Channel configuration */
  HAL_NVIC_SetPriority(AUDIO_IN_I2S_DMAx_IRQ, CCA02M2_AUDIO_IN_IT_PRIORITY, CCA02M2_AUDIO_IN_IT_PRIORITY);
 80019d0:	2206      	movs	r2, #6
 80019d2:	4611      	mov	r1, r2
 80019d4:	200e      	movs	r0, #14
 80019d6:	f000 fe81 	bl	80026dc <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(AUDIO_IN_I2S_DMAx_IRQ); 
 80019da:	200e      	movs	r0, #14
 80019dc:	f000 febc 	bl	8002758 <HAL_NVIC_EnableIRQ>
  
  return ret;
}
 80019e0:	4620      	mov	r0, r4
 80019e2:	b003      	add	sp, #12
 80019e4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    hdma_i2sRx.Init.Channel             = AUDIO_IN_I2S_DMAx_CHANNEL;
 80019e6:	4a1a      	ldr	r2, [pc, #104]	; (8001a50 <MX_I2S_IN_Init+0xc8>)
    hdma_i2sRx.Instance = AUDIO_IN_I2S_DMAx_STREAM;
 80019e8:	491a      	ldr	r1, [pc, #104]	; (8001a54 <MX_I2S_IN_Init+0xcc>)
 80019ea:	f8c2 118c 	str.w	r1, [r2, #396]	; 0x18c
    __HAL_LINKDMA(hi2s, hdmarx, hdma_i2sRx);    
 80019ee:	f502 75c6 	add.w	r5, r2, #396	; 0x18c
 80019f2:	63dd      	str	r5, [r3, #60]	; 0x3c
 80019f4:	f8c2 31c4 	str.w	r3, [r2, #452]	; 0x1c4
    hdma_i2sRx.Init.MemDataAlignment    = AUDIO_IN_I2S_DMAx_MEM_DATA_SIZE;
 80019f8:	f44f 6100 	mov.w	r1, #2048	; 0x800
 80019fc:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8001a00:	e9c2 1368 	strd	r1, r3, [r2, #416]	; 0x1a0
    hdma_i2sRx.Init.MemInc              = DMA_MINC_ENABLE;
 8001a04:	f44f 6080 	mov.w	r0, #1024	; 0x400
    hdma_i2sRx.Init.Priority            = DMA_PRIORITY_HIGH;
 8001a08:	f44f 7180 	mov.w	r1, #256	; 0x100
 8001a0c:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 8001a10:	e9c2 136a 	strd	r1, r3, [r2, #424]	; 0x1a8
    hdma_i2sRx.Init.MemInc              = DMA_MINC_ENABLE;
 8001a14:	f8c2 019c 	str.w	r0, [r2, #412]	; 0x19c
    hdma_i2sRx.Init.FIFOThreshold       = DMA_FIFO_THRESHOLD_FULL;
 8001a18:	2303      	movs	r3, #3
    if (HAL_DMA_DeInit(&hdma_i2sRx) != HAL_OK)
 8001a1a:	4628      	mov	r0, r5
    hdma_i2sRx.Init.Direction           = DMA_PERIPH_TO_MEMORY;
 8001a1c:	e9c2 4464 	strd	r4, r4, [r2, #400]	; 0x190
    hdma_i2sRx.Init.PeriphBurst         = DMA_MBURST_SINGLE;
 8001a20:	e9c2 446e 	strd	r4, r4, [r2, #440]	; 0x1b8
    hdma_i2sRx.Init.PeriphInc           = DMA_PINC_DISABLE;
 8001a24:	f8c2 4198 	str.w	r4, [r2, #408]	; 0x198
    hdma_i2sRx.Init.FIFOMode            = DMA_FIFOMODE_DISABLE;
 8001a28:	f8c2 41b0 	str.w	r4, [r2, #432]	; 0x1b0
    hdma_i2sRx.Init.FIFOThreshold       = DMA_FIFO_THRESHOLD_FULL;
 8001a2c:	f8c2 31b4 	str.w	r3, [r2, #436]	; 0x1b4
    if (HAL_DMA_DeInit(&hdma_i2sRx) != HAL_OK)
 8001a30:	f000 ff52 	bl	80028d8 <HAL_DMA_DeInit>
 8001a34:	4604      	mov	r4, r0
    if (HAL_DMA_Init(&hdma_i2sRx) != HAL_OK)
 8001a36:	4628      	mov	r0, r5
 8001a38:	f000 feb6 	bl	80027a8 <HAL_DMA_Init>
 8001a3c:	2800      	cmp	r0, #0
 8001a3e:	d1c6      	bne.n	80019ce <MX_I2S_IN_Init+0x46>
  HAL_StatusTypeDef ret = HAL_OK;
 8001a40:	3c00      	subs	r4, #0
 8001a42:	bf18      	it	ne
 8001a44:	2401      	movne	r4, #1
 8001a46:	e7c3      	b.n	80019d0 <MX_I2S_IN_Init+0x48>
 8001a48:	40023800 	.word	0x40023800
 8001a4c:	40003800 	.word	0x40003800
 8001a50:	200014d8 	.word	0x200014d8
 8001a54:	40026058 	.word	0x40026058

08001a58 <CCA02M2_AUDIO_IN_PDMToPCM_Init>:
* @param  ChnlNbrOut Number of desired output audio channels in the  resulting PCM buffer
* @retval BSP status
*/
__weak int32_t CCA02M2_AUDIO_IN_PDMToPCM_Init(uint32_t Instance, uint32_t AudioFreq, uint32_t ChnlNbrIn, uint32_t ChnlNbrOut)
{  
  if(Instance != 0U)
 8001a58:	2800      	cmp	r0, #0
 8001a5a:	f040 80a1 	bne.w	8001ba0 <CCA02M2_AUDIO_IN_PDMToPCM_Init+0x148>
{  
 8001a5e:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001a62:	b089      	sub	sp, #36	; 0x24
 8001a64:	4690      	mov	r8, r2
    static int16_t aState_ARM[4][DECIMATOR_STATE_LENGTH];
    static int16_t aCoeffs[] = { -1406, 1634, -1943, 2386, -3080, 4325, -7223, 21690, 21690, -7223, 4325, -3080, 2386, -1943, 1634, -1406, };
#endif
    
    /* Enable CRC peripheral to unlock the PDM library */
    __HAL_RCC_CRC_CLK_ENABLE();
 8001a66:	4a50      	ldr	r2, [pc, #320]	; (8001ba8 <CCA02M2_AUDIO_IN_PDMToPCM_Init+0x150>)
 8001a68:	9006      	str	r0, [sp, #24]
 8001a6a:	4606      	mov	r6, r0
 8001a6c:	6b10      	ldr	r0, [r2, #48]	; 0x30
 8001a6e:	f440 5080 	orr.w	r0, r0, #4096	; 0x1000
 8001a72:	6310      	str	r0, [r2, #48]	; 0x30
 8001a74:	6b12      	ldr	r2, [r2, #48]	; 0x30
 8001a76:	f402 5280 	and.w	r2, r2, #4096	; 0x1000
 8001a7a:	9206      	str	r2, [sp, #24]
 8001a7c:	9a06      	ldr	r2, [sp, #24]
    
    for(index = 0; index < ChnlNbrIn; index++)
 8001a7e:	f1b8 0f00 	cmp.w	r8, #0
 8001a82:	f000 8089 	beq.w	8001b98 <CCA02M2_AUDIO_IN_PDMToPCM_Init+0x140>
      PDM_FilterHandler[index].high_pass_tap = 2122358088;
      PDM_FilterHandler[index].out_ptr_channels = (uint16_t)ChnlNbrOut;
      PDM_FilterHandler[index].in_ptr_channels  = (uint16_t)ChnlNbrIn;
      
      /* PDM lib config phase */
      PDM_FilterConfig[index].output_samples_number = (uint16_t) ((AudioFreq/1000U) * N_MS_PER_INTERRUPT);
 8001a86:	4f49      	ldr	r7, [pc, #292]	; (8001bac <CCA02M2_AUDIO_IN_PDMToPCM_Init+0x154>)
 8001a88:	4c49      	ldr	r4, [pc, #292]	; (8001bb0 <CCA02M2_AUDIO_IN_PDMToPCM_Init+0x158>)
      PDM_FilterHandler[index].out_ptr_channels = (uint16_t)ChnlNbrOut;
 8001a8a:	fa1f f983 	uxth.w	r9, r3
      PDM_FilterConfig[index].output_samples_number = (uint16_t) ((AudioFreq/1000U) * N_MS_PER_INTERRUPT);
 8001a8e:	fba7 3701 	umull	r3, r7, r7, r1
 8001a92:	f3c7 178f 	ubfx	r7, r7, #6, #16
      case 128:
        PDM_FilterConfig[index].decimation_factor = PDM_FILTER_DEC_FACTOR_128;
        break;
      case 160:
        PDM_FilterConfig[index].decimation_factor = PDM_FILTER_DEC_FACTOR_80;
        PDM_FilterConfig[index].output_samples_number *= 2U;        
 8001a96:	007b      	lsls	r3, r7, #1
 8001a98:	b29b      	uxth	r3, r3
 8001a9a:	9304      	str	r3, [sp, #16]
        PDM_FilterHandler[index].endianness = PDM_FILTER_ENDIANNESS_BE; /* For WB this should be LE, TODO after bugfix in PDMlib */
 8001a9c:	f1a8 0301 	sub.w	r3, r8, #1
 8001aa0:	fab3 f383 	clz	r3, r3
 8001aa4:	095b      	lsrs	r3, r3, #5
 8001aa6:	9303      	str	r3, [sp, #12]
        PDM_FilterHandler[index].out_ptr_channels = 1;
        (void)arm_fir_decimate_init_q15  (&ARM_Decimator_State[index], DECIMATOR_NUM_TAPS, DECIMATOR_FACTOR,
 8001aa8:	f504 73bc 	add.w	r3, r4, #376	; 0x178
      PDM_FilterHandler[index].in_ptr_channels  = (uint16_t)ChnlNbrIn;
 8001aac:	fa1f fa88 	uxth.w	sl, r8
 8001ab0:	f504 7598 	add.w	r5, r4, #304	; 0x130
 8001ab4:	f5a4 7bf6 	sub.w	fp, r4, #492	; 0x1ec
        (void)arm_fir_decimate_init_q15  (&ARM_Decimator_State[index], DECIMATOR_NUM_TAPS, DECIMATOR_FACTOR,
 8001ab8:	9305      	str	r3, [sp, #20]
 8001aba:	e019      	b.n	8001af0 <CCA02M2_AUDIO_IN_PDMToPCM_Init+0x98>
      switch (AudioInCtx[0].DecimationFactor)
 8001abc:	2b10      	cmp	r3, #16
 8001abe:	d062      	beq.n	8001b86 <CCA02M2_AUDIO_IN_PDMToPCM_Init+0x12e>
 8001ac0:	4293      	cmp	r3, r2
 8001ac2:	d101      	bne.n	8001ac8 <CCA02M2_AUDIO_IN_PDMToPCM_Init+0x70>
        PDM_FilterConfig[index].decimation_factor = PDM_FILTER_DEC_FACTOR_24;
 8001ac4:	2306      	movs	r3, #6
 8001ac6:	802b      	strh	r3, [r5, #0]
      default:
        break;        
      }
#endif
      
      error = PDM_Filter_Init((PDM_Filter_Handler_t *)(&PDM_FilterHandler[index]));
 8001ac8:	4620      	mov	r0, r4
 8001aca:	f006 ff0f 	bl	80088ec <PDM_Filter_Init>
 8001ace:	9007      	str	r0, [sp, #28]
      if (error!=0U)
 8001ad0:	9b07      	ldr	r3, [sp, #28]
 8001ad2:	bb7b      	cbnz	r3, 8001b34 <CCA02M2_AUDIO_IN_PDMToPCM_Init+0xdc>
      {
        return  BSP_ERROR_NO_INIT;
      }      
      error = PDM_Filter_setConfig((PDM_Filter_Handler_t *)&PDM_FilterHandler[index], &PDM_FilterConfig[index]);
 8001ad4:	4629      	mov	r1, r5
 8001ad6:	4620      	mov	r0, r4
 8001ad8:	f006 ffbc 	bl	8008a54 <PDM_Filter_setConfig>
 8001adc:	9007      	str	r0, [sp, #28]
      if (error!=0U)
 8001ade:	9b07      	ldr	r3, [sp, #28]
 8001ae0:	bb43      	cbnz	r3, 8001b34 <CCA02M2_AUDIO_IN_PDMToPCM_Init+0xdc>
    for(index = 0; index < ChnlNbrIn; index++)
 8001ae2:	3601      	adds	r6, #1
 8001ae4:	45b0      	cmp	r8, r6
 8001ae6:	f104 044c 	add.w	r4, r4, #76	; 0x4c
 8001aea:	f105 0506 	add.w	r5, r5, #6
 8001aee:	d053      	beq.n	8001b98 <CCA02M2_AUDIO_IN_PDMToPCM_Init+0x140>
      volatile uint32_t error = 0;
 8001af0:	9b03      	ldr	r3, [sp, #12]
 8001af2:	8063      	strh	r3, [r4, #2]
      PDM_FilterHandler[index].high_pass_tap = 2122358088;
 8001af4:	4b2f      	ldr	r3, [pc, #188]	; (8001bb4 <CCA02M2_AUDIO_IN_PDMToPCM_Init+0x15c>)
 8001af6:	6063      	str	r3, [r4, #4]
      switch (AudioInCtx[0].DecimationFactor)
 8001af8:	f8db 3060 	ldr.w	r3, [fp, #96]	; 0x60
      PDM_FilterHandler[index].out_ptr_channels = (uint16_t)ChnlNbrOut;
 8001afc:	f8a4 900a 	strh.w	r9, [r4, #10]
      volatile uint32_t error = 0;
 8001b00:	2200      	movs	r2, #0
 8001b02:	9207      	str	r2, [sp, #28]
      PDM_FilterHandler[index].bit_order  = PDM_FILTER_BIT_ORDER_LSB;
 8001b04:	8022      	strh	r2, [r4, #0]
      switch (AudioInCtx[0].DecimationFactor)
 8001b06:	2b40      	cmp	r3, #64	; 0x40
      PDM_FilterConfig[index].mic_gain = 24;
 8001b08:	f04f 0218 	mov.w	r2, #24
      PDM_FilterHandler[index].in_ptr_channels  = (uint16_t)ChnlNbrIn;
 8001b0c:	f8a4 a008 	strh.w	sl, [r4, #8]
      PDM_FilterConfig[index].output_samples_number = (uint16_t) ((AudioFreq/1000U) * N_MS_PER_INTERRUPT);
 8001b10:	806f      	strh	r7, [r5, #2]
      PDM_FilterConfig[index].mic_gain = 24;
 8001b12:	80aa      	strh	r2, [r5, #4]
      switch (AudioInCtx[0].DecimationFactor)
 8001b14:	d03a      	beq.n	8001b8c <CCA02M2_AUDIO_IN_PDMToPCM_Init+0x134>
 8001b16:	d812      	bhi.n	8001b3e <CCA02M2_AUDIO_IN_PDMToPCM_Init+0xe6>
 8001b18:	2b20      	cmp	r3, #32
 8001b1a:	d03a      	beq.n	8001b92 <CCA02M2_AUDIO_IN_PDMToPCM_Init+0x13a>
 8001b1c:	d9ce      	bls.n	8001abc <CCA02M2_AUDIO_IN_PDMToPCM_Init+0x64>
 8001b1e:	2b30      	cmp	r3, #48	; 0x30
 8001b20:	d1d2      	bne.n	8001ac8 <CCA02M2_AUDIO_IN_PDMToPCM_Init+0x70>
        PDM_FilterConfig[index].decimation_factor = PDM_FILTER_DEC_FACTOR_48;
 8001b22:	2301      	movs	r3, #1
 8001b24:	802b      	strh	r3, [r5, #0]
      error = PDM_Filter_Init((PDM_Filter_Handler_t *)(&PDM_FilterHandler[index]));
 8001b26:	4620      	mov	r0, r4
 8001b28:	f006 fee0 	bl	80088ec <PDM_Filter_Init>
 8001b2c:	9007      	str	r0, [sp, #28]
      if (error!=0U)
 8001b2e:	9b07      	ldr	r3, [sp, #28]
 8001b30:	2b00      	cmp	r3, #0
 8001b32:	d0cf      	beq.n	8001ad4 <CCA02M2_AUDIO_IN_PDMToPCM_Init+0x7c>
        return  BSP_ERROR_NO_INIT;
 8001b34:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
      }
    }    
#endif
  } 
  return BSP_ERROR_NONE;
}
 8001b38:	b009      	add	sp, #36	; 0x24
 8001b3a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      switch (AudioInCtx[0].DecimationFactor)
 8001b3e:	2b80      	cmp	r3, #128	; 0x80
 8001b40:	d01e      	beq.n	8001b80 <CCA02M2_AUDIO_IN_PDMToPCM_Init+0x128>
 8001b42:	2ba0      	cmp	r3, #160	; 0xa0
 8001b44:	d117      	bne.n	8001b76 <CCA02M2_AUDIO_IN_PDMToPCM_Init+0x11e>
        PDM_FilterConfig[index].output_samples_number *= 2U;        
 8001b46:	9b04      	ldr	r3, [sp, #16]
        (void)arm_fir_decimate_init_q15  (&ARM_Decimator_State[index], DECIMATOR_NUM_TAPS, DECIMATOR_FACTOR,
 8001b48:	9a05      	ldr	r2, [sp, #20]
        PDM_FilterConfig[index].output_samples_number *= 2U;        
 8001b4a:	806b      	strh	r3, [r5, #2]
        (void)arm_fir_decimate_init_q15  (&ARM_Decimator_State[index], DECIMATOR_NUM_TAPS, DECIMATOR_FACTOR,
 8001b4c:	ebc6 1346 	rsb	r3, r6, r6, lsl #5
 8001b50:	eb02 0343 	add.w	r3, r2, r3, lsl #1
 8001b54:	9300      	str	r3, [sp, #0]
 8001b56:	4b18      	ldr	r3, [pc, #96]	; (8001bb8 <CCA02M2_AUDIO_IN_PDMToPCM_Init+0x160>)
 8001b58:	eb06 0046 	add.w	r0, r6, r6, lsl #1
 8001b5c:	2110      	movs	r1, #16
 8001b5e:	eb03 0080 	add.w	r0, r3, r0, lsl #2
        PDM_FilterConfig[index].decimation_factor = PDM_FILTER_DEC_FACTOR_80;
 8001b62:	2303      	movs	r3, #3
        (void)arm_fir_decimate_init_q15  (&ARM_Decimator_State[index], DECIMATOR_NUM_TAPS, DECIMATOR_FACTOR,
 8001b64:	9101      	str	r1, [sp, #4]
        PDM_FilterConfig[index].decimation_factor = PDM_FILTER_DEC_FACTOR_80;
 8001b66:	802b      	strh	r3, [r5, #0]
        PDM_FilterHandler[index].out_ptr_channels = 1;
 8001b68:	2301      	movs	r3, #1
 8001b6a:	8163      	strh	r3, [r4, #10]
        (void)arm_fir_decimate_init_q15  (&ARM_Decimator_State[index], DECIMATOR_NUM_TAPS, DECIMATOR_FACTOR,
 8001b6c:	2202      	movs	r2, #2
 8001b6e:	4b13      	ldr	r3, [pc, #76]	; (8001bbc <CCA02M2_AUDIO_IN_PDMToPCM_Init+0x164>)
 8001b70:	f007 f9e6 	bl	8008f40 <arm_fir_decimate_init_q15>
         break;
 8001b74:	e7a8      	b.n	8001ac8 <CCA02M2_AUDIO_IN_PDMToPCM_Init+0x70>
      switch (AudioInCtx[0].DecimationFactor)
 8001b76:	2b50      	cmp	r3, #80	; 0x50
 8001b78:	d1a6      	bne.n	8001ac8 <CCA02M2_AUDIO_IN_PDMToPCM_Init+0x70>
        PDM_FilterConfig[index].decimation_factor = PDM_FILTER_DEC_FACTOR_80;
 8001b7a:	2303      	movs	r3, #3
 8001b7c:	802b      	strh	r3, [r5, #0]
        break;
 8001b7e:	e7a3      	b.n	8001ac8 <CCA02M2_AUDIO_IN_PDMToPCM_Init+0x70>
        PDM_FilterConfig[index].decimation_factor = PDM_FILTER_DEC_FACTOR_128;
 8001b80:	2304      	movs	r3, #4
 8001b82:	802b      	strh	r3, [r5, #0]
        break;
 8001b84:	e7a0      	b.n	8001ac8 <CCA02M2_AUDIO_IN_PDMToPCM_Init+0x70>
        PDM_FilterConfig[index].decimation_factor = PDM_FILTER_DEC_FACTOR_16;
 8001b86:	2305      	movs	r3, #5
 8001b88:	802b      	strh	r3, [r5, #0]
        break;
 8001b8a:	e79d      	b.n	8001ac8 <CCA02M2_AUDIO_IN_PDMToPCM_Init+0x70>
        PDM_FilterConfig[index].decimation_factor = PDM_FILTER_DEC_FACTOR_64;
 8001b8c:	2302      	movs	r3, #2
 8001b8e:	802b      	strh	r3, [r5, #0]
        break;
 8001b90:	e79a      	b.n	8001ac8 <CCA02M2_AUDIO_IN_PDMToPCM_Init+0x70>
        PDM_FilterConfig[index].decimation_factor = PDM_FILTER_DEC_FACTOR_32;
 8001b92:	2307      	movs	r3, #7
 8001b94:	802b      	strh	r3, [r5, #0]
        break;
 8001b96:	e797      	b.n	8001ac8 <CCA02M2_AUDIO_IN_PDMToPCM_Init+0x70>
  return BSP_ERROR_NONE;
 8001b98:	2000      	movs	r0, #0
}
 8001b9a:	b009      	add	sp, #36	; 0x24
 8001b9c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    return  BSP_ERROR_WRONG_PARAM;
 8001ba0:	f06f 0001 	mvn.w	r0, #1
}
 8001ba4:	4770      	bx	lr
 8001ba6:	bf00      	nop
 8001ba8:	40023800 	.word	0x40023800
 8001bac:	10624dd3 	.word	0x10624dd3
 8001bb0:	200016c4 	.word	0x200016c4
 8001bb4:	7e809d48 	.word	0x7e809d48
 8001bb8:	2000180c 	.word	0x2000180c
 8001bbc:	20000058 	.word	0x20000058

08001bc0 <CCA02M2_AUDIO_IN_Init>:
  if(Instance >= AUDIO_IN_INSTANCES_NBR)
 8001bc0:	2802      	cmp	r0, #2
 8001bc2:	f200 820c 	bhi.w	8001fde <CCA02M2_AUDIO_IN_Init+0x41e>
{  
 8001bc6:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    AudioInCtx[Instance].Device          = AudioInit->Device;
 8001bca:	4dbb      	ldr	r5, [pc, #748]	; (8001eb8 <CCA02M2_AUDIO_IN_Init+0x2f8>)
 8001bcc:	680a      	ldr	r2, [r1, #0]
 8001bce:	2364      	movs	r3, #100	; 0x64
 8001bd0:	fb03 5300 	mla	r3, r3, r0, r5
 8001bd4:	4604      	mov	r4, r0
 8001bd6:	605a      	str	r2, [r3, #4]
    AudioInCtx[Instance].ChannelsNbr     = AudioInit->ChannelsNbr;  
 8001bd8:	68ca      	ldr	r2, [r1, #12]
    AudioInCtx[Instance].BitsPerSample   = AudioInit->BitsPerSample;
 8001bda:	6888      	ldr	r0, [r1, #8]
    AudioInCtx[Instance].ChannelsNbr     = AudioInit->ChannelsNbr;  
 8001bdc:	611a      	str	r2, [r3, #16]
    AudioInCtx[Instance].SampleRate      = AudioInit->SampleRate; 
 8001bde:	684a      	ldr	r2, [r1, #4]
    AudioInCtx[Instance].Volume          = AudioInit->Volume;
 8001be0:	6909      	ldr	r1, [r1, #16]
 8001be2:	6219      	str	r1, [r3, #32]
    AudioInCtx[Instance].State           = AUDIO_IN_STATE_RESET;
 8001be4:	2100      	movs	r1, #0
{  
 8001be6:	b0a0      	sub	sp, #128	; 0x80
    AudioInCtx[Instance].SampleRate      = AudioInit->SampleRate; 
 8001be8:	609a      	str	r2, [r3, #8]
    AudioInCtx[Instance].BitsPerSample   = AudioInit->BitsPerSample;
 8001bea:	60d8      	str	r0, [r3, #12]
    AudioInCtx[Instance].State           = AUDIO_IN_STATE_RESET;
 8001bec:	6259      	str	r1, [r3, #36]	; 0x24
    if(Instance == 0U)
 8001bee:	2c00      	cmp	r4, #0
 8001bf0:	f040 81a5 	bne.w	8001f3e <CCA02M2_AUDIO_IN_Init+0x37e>
      switch (AudioInit->SampleRate)
 8001bf4:	f5b2 4ffa 	cmp.w	r2, #32000	; 0x7d00
 8001bf8:	f000 81e4 	beq.w	8001fc4 <CCA02M2_AUDIO_IN_Init+0x404>
 8001bfc:	f200 81aa 	bhi.w	8001f54 <CCA02M2_AUDIO_IN_Init+0x394>
 8001c00:	f5b2 5ffa 	cmp.w	r2, #8000	; 0x1f40
 8001c04:	d003      	beq.n	8001c0e <CCA02M2_AUDIO_IN_Init+0x4e>
 8001c06:	f5b2 5f7a 	cmp.w	r2, #16000	; 0x3e80
 8001c0a:	f040 81c0 	bne.w	8001f8e <CCA02M2_AUDIO_IN_Init+0x3ce>
 8001c0e:	4bab      	ldr	r3, [pc, #684]	; (8001ebc <CCA02M2_AUDIO_IN_Init+0x2fc>)
 8001c10:	f44f 6820 	mov.w	r8, #2560	; 0xa00
 8001c14:	f649 4040 	movw	r0, #40000	; 0x9c40
 8001c18:	f44f 71a0 	mov.w	r1, #320	; 0x140
 8001c1c:	f44f 67a0 	mov.w	r7, #1280	; 0x500
      AudioInCtx[Instance].DecimationFactor = (PDM_Clock_Freq * 1000U)/AudioInit->SampleRate;
 8001c20:	fbb3 f3f2 	udiv	r3, r3, r2
 8001c24:	662b      	str	r3, [r5, #96]	; 0x60
      if(AudioInCtx[0].ChannelsNbr == 1U)
 8001c26:	692b      	ldr	r3, [r5, #16]
      AudioInCtx[Instance].Size = (PDM_Clock_Freq/8U) * 2U * N_MS_PER_INTERRUPT;
 8001c28:	61e9      	str	r1, [r5, #28]
      if(AudioInCtx[0].ChannelsNbr == 1U)
 8001c2a:	2b01      	cmp	r3, #1
 8001c2c:	f000 81b9 	beq.w	8001fa2 <CCA02M2_AUDIO_IN_Init+0x3e2>
      i2s_config.CPOL = I2S_CPOL_HIGH;
 8001c30:	f04f 0308 	mov.w	r3, #8
      i2s_config.Mode = I2S_MODE_MASTER_RX;
 8001c34:	f44f 7240 	mov.w	r2, #768	; 0x300
      i2s_config.CPOL = I2S_CPOL_HIGH;
 8001c38:	9311      	str	r3, [sp, #68]	; 0x44
      i2s_config.Mode = I2S_MODE_MASTER_RX;
 8001c3a:	f04f 0310 	mov.w	r3, #16
 8001c3e:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
      i2s_config.FullDuplexMode = I2S_FULLDUPLEXMODE_DISABLE;
 8001c42:	f04f 0600 	mov.w	r6, #0
      i2s_config.Mode = I2S_MODE_MASTER_RX;
 8001c46:	f04f 0205 	mov.w	r2, #5
 8001c4a:	f04f 0300 	mov.w	r3, #0
      i2s_config.ClockSource = I2S_CLOCK_PLL;
 8001c4e:	e9cd 6612 	strd	r6, r6, [sp, #72]	; 0x48
      i2s_config.Mode = I2S_MODE_MASTER_RX;
 8001c52:	e9cd 230e 	strd	r2, r3, [sp, #56]	; 0x38
      i2s_config.AudioFreq = ((PDM_Clock_Freq * 1000U) / 32U);
 8001c56:	9010      	str	r0, [sp, #64]	; 0x40
      if (AudioInCtx[0].ChannelsNbr>1U)
 8001c58:	f240 81bf 	bls.w	8001fda <CCA02M2_AUDIO_IN_Init+0x41a>
  static TIM_IC_InitTypeDef       sICConfig;
  static TIM_OC_InitTypeDef       sOCConfig; 
  GPIO_InitTypeDef   GPIO_InitStruct;
  
  /* Enable AUDIO_TIMER clock*/
  AUDIO_IN_TIMER_CLK_ENABLE();
 8001c5c:	4b98      	ldr	r3, [pc, #608]	; (8001ec0 <CCA02M2_AUDIO_IN_Init+0x300>)
 8001c5e:	9601      	str	r6, [sp, #4]
 8001c60:	6c1a      	ldr	r2, [r3, #64]	; 0x40
  GPIO_InitStruct.Pull = GPIO_PULLUP;
  GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
  
  GPIO_InitStruct.Alternate = AUDIO_IN_TIMER_CHIN_AF;
  GPIO_InitStruct.Pin = AUDIO_IN_TIMER_CHIN_PIN;
  HAL_GPIO_Init(AUDIO_IN_TIMER_CHIN_GPIO_PORT, &GPIO_InitStruct);
 8001c62:	4898      	ldr	r0, [pc, #608]	; (8001ec4 <CCA02M2_AUDIO_IN_Init+0x304>)
  HAL_GPIO_Init(AUDIO_IN_TIMER_CHOUT_GPIO_PORT, &GPIO_InitStruct);
  
  TimDividerHandle.Instance = AUDIO_IN_TIMER;
  
  /* Configure the Input: channel_1 */
  sICConfig.ICPolarity  = TIM_ICPOLARITY_RISING;
 8001c64:	4f98      	ldr	r7, [pc, #608]	; (8001ec8 <CCA02M2_AUDIO_IN_Init+0x308>)
  AUDIO_IN_TIMER_CLK_ENABLE();
 8001c66:	f042 0202 	orr.w	r2, r2, #2
 8001c6a:	641a      	str	r2, [r3, #64]	; 0x40
 8001c6c:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8001c6e:	f002 0202 	and.w	r2, r2, #2
 8001c72:	9201      	str	r2, [sp, #4]
 8001c74:	9a01      	ldr	r2, [sp, #4]
  AUDIO_IN_TIMER_CHOUT_GPIO_PORT_CLK_ENABLE();
 8001c76:	9602      	str	r6, [sp, #8]
 8001c78:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8001c7a:	f042 0202 	orr.w	r2, r2, #2
 8001c7e:	631a      	str	r2, [r3, #48]	; 0x30
 8001c80:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8001c82:	f002 0202 	and.w	r2, r2, #2
 8001c86:	9202      	str	r2, [sp, #8]
 8001c88:	9a02      	ldr	r2, [sp, #8]
  AUDIO_IN_TIMER_CHIN_GPIO_PORT_CLK_ENABLE();
 8001c8a:	9603      	str	r6, [sp, #12]
 8001c8c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8001c8e:	f042 0202 	orr.w	r2, r2, #2
 8001c92:	631a      	str	r2, [r3, #48]	; 0x30
 8001c94:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8001c96:	f003 0302 	and.w	r3, r3, #2
 8001c9a:	9303      	str	r3, [sp, #12]
 8001c9c:	9b03      	ldr	r3, [sp, #12]
  GPIO_InitStruct.Pin = AUDIO_IN_TIMER_CHIN_PIN;
 8001c9e:	2210      	movs	r2, #16
 8001ca0:	2302      	movs	r3, #2
 8001ca2:	e9cd 2314 	strd	r2, r3, [sp, #80]	; 0x50
  GPIO_InitStruct.Alternate = AUDIO_IN_TIMER_CHIN_AF;
 8001ca6:	f04f 0902 	mov.w	r9, #2
  GPIO_InitStruct.Pin = AUDIO_IN_TIMER_CHIN_PIN;
 8001caa:	2201      	movs	r2, #1
 8001cac:	2303      	movs	r3, #3
  HAL_GPIO_Init(AUDIO_IN_TIMER_CHIN_GPIO_PORT, &GPIO_InitStruct);
 8001cae:	a914      	add	r1, sp, #80	; 0x50
  GPIO_InitStruct.Pin = AUDIO_IN_TIMER_CHIN_PIN;
 8001cb0:	e9cd 2316 	strd	r2, r3, [sp, #88]	; 0x58
  GPIO_InitStruct.Alternate = AUDIO_IN_TIMER_CHIN_AF;
 8001cb4:	f8cd 9060 	str.w	r9, [sp, #96]	; 0x60
  HAL_GPIO_Init(AUDIO_IN_TIMER_CHIN_GPIO_PORT, &GPIO_InitStruct);
 8001cb8:	f000 ff80 	bl	8002bbc <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = AUDIO_IN_TIMER_CHOUT_PIN;
 8001cbc:	2320      	movs	r3, #32
  HAL_GPIO_Init(AUDIO_IN_TIMER_CHOUT_GPIO_PORT, &GPIO_InitStruct);
 8001cbe:	4881      	ldr	r0, [pc, #516]	; (8001ec4 <CCA02M2_AUDIO_IN_Init+0x304>)
  GPIO_InitStruct.Alternate = AUDIO_IN_TIMER_CHOUT_AF;
 8001cc0:	f8cd 9060 	str.w	r9, [sp, #96]	; 0x60
  HAL_GPIO_Init(AUDIO_IN_TIMER_CHOUT_GPIO_PORT, &GPIO_InitStruct);
 8001cc4:	a914      	add	r1, sp, #80	; 0x50
  GPIO_InitStruct.Pin = AUDIO_IN_TIMER_CHOUT_PIN;
 8001cc6:	9314      	str	r3, [sp, #80]	; 0x50
  HAL_GPIO_Init(AUDIO_IN_TIMER_CHOUT_GPIO_PORT, &GPIO_InitStruct);
 8001cc8:	f000 ff78 	bl	8002bbc <HAL_GPIO_Init>
  sICConfig.ICPolarity  = TIM_ICPOLARITY_RISING;
 8001ccc:	ed9f 7b76 	vldr	d7, [pc, #472]	; 8001ea8 <CCA02M2_AUDIO_IN_Init+0x2e8>
 8001cd0:	ed87 7b00 	vstr	d7, [r7]
 8001cd4:	ed9f 7b76 	vldr	d7, [pc, #472]	; 8001eb0 <CCA02M2_AUDIO_IN_Init+0x2f0>
 8001cd8:	f1a7 0a54 	sub.w	sl, r7, #84	; 0x54
  TimDividerHandle.Instance = AUDIO_IN_TIMER;
 8001cdc:	4b7b      	ldr	r3, [pc, #492]	; (8001ecc <CCA02M2_AUDIO_IN_Init+0x30c>)
 8001cde:	f8c5 345c 	str.w	r3, [r5, #1116]	; 0x45c
  sICConfig.ICPolarity  = TIM_ICPOLARITY_RISING;
 8001ce2:	ed07 7b02 	vstr	d7, [r7, #-8]
  sICConfig.ICSelection = TIM_ICSELECTION_DIRECTTI;
  sICConfig.ICPrescaler = TIM_ICPSC_DIV1;
  sICConfig.ICFilter = 0;
  if(HAL_TIM_IC_ConfigChannel(&TimDividerHandle, &sICConfig, TIM_CHANNEL_1) != HAL_OK)
 8001ce6:	4632      	mov	r2, r6
 8001ce8:	f1a7 0108 	sub.w	r1, r7, #8
 8001cec:	4650      	mov	r0, sl
 8001cee:	f002 fb75 	bl	80043dc <HAL_TIM_IC_ConfigChannel>
  }
  
  /* Configure TIM1 in Gated Slave mode for the external trigger (Filtered Timer
  Input 1) */
  sSlaveConfig.InputTrigger = TIM_TS_TI1FP1;
  sSlaveConfig.SlaveMode    = TIM_SLAVEMODE_EXTERNAL1;
 8001cf2:	2350      	movs	r3, #80	; 0x50
 8001cf4:	2207      	movs	r2, #7
  if(HAL_TIM_IC_ConfigChannel(&TimDividerHandle, &sICConfig, TIM_CHANNEL_1) != HAL_OK)
 8001cf6:	4681      	mov	r9, r0
  sSlaveConfig.SlaveMode    = TIM_SLAVEMODE_EXTERNAL1;
 8001cf8:	e9c7 2302 	strd	r2, r3, [r7, #8]
  if( HAL_TIM_SlaveConfigSynchronization(&TimDividerHandle, &sSlaveConfig) != HAL_OK)
 8001cfc:	f107 0108 	add.w	r1, r7, #8
 8001d00:	4650      	mov	r0, sl
 8001d02:	f002 fd47 	bl	8004794 <HAL_TIM_SlaveConfigSynchro>
 8001d06:	ea49 0000 	orr.w	r0, r9, r0
 8001d0a:	fa5f f980 	uxtb.w	r9, r0
  {
    ret =  HAL_ERROR;
 8001d0e:	ebb9 0906 	subs.w	r9, r9, r6
  }
  
  /* Initialize TIM3 peripheral in PWM mode*/
  TimDividerHandle.Init.Period            = 1;
 8001d12:	f04f 0301 	mov.w	r3, #1
  TimDividerHandle.Init.Prescaler         = 0;
  TimDividerHandle.Init.ClockDivision     = 0;
  TimDividerHandle.Init.CounterMode       = TIM_COUNTERMODE_UP;
  TimDividerHandle.Init.RepetitionCounter = 0;
  if(HAL_TIM_PWM_Init(&TimDividerHandle) != HAL_OK)
 8001d16:	4650      	mov	r0, sl
    ret =  HAL_ERROR;
 8001d18:	bf18      	it	ne
 8001d1a:	f04f 0901 	movne.w	r9, #1
  TimDividerHandle.Init.Prescaler         = 0;
 8001d1e:	f8c5 6460 	str.w	r6, [r5, #1120]	; 0x460
  TimDividerHandle.Init.ClockDivision     = 0;
 8001d22:	f8c5 646c 	str.w	r6, [r5, #1132]	; 0x46c
  TimDividerHandle.Init.CounterMode       = TIM_COUNTERMODE_UP;
 8001d26:	f8c5 6464 	str.w	r6, [r5, #1124]	; 0x464
  TimDividerHandle.Init.RepetitionCounter = 0;
 8001d2a:	f8c5 6470 	str.w	r6, [r5, #1136]	; 0x470
  TimDividerHandle.Init.Period            = 1;
 8001d2e:	f8c5 3468 	str.w	r3, [r5, #1128]	; 0x468
  if(HAL_TIM_PWM_Init(&TimDividerHandle) != HAL_OK)
 8001d32:	f002 fa63 	bl	80041fc <HAL_TIM_PWM_Init>
 8001d36:	2800      	cmp	r0, #0
 8001d38:	f040 8119 	bne.w	8001f6e <CCA02M2_AUDIO_IN_Init+0x3ae>
  {
    ret =  HAL_ERROR;
  }
  
  /* Configure the PWM_channel_1  */
  sOCConfig.OCMode     = TIM_OCMODE_PWM1;
 8001d3c:	4639      	mov	r1, r7
 8001d3e:	2660      	movs	r6, #96	; 0x60
 8001d40:	2701      	movs	r7, #1
  sOCConfig.OCPolarity = TIM_OCPOLARITY_HIGH;
 8001d42:	f8c5 04d8 	str.w	r0, [r5, #1240]	; 0x4d8
  sOCConfig.OCMode     = TIM_OCMODE_PWM1;
 8001d46:	e9e1 6708 	strd	r6, r7, [r1, #32]!
  sOCConfig.Pulse = 1;
  if(HAL_TIM_PWM_ConfigChannel(&TimDividerHandle, &sOCConfig, TIM_CHANNEL_2) != HAL_OK)
 8001d4a:	4650      	mov	r0, sl
 8001d4c:	2204      	movs	r2, #4
 8001d4e:	f002 fc1b 	bl	8004588 <HAL_TIM_PWM_ConfigChannel>
 8001d52:	2800      	cmp	r0, #0
 8001d54:	f040 8116 	bne.w	8001f84 <CCA02M2_AUDIO_IN_Init+0x3c4>
        if (AUDIO_IN_Timer_Init() != HAL_OK)
 8001d58:	f1b9 0f00 	cmp.w	r9, #0
 8001d5c:	f040 8112 	bne.w	8001f84 <CCA02M2_AUDIO_IN_Init+0x3c4>
      if(MX_I2S_IN_ClockConfig(&hAudioInI2s, PDM_Clock_Freq) != HAL_OK)
 8001d60:	485b      	ldr	r0, [pc, #364]	; (8001ed0 <CCA02M2_AUDIO_IN_Init+0x310>)
 8001d62:	4641      	mov	r1, r8
 8001d64:	f7ff fd9c 	bl	80018a0 <MX_I2S_IN_ClockConfig>
 8001d68:	2800      	cmp	r0, #0
 8001d6a:	f040 8115 	bne.w	8001f98 <CCA02M2_AUDIO_IN_Init+0x3d8>
      hAudioInI2s.Instance          = AUDIO_IN_I2S_INSTANCE;
 8001d6e:	4b59      	ldr	r3, [pc, #356]	; (8001ed4 <CCA02M2_AUDIO_IN_Init+0x314>)
  AUDIO_IN_I2S_CLK_ENABLE();  
 8001d70:	4e53      	ldr	r6, [pc, #332]	; (8001ec0 <CCA02M2_AUDIO_IN_Init+0x300>)
      __HAL_I2S_DISABLE(&hAudioInI2s);
 8001d72:	69da      	ldr	r2, [r3, #28]
      hAudioInI2s.Instance          = AUDIO_IN_I2S_INSTANCE;
 8001d74:	f8c5 34ec 	str.w	r3, [r5, #1260]	; 0x4ec
      __HAL_I2S_DISABLE(&hAudioInI2s);
 8001d78:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8001d7c:	61da      	str	r2, [r3, #28]
  AUDIO_IN_I2S_CLK_ENABLE();  
 8001d7e:	9004      	str	r0, [sp, #16]
 8001d80:	6c33      	ldr	r3, [r6, #64]	; 0x40
 8001d82:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8001d86:	6433      	str	r3, [r6, #64]	; 0x40
 8001d88:	6c33      	ldr	r3, [r6, #64]	; 0x40
 8001d8a:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8001d8e:	9304      	str	r3, [sp, #16]
 8001d90:	9b04      	ldr	r3, [sp, #16]
  AUDIO_IN_I2S_SCK_GPIO_CLK_ENABLE();
 8001d92:	9005      	str	r0, [sp, #20]
 8001d94:	6b33      	ldr	r3, [r6, #48]	; 0x30
 8001d96:	f043 0302 	orr.w	r3, r3, #2
 8001d9a:	6333      	str	r3, [r6, #48]	; 0x30
 8001d9c:	6b33      	ldr	r3, [r6, #48]	; 0x30
 8001d9e:	f003 0302 	and.w	r3, r3, #2
 8001da2:	9305      	str	r3, [sp, #20]
 8001da4:	9b05      	ldr	r3, [sp, #20]
  AUDIO_IN_I2S_MOSI_GPIO_CLK_ENABLE();
 8001da6:	9006      	str	r0, [sp, #24]
 8001da8:	6b33      	ldr	r3, [r6, #48]	; 0x30
 8001daa:	f043 0302 	orr.w	r3, r3, #2
 8001dae:	6333      	str	r3, [r6, #48]	; 0x30
 8001db0:	6b33      	ldr	r3, [r6, #48]	; 0x30
  HAL_GPIO_Init(AUDIO_IN_I2S_SCK_GPIO_PORT, &GPIO_InitStruct);
 8001db2:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
  AUDIO_IN_I2S_MOSI_GPIO_CLK_ENABLE();
 8001db6:	f003 0302 	and.w	r3, r3, #2
 8001dba:	9306      	str	r3, [sp, #24]
  GPIO_InitStruct.Pin       = AUDIO_IN_I2S_SCK_PIN;
 8001dbc:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8001dc0:	2302      	movs	r3, #2
  HAL_GPIO_Init(AUDIO_IN_I2S_SCK_GPIO_PORT, &GPIO_InitStruct);
 8001dc2:	f500 3001 	add.w	r0, r0, #132096	; 0x20400
  GPIO_InitStruct.Alternate = AUDIO_IN_I2S_SCK_AF;
 8001dc6:	2705      	movs	r7, #5
  HAL_GPIO_Init(AUDIO_IN_I2S_SCK_GPIO_PORT, &GPIO_InitStruct);
 8001dc8:	a914      	add	r1, sp, #80	; 0x50
  GPIO_InitStruct.Pin       = AUDIO_IN_I2S_SCK_PIN;
 8001dca:	f04f 0801 	mov.w	r8, #1
 8001dce:	f04f 0902 	mov.w	r9, #2
 8001dd2:	e9cd 2314 	strd	r2, r3, [sp, #80]	; 0x50
 8001dd6:	e9cd 8916 	strd	r8, r9, [sp, #88]	; 0x58
  AUDIO_IN_I2S_MOSI_GPIO_CLK_ENABLE();
 8001dda:	9b06      	ldr	r3, [sp, #24]
  GPIO_InitStruct.Alternate = AUDIO_IN_I2S_SCK_AF;
 8001ddc:	9718      	str	r7, [sp, #96]	; 0x60
  HAL_GPIO_Init(AUDIO_IN_I2S_SCK_GPIO_PORT, &GPIO_InitStruct);
 8001dde:	f000 feed 	bl	8002bbc <HAL_GPIO_Init>
  HAL_GPIO_Init(AUDIO_IN_I2S_MOSI_GPIO_PORT, &GPIO_InitStruct);
 8001de2:	4838      	ldr	r0, [pc, #224]	; (8001ec4 <CCA02M2_AUDIO_IN_Init+0x304>)
  GPIO_InitStruct.Alternate = AUDIO_IN_I2S_MOSI_AF;
 8001de4:	9718      	str	r7, [sp, #96]	; 0x60
  HAL_GPIO_Init(AUDIO_IN_I2S_MOSI_GPIO_PORT, &GPIO_InitStruct);
 8001de6:	a914      	add	r1, sp, #80	; 0x50
  GPIO_InitStruct.Pin       = AUDIO_IN_I2S_MOSI_PIN ;
 8001de8:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8001dec:	9314      	str	r3, [sp, #80]	; 0x50
  HAL_GPIO_Init(AUDIO_IN_I2S_MOSI_GPIO_PORT, &GPIO_InitStruct);
 8001dee:	f000 fee5 	bl	8002bbc <HAL_GPIO_Init>
      if (MX_I2S_IN_Init(&hAudioInI2s, &i2s_config)!= HAL_OK)
 8001df2:	4837      	ldr	r0, [pc, #220]	; (8001ed0 <CCA02M2_AUDIO_IN_Init+0x310>)
 8001df4:	a90c      	add	r1, sp, #48	; 0x30
 8001df6:	f7ff fdc7 	bl	8001988 <MX_I2S_IN_Init>
 8001dfa:	2800      	cmp	r0, #0
 8001dfc:	f040 80c2 	bne.w	8001f84 <CCA02M2_AUDIO_IN_Init+0x3c4>
      if (HAL_I2S_Init(&hAudioInI2s) != HAL_OK)
 8001e00:	4833      	ldr	r0, [pc, #204]	; (8001ed0 <CCA02M2_AUDIO_IN_Init+0x310>)
 8001e02:	f000 ffcf 	bl	8002da4 <HAL_I2S_Init>
 8001e06:	2800      	cmp	r0, #0
 8001e08:	f040 80bc 	bne.w	8001f84 <CCA02M2_AUDIO_IN_Init+0x3c4>
      if (AudioInCtx[0].ChannelsNbr>2U)
 8001e0c:	692b      	ldr	r3, [r5, #16]
 8001e0e:	2b02      	cmp	r3, #2
 8001e10:	f240 808c 	bls.w	8001f2c <CCA02M2_AUDIO_IN_Init+0x36c>
        hAudioInSPI.Instance = AUDIO_IN_SPI_INSTANCE;
 8001e14:	4b30      	ldr	r3, [pc, #192]	; (8001ed8 <CCA02M2_AUDIO_IN_Init+0x318>)
 8001e16:	f8c5 3534 	str.w	r3, [r5, #1332]	; 0x534
        __HAL_SPI_DISABLE(&hAudioInSPI);
 8001e1a:	681a      	ldr	r2, [r3, #0]
 8001e1c:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8001e20:	601a      	str	r2, [r3, #0]
  AUDIO_IN_SPI_SCK_GPIO_CLK_ENABLE();
 8001e22:	9007      	str	r0, [sp, #28]
 8001e24:	6b33      	ldr	r3, [r6, #48]	; 0x30
 8001e26:	f043 0301 	orr.w	r3, r3, #1
 8001e2a:	6333      	str	r3, [r6, #48]	; 0x30
 8001e2c:	6b33      	ldr	r3, [r6, #48]	; 0x30
 8001e2e:	f003 0301 	and.w	r3, r3, #1
 8001e32:	9307      	str	r3, [sp, #28]
 8001e34:	9b07      	ldr	r3, [sp, #28]
  AUDIO_IN_SPI_MISO_GPIO_CLK_ENABLE();
 8001e36:	9008      	str	r0, [sp, #32]
 8001e38:	6b33      	ldr	r3, [r6, #48]	; 0x30
 8001e3a:	f043 0301 	orr.w	r3, r3, #1
 8001e3e:	6333      	str	r3, [r6, #48]	; 0x30
 8001e40:	6b33      	ldr	r3, [r6, #48]	; 0x30
 8001e42:	f003 0301 	and.w	r3, r3, #1
 8001e46:	9308      	str	r3, [sp, #32]
 8001e48:	9b08      	ldr	r3, [sp, #32]
  AUDIO_IN_SPI_MOSI_GPIO_CLK_ENABLE();
 8001e4a:	9009      	str	r0, [sp, #36]	; 0x24
 8001e4c:	6b33      	ldr	r3, [r6, #48]	; 0x30
 8001e4e:	f043 0301 	orr.w	r3, r3, #1
 8001e52:	6333      	str	r3, [r6, #48]	; 0x30
 8001e54:	6b33      	ldr	r3, [r6, #48]	; 0x30
 8001e56:	f003 0301 	and.w	r3, r3, #1
 8001e5a:	9309      	str	r3, [sp, #36]	; 0x24
 8001e5c:	9b09      	ldr	r3, [sp, #36]	; 0x24
  AUDIO_IN_SPI_CLK_ENABLE();
 8001e5e:	900a      	str	r0, [sp, #40]	; 0x28
 8001e60:	6c73      	ldr	r3, [r6, #68]	; 0x44
 8001e62:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8001e66:	6473      	str	r3, [r6, #68]	; 0x44
 8001e68:	6c73      	ldr	r3, [r6, #68]	; 0x44
 8001e6a:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8001e6e:	930a      	str	r3, [sp, #40]	; 0x28
 8001e70:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  AUDIO_IN_SPI_DMAx_CLK_ENABLE();
 8001e72:	900b      	str	r0, [sp, #44]	; 0x2c
 8001e74:	6b33      	ldr	r3, [r6, #48]	; 0x30
  HAL_GPIO_Init(AUDIO_IN_SPI_SCK_GPIO_PORT, &GPIO_InitStruct);
 8001e76:	4819      	ldr	r0, [pc, #100]	; (8001edc <CCA02M2_AUDIO_IN_Init+0x31c>)
  AUDIO_IN_SPI_DMAx_CLK_ENABLE();
 8001e78:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 8001e7c:	6333      	str	r3, [r6, #48]	; 0x30
 8001e7e:	6b33      	ldr	r3, [r6, #48]	; 0x30
        if (MX_SPI_Init(&hAudioInSPI, &spi_config)!= HAL_OK)
 8001e80:	4e17      	ldr	r6, [pc, #92]	; (8001ee0 <CCA02M2_AUDIO_IN_Init+0x320>)
  AUDIO_IN_SPI_DMAx_CLK_ENABLE();
 8001e82:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8001e86:	930b      	str	r3, [sp, #44]	; 0x2c
 8001e88:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
  GPIO_InitStruct.Alternate = AUDIO_IN_SPI_SCK_AF;  
 8001e8a:	9718      	str	r7, [sp, #96]	; 0x60
  GPIO_InitStruct.Pin       = AUDIO_IN_SPI_SCK_PIN;
 8001e8c:	2220      	movs	r2, #32
 8001e8e:	2302      	movs	r3, #2
  HAL_GPIO_Init(AUDIO_IN_SPI_SCK_GPIO_PORT, &GPIO_InitStruct);
 8001e90:	a914      	add	r1, sp, #80	; 0x50
  GPIO_InitStruct.Pin       = AUDIO_IN_SPI_SCK_PIN;
 8001e92:	e9cd 2314 	strd	r2, r3, [sp, #80]	; 0x50
 8001e96:	e9cd 8916 	strd	r8, r9, [sp, #88]	; 0x58
  HAL_GPIO_Init(AUDIO_IN_SPI_SCK_GPIO_PORT, &GPIO_InitStruct);
 8001e9a:	f000 fe8f 	bl	8002bbc <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = AUDIO_IN_SPI_MOSI_PIN;
 8001e9e:	2380      	movs	r3, #128	; 0x80
  HAL_GPIO_Init(AUDIO_IN_SPI_MOSI_GPIO_PORT, &GPIO_InitStruct);
 8001ea0:	480e      	ldr	r0, [pc, #56]	; (8001edc <CCA02M2_AUDIO_IN_Init+0x31c>)
  GPIO_InitStruct.Pin = AUDIO_IN_SPI_MOSI_PIN;
 8001ea2:	9314      	str	r3, [sp, #80]	; 0x50
  HAL_GPIO_Init(AUDIO_IN_SPI_MOSI_GPIO_PORT, &GPIO_InitStruct);
 8001ea4:	a914      	add	r1, sp, #80	; 0x50
 8001ea6:	e01d      	b.n	8001ee4 <CCA02M2_AUDIO_IN_Init+0x324>
	...
 8001eb4:	00000001 	.word	0x00000001
 8001eb8:	200014d8 	.word	0x200014d8
 8001ebc:	00138800 	.word	0x00138800
 8001ec0:	40023800 	.word	0x40023800
 8001ec4:	40020400 	.word	0x40020400
 8001ec8:	20001988 	.word	0x20001988
 8001ecc:	40000400 	.word	0x40000400
 8001ed0:	200019c4 	.word	0x200019c4
 8001ed4:	40003800 	.word	0x40003800
 8001ed8:	40013000 	.word	0x40013000
 8001edc:	40020000 	.word	0x40020000
 8001ee0:	20001a0c 	.word	0x20001a0c
  GPIO_InitStruct.Alternate = AUDIO_IN_SPI_MOSI_AF;
 8001ee4:	9718      	str	r7, [sp, #96]	; 0x60
  HAL_GPIO_Init(AUDIO_IN_SPI_MOSI_GPIO_PORT, &GPIO_InitStruct);
 8001ee6:	f000 fe69 	bl	8002bbc <HAL_GPIO_Init>
        spi_config.CRCPolynomial = 7;
 8001eea:	2307      	movs	r3, #7
        spi_config.Mode = SPI_MODE_SLAVE;
 8001eec:	2200      	movs	r2, #0
        spi_config.CRCPolynomial = 7;
 8001eee:	931e      	str	r3, [sp, #120]	; 0x78
        spi_config.Mode = SPI_MODE_SLAVE;
 8001ef0:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8001ef4:	e9cd 2314 	strd	r2, r3, [sp, #80]	; 0x50
 8001ef8:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8001efc:	2302      	movs	r3, #2
 8001efe:	e9cd 2316 	strd	r2, r3, [sp, #88]	; 0x58
 8001f02:	2201      	movs	r2, #1
 8001f04:	f44f 7300 	mov.w	r3, #512	; 0x200
 8001f08:	e9cd 2318 	strd	r2, r3, [sp, #96]	; 0x60
        if (MX_SPI_Init(&hAudioInSPI, &spi_config)!= HAL_OK)
 8001f0c:	a914      	add	r1, sp, #80	; 0x50
        spi_config.Mode = SPI_MODE_SLAVE;
 8001f0e:	2200      	movs	r2, #0
 8001f10:	2300      	movs	r3, #0
        if (MX_SPI_Init(&hAudioInSPI, &spi_config)!= HAL_OK)
 8001f12:	4630      	mov	r0, r6
        spi_config.Mode = SPI_MODE_SLAVE;
 8001f14:	e9cd 231a 	strd	r2, r3, [sp, #104]	; 0x68
 8001f18:	e9cd 231c 	strd	r2, r3, [sp, #112]	; 0x70
        if (MX_SPI_Init(&hAudioInSPI, &spi_config)!= HAL_OK)
 8001f1c:	f7ff fce4 	bl	80018e8 <MX_SPI_Init>
 8001f20:	bb80      	cbnz	r0, 8001f84 <CCA02M2_AUDIO_IN_Init+0x3c4>
        if (HAL_SPI_Init(&hAudioInSPI) != HAL_OK)
 8001f22:	4630      	mov	r0, r6
 8001f24:	f001 fe76 	bl	8003c14 <HAL_SPI_Init>
 8001f28:	bb60      	cbnz	r0, 8001f84 <CCA02M2_AUDIO_IN_Init+0x3c4>
      if (CCA02M2_AUDIO_IN_PDMToPCM_Init(Instance, AudioInCtx[0].SampleRate, AudioInCtx[0].ChannelsNbr, AudioInCtx[0].ChannelsNbr)!= BSP_ERROR_NONE)
 8001f2a:	692b      	ldr	r3, [r5, #16]
 8001f2c:	68a9      	ldr	r1, [r5, #8]
 8001f2e:	461a      	mov	r2, r3
 8001f30:	2000      	movs	r0, #0
 8001f32:	f7ff fd91 	bl	8001a58 <CCA02M2_AUDIO_IN_PDMToPCM_Init>
 8001f36:	b120      	cbz	r0, 8001f42 <CCA02M2_AUDIO_IN_Init+0x382>
        return  BSP_ERROR_NO_INIT;
 8001f38:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8001f3c:	e007      	b.n	8001f4e <CCA02M2_AUDIO_IN_Init+0x38e>
    else if(Instance == 1U)
 8001f3e:	2c01      	cmp	r4, #1
 8001f40:	d025      	beq.n	8001f8e <CCA02M2_AUDIO_IN_Init+0x3ce>
    AudioInCtx[Instance].State = AUDIO_IN_STATE_STOP; 
 8001f42:	2064      	movs	r0, #100	; 0x64
 8001f44:	fb00 5404 	mla	r4, r0, r4, r5
 8001f48:	2302      	movs	r3, #2
 8001f4a:	6263      	str	r3, [r4, #36]	; 0x24
  return BSP_ERROR_NONE;
 8001f4c:	2000      	movs	r0, #0
}
 8001f4e:	b020      	add	sp, #128	; 0x80
 8001f50:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      switch (AudioInit->SampleRate)
 8001f54:	f64b 3380 	movw	r3, #48000	; 0xbb80
 8001f58:	429a      	cmp	r2, r3
 8001f5a:	d118      	bne.n	8001f8e <CCA02M2_AUDIO_IN_Init+0x3ce>
 8001f5c:	4821      	ldr	r0, [pc, #132]	; (8001fe4 <CCA02M2_AUDIO_IN_Init+0x424>)
 8001f5e:	4b22      	ldr	r3, [pc, #136]	; (8001fe8 <CCA02M2_AUDIO_IN_Init+0x428>)
 8001f60:	f44f 58c0 	mov.w	r8, #6144	; 0x1800
 8001f64:	f44f 7140 	mov.w	r1, #768	; 0x300
        PDM_Clock_Freq = 3072;
 8001f68:	f44f 6740 	mov.w	r7, #3072	; 0xc00
 8001f6c:	e658      	b.n	8001c20 <CCA02M2_AUDIO_IN_Init+0x60>
  sOCConfig.OCMode     = TIM_OCMODE_PWM1;
 8001f6e:	4639      	mov	r1, r7
  sOCConfig.OCPolarity = TIM_OCPOLARITY_HIGH;
 8001f70:	f8c5 64d8 	str.w	r6, [r5, #1240]	; 0x4d8
  sOCConfig.OCMode     = TIM_OCMODE_PWM1;
 8001f74:	2460      	movs	r4, #96	; 0x60
 8001f76:	2501      	movs	r5, #1
 8001f78:	e9e1 4508 	strd	r4, r5, [r1, #32]!
  if(HAL_TIM_PWM_ConfigChannel(&TimDividerHandle, &sOCConfig, TIM_CHANNEL_2) != HAL_OK)
 8001f7c:	2204      	movs	r2, #4
 8001f7e:	4650      	mov	r0, sl
 8001f80:	f002 fb02 	bl	8004588 <HAL_TIM_PWM_ConfigChannel>
          return  BSP_ERROR_PERIPH_FAILURE;
 8001f84:	f06f 0003 	mvn.w	r0, #3
}
 8001f88:	b020      	add	sp, #128	; 0x80
 8001f8a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      switch (AudioInit->SampleRate)
 8001f8e:	f06f 0001 	mvn.w	r0, #1
}
 8001f92:	b020      	add	sp, #128	; 0x80
 8001f94:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        return  BSP_ERROR_CLOCK_FAILURE;
 8001f98:	f06f 0008 	mvn.w	r0, #8
}
 8001f9c:	b020      	add	sp, #128	; 0x80
 8001f9e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      i2s_config.CPOL = I2S_CPOL_HIGH;
 8001fa2:	2308      	movs	r3, #8
      i2s_config.Mode = I2S_MODE_MASTER_RX;
 8001fa4:	f44f 7240 	mov.w	r2, #768	; 0x300
      i2s_config.CPOL = I2S_CPOL_HIGH;
 8001fa8:	e9cd 0310 	strd	r0, r3, [sp, #64]	; 0x40
      i2s_config.Mode = I2S_MODE_MASTER_RX;
 8001fac:	2310      	movs	r3, #16
 8001fae:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
 8001fb2:	2300      	movs	r3, #0
 8001fb4:	2200      	movs	r2, #0
 8001fb6:	e9cd 230e 	strd	r2, r3, [sp, #56]	; 0x38
      i2s_config.FullDuplexMode = I2S_FULLDUPLEXMODE_DISABLE;
 8001fba:	2300      	movs	r3, #0
      i2s_config.ClockSource = I2S_CLOCK_PLL;
 8001fbc:	e9cd 3312 	strd	r3, r3, [sp, #72]	; 0x48
 8001fc0:	46b8      	mov	r8, r7
 8001fc2:	e6cd      	b.n	8001d60 <CCA02M2_AUDIO_IN_Init+0x1a0>
      switch (AudioInit->SampleRate)
 8001fc4:	f44f 5880 	mov.w	r8, #4096	; 0x1000
 8001fc8:	f44f 407a 	mov.w	r0, #64000	; 0xfa00
 8001fcc:	f44f 7100 	mov.w	r1, #512	; 0x200
 8001fd0:	f44f 13fa 	mov.w	r3, #2048000	; 0x1f4000
        PDM_Clock_Freq = 2048;
 8001fd4:	f44f 6700 	mov.w	r7, #2048	; 0x800
 8001fd8:	e622      	b.n	8001c20 <CCA02M2_AUDIO_IN_Init+0x60>
 8001fda:	46b8      	mov	r8, r7
 8001fdc:	e6c0      	b.n	8001d60 <CCA02M2_AUDIO_IN_Init+0x1a0>
    return BSP_ERROR_WRONG_PARAM;  
 8001fde:	f06f 0001 	mvn.w	r0, #1
}
 8001fe2:	4770      	bx	lr
 8001fe4:	00017700 	.word	0x00017700
 8001fe8:	002ee000 	.word	0x002ee000

08001fec <CCA02M2_AUDIO_IN_PDMToPCM>:
  if(Instance != 0U)
 8001fec:	2800      	cmp	r0, #0
 8001fee:	d174      	bne.n	80020da <CCA02M2_AUDIO_IN_PDMToPCM+0xee>
{    
 8001ff0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    for(index = 0; index < AudioInCtx[Instance].ChannelsNbr; index++)
 8001ff4:	4e3a      	ldr	r6, [pc, #232]	; (80020e0 <CCA02M2_AUDIO_IN_PDMToPCM+0xf4>)
 8001ff6:	6933      	ldr	r3, [r6, #16]
{    
 8001ff8:	b08f      	sub	sp, #60	; 0x3c
    for(index = 0; index < AudioInCtx[Instance].ChannelsNbr; index++)
 8001ffa:	b373      	cbz	r3, 800205a <CCA02M2_AUDIO_IN_PDMToPCM+0x6e>
 8001ffc:	4693      	mov	fp, r2
 8001ffe:	4604      	mov	r4, r0
 8002000:	460d      	mov	r5, r1
 8002002:	f506 77f6 	add.w	r7, r6, #492	; 0x1ec
 8002006:	f506 794d 	add.w	r9, r6, #820	; 0x334
 800200a:	4690      	mov	r8, r2
 800200c:	e00c      	b.n	8002028 <CCA02M2_AUDIO_IN_PDMToPCM+0x3c>
        switch(AudioInCtx[Instance].BitsPerSample)
 800200e:	2a10      	cmp	r2, #16
 8002010:	d013      	beq.n	800203a <CCA02M2_AUDIO_IN_PDMToPCM+0x4e>
    for(index = 0; index < AudioInCtx[Instance].ChannelsNbr; index++)
 8002012:	3401      	adds	r4, #1
 8002014:	42a3      	cmp	r3, r4
 8002016:	f105 0501 	add.w	r5, r5, #1
 800201a:	f107 074c 	add.w	r7, r7, #76	; 0x4c
 800201e:	f109 090c 	add.w	r9, r9, #12
 8002022:	f108 0802 	add.w	r8, r8, #2
 8002026:	d918      	bls.n	800205a <CCA02M2_AUDIO_IN_PDMToPCM+0x6e>
      if (AudioInCtx[Instance].SampleRate == 8000U)
 8002028:	68b2      	ldr	r2, [r6, #8]
 800202a:	f5b2 5ffa 	cmp.w	r2, #8000	; 0x1f40
 800202e:	d018      	beq.n	8002062 <CCA02M2_AUDIO_IN_PDMToPCM+0x76>
        switch(AudioInCtx[Instance].BitsPerSample)
 8002030:	68f2      	ldr	r2, [r6, #12]
 8002032:	2a18      	cmp	r2, #24
 8002034:	d008      	beq.n	8002048 <CCA02M2_AUDIO_IN_PDMToPCM+0x5c>
 8002036:	2a20      	cmp	r2, #32
 8002038:	d1e9      	bne.n	800200e <CCA02M2_AUDIO_IN_PDMToPCM+0x22>
          (void)PDM_Filter(&((uint8_t*)(PDMBuf))[index], (uint32_t*)&(PCMBuf[index]), &PDM_FilterHandler[index]);          
 800203a:	463a      	mov	r2, r7
 800203c:	4641      	mov	r1, r8
 800203e:	4628      	mov	r0, r5
 8002040:	f006 fe04 	bl	8008c4c <PDM_Filter>
    for(index = 0; index < AudioInCtx[Instance].ChannelsNbr; index++)
 8002044:	6933      	ldr	r3, [r6, #16]
          break;
 8002046:	e7e4      	b.n	8002012 <CCA02M2_AUDIO_IN_PDMToPCM+0x26>
          (void)PDM_Filter(&((uint8_t*)(PDMBuf))[index], &((uint8_t*)(PCMBuf))[3U*index], &PDM_FilterHandler[index]);          
 8002048:	eb04 0144 	add.w	r1, r4, r4, lsl #1
 800204c:	4459      	add	r1, fp
 800204e:	463a      	mov	r2, r7
 8002050:	4628      	mov	r0, r5
 8002052:	f006 fdfb 	bl	8008c4c <PDM_Filter>
    for(index = 0; index < AudioInCtx[Instance].ChannelsNbr; index++)
 8002056:	6933      	ldr	r3, [r6, #16]
          break;
 8002058:	e7db      	b.n	8002012 <CCA02M2_AUDIO_IN_PDMToPCM+0x26>
  return BSP_ERROR_NONE;
 800205a:	2000      	movs	r0, #0
}
 800205c:	b00f      	add	sp, #60	; 0x3c
 800205e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        (void)PDM_Filter(&((uint8_t*)(PDMBuf))[index], PDM_Filter_Out, &PDM_FilterHandler[index]);
 8002062:	463a      	mov	r2, r7
 8002064:	a906      	add	r1, sp, #24
 8002066:	4628      	mov	r0, r5
 8002068:	f006 fdf0 	bl	8008c4c <PDM_Filter>
        (void)arm_fir_decimate_q15 (&ARM_Decimator_State[index], (q15_t *)&(PDM_Filter_Out), (q15_t*)&(Decimate_Out), DECIMATOR_BLOCK_SIZE);
 800206c:	2310      	movs	r3, #16
 800206e:	aa02      	add	r2, sp, #8
 8002070:	a906      	add	r1, sp, #24
 8002072:	4648      	mov	r0, r9
 8002074:	f006 fdf8 	bl	8008c68 <arm_fir_decimate_q15>
          PCMBuf[(ii * AudioInCtx[Instance].ChannelsNbr) + index] = Decimate_Out[ii];
 8002078:	6933      	ldr	r3, [r6, #16]
 800207a:	f8bd 2008 	ldrh.w	r2, [sp, #8]
 800207e:	f8a8 2000 	strh.w	r2, [r8]
 8002082:	eb03 0a04 	add.w	sl, r3, r4
 8002086:	eb03 0e0a 	add.w	lr, r3, sl
 800208a:	eb03 0c0e 	add.w	ip, r3, lr
 800208e:	eb03 000c 	add.w	r0, r3, ip
 8002092:	181a      	adds	r2, r3, r0
 8002094:	9200      	str	r2, [sp, #0]
 8002096:	189a      	adds	r2, r3, r2
 8002098:	1899      	adds	r1, r3, r2
 800209a:	9101      	str	r1, [sp, #4]
 800209c:	f8bd 100a 	ldrh.w	r1, [sp, #10]
 80020a0:	f82b 101a 	strh.w	r1, [fp, sl, lsl #1]
 80020a4:	f8bd a00c 	ldrh.w	sl, [sp, #12]
 80020a8:	f82b a01e 	strh.w	sl, [fp, lr, lsl #1]
 80020ac:	f8bd e00e 	ldrh.w	lr, [sp, #14]
 80020b0:	f82b e01c 	strh.w	lr, [fp, ip, lsl #1]
 80020b4:	9900      	ldr	r1, [sp, #0]
 80020b6:	f8bd c010 	ldrh.w	ip, [sp, #16]
 80020ba:	f82b c010 	strh.w	ip, [fp, r0, lsl #1]
 80020be:	f8bd 0012 	ldrh.w	r0, [sp, #18]
 80020c2:	f82b 0011 	strh.w	r0, [fp, r1, lsl #1]
 80020c6:	f8bd 1014 	ldrh.w	r1, [sp, #20]
 80020ca:	f82b 1012 	strh.w	r1, [fp, r2, lsl #1]
 80020ce:	9901      	ldr	r1, [sp, #4]
 80020d0:	f8bd 2016 	ldrh.w	r2, [sp, #22]
 80020d4:	f82b 2011 	strh.w	r2, [fp, r1, lsl #1]
        for (ii=0; ii<(8U*N_MS_PER_INTERRUPT); ii++)
 80020d8:	e79b      	b.n	8002012 <CCA02M2_AUDIO_IN_PDMToPCM+0x26>
    return  BSP_ERROR_WRONG_PARAM;
 80020da:	f06f 0001 	mvn.w	r0, #1
}
 80020de:	4770      	bx	lr
 80020e0:	200014d8 	.word	0x200014d8

080020e4 <CCA02M2_AUDIO_IN_Record>:
  if(Instance >= (AUDIO_IN_INSTANCES_NBR - 1U) )
 80020e4:	2801      	cmp	r0, #1
 80020e6:	d837      	bhi.n	8002158 <CCA02M2_AUDIO_IN_Record+0x74>
{  
 80020e8:	b510      	push	{r4, lr}
    AudioInCtx[Instance].pBuff = (uint16_t*)pBuf;
 80020ea:	4c1d      	ldr	r4, [pc, #116]	; (8002160 <CCA02M2_AUDIO_IN_Record+0x7c>)
 80020ec:	2364      	movs	r3, #100	; 0x64
 80020ee:	fb03 4300 	mla	r3, r3, r0, r4
 80020f2:	6159      	str	r1, [r3, #20]
    if(Instance == 0U)
 80020f4:	bb68      	cbnz	r0, 8002152 <CCA02M2_AUDIO_IN_Record+0x6e>
      if(AudioInCtx[Instance].ChannelsNbr > 2U)
 80020f6:	6923      	ldr	r3, [r4, #16]
 80020f8:	2b02      	cmp	r3, #2
 80020fa:	d81f      	bhi.n	800213c <CCA02M2_AUDIO_IN_Record+0x58>
      if(AudioInCtx[Instance].ChannelsNbr != 1U)
 80020fc:	2b01      	cmp	r3, #1
 80020fe:	d011      	beq.n	8002124 <CCA02M2_AUDIO_IN_Record+0x40>
* @retval None
*/
static HAL_StatusTypeDef AUDIO_IN_Timer_Start(void)
{  
  HAL_StatusTypeDef ret =  HAL_OK;
  if(HAL_TIM_IC_Start(&TimDividerHandle, TIM_CHANNEL_1) != HAL_OK)
 8002100:	4818      	ldr	r0, [pc, #96]	; (8002164 <CCA02M2_AUDIO_IN_Record+0x80>)
 8002102:	2100      	movs	r1, #0
 8002104:	f002 f8f8 	bl	80042f8 <HAL_TIM_IC_Start>
 8002108:	b130      	cbz	r0, 8002118 <CCA02M2_AUDIO_IN_Record+0x34>
  {
    ret =  HAL_ERROR;
  }
  /* Start the Output Compare */
  if(HAL_TIM_OC_Start(&TimDividerHandle, TIM_CHANNEL_2) != HAL_OK)
 800210a:	4816      	ldr	r0, [pc, #88]	; (8002164 <CCA02M2_AUDIO_IN_Record+0x80>)
 800210c:	2104      	movs	r1, #4
 800210e:	f002 f80d 	bl	800412c <HAL_TIM_OC_Start>
          return BSP_ERROR_PERIPH_FAILURE;
 8002112:	f06f 0003 	mvn.w	r0, #3
}
 8002116:	bd10      	pop	{r4, pc}
  if(HAL_TIM_OC_Start(&TimDividerHandle, TIM_CHANNEL_2) != HAL_OK)
 8002118:	4812      	ldr	r0, [pc, #72]	; (8002164 <CCA02M2_AUDIO_IN_Record+0x80>)
 800211a:	2104      	movs	r1, #4
 800211c:	f002 f806 	bl	800412c <HAL_TIM_OC_Start>
 8002120:	2800      	cmp	r0, #0
 8002122:	d1f6      	bne.n	8002112 <CCA02M2_AUDIO_IN_Record+0x2e>
      if(HAL_I2S_Receive_DMA(&hAudioInI2s, I2S_InternalBuffer, (uint16_t)AudioInCtx[Instance].Size/2U) != HAL_OK)
 8002124:	8ba2      	ldrh	r2, [r4, #28]
 8002126:	4910      	ldr	r1, [pc, #64]	; (8002168 <CCA02M2_AUDIO_IN_Record+0x84>)
 8002128:	0852      	lsrs	r2, r2, #1
 800212a:	f5a1 60d4 	sub.w	r0, r1, #1696	; 0x6a0
 800212e:	f000 fed5 	bl	8002edc <HAL_I2S_Receive_DMA>
 8002132:	2800      	cmp	r0, #0
 8002134:	d1ed      	bne.n	8002112 <CCA02M2_AUDIO_IN_Record+0x2e>
      AudioInCtx[Instance].State = AUDIO_IN_STATE_RECORDING;           
 8002136:	2301      	movs	r3, #1
 8002138:	6263      	str	r3, [r4, #36]	; 0x24
}
 800213a:	bd10      	pop	{r4, pc}
        if(HAL_SPI_Receive_DMA(&hAudioInSPI, (uint8_t *)SPI_InternalBuffer, (uint16_t)AudioInCtx[Instance].Size) != HAL_OK)
 800213c:	8ba2      	ldrh	r2, [r4, #28]
 800213e:	f204 518c 	addw	r1, r4, #1420	; 0x58c
 8002142:	f204 5034 	addw	r0, r4, #1332	; 0x534
 8002146:	f001 fe4d 	bl	8003de4 <HAL_SPI_Receive_DMA>
 800214a:	2800      	cmp	r0, #0
 800214c:	d1e1      	bne.n	8002112 <CCA02M2_AUDIO_IN_Record+0x2e>
      if(AudioInCtx[Instance].ChannelsNbr != 1U)
 800214e:	6923      	ldr	r3, [r4, #16]
 8002150:	e7d4      	b.n	80020fc <CCA02M2_AUDIO_IN_Record+0x18>
    return BSP_ERROR_WRONG_PARAM;
 8002152:	f06f 0001 	mvn.w	r0, #1
}
 8002156:	bd10      	pop	{r4, pc}
    return BSP_ERROR_WRONG_PARAM;
 8002158:	f06f 0001 	mvn.w	r0, #1
}
 800215c:	4770      	bx	lr
 800215e:	bf00      	nop
 8002160:	200014d8 	.word	0x200014d8
 8002164:	20001934 	.word	0x20001934
 8002168:	20002064 	.word	0x20002064

0800216c <CCA02M2_AUDIO_IN_SetVolume>:
  if(Instance >= AUDIO_IN_INSTANCES_NBR)
 800216c:	2802      	cmp	r0, #2
 800216e:	d849      	bhi.n	8002204 <CCA02M2_AUDIO_IN_SetVolume+0x98>
{
 8002170:	b538      	push	{r3, r4, r5, lr}
  else if (Instance == 0U)
 8002172:	bb30      	cbnz	r0, 80021c2 <CCA02M2_AUDIO_IN_SetVolume+0x56>
    for (index = 0; index < AudioInCtx[Instance].ChannelsNbr; index++)
 8002174:	4c25      	ldr	r4, [pc, #148]	; (800220c <CCA02M2_AUDIO_IN_SetVolume+0xa0>)
 8002176:	6923      	ldr	r3, [r4, #16]
 8002178:	b30b      	cbz	r3, 80021be <CCA02M2_AUDIO_IN_SetVolume+0x52>
      if (PDM_FilterConfig[index].mic_gain != VolumeGain[Volume])
 800217a:	4825      	ldr	r0, [pc, #148]	; (8002210 <CCA02M2_AUDIO_IN_SetVolume+0xa4>)
 800217c:	f9b4 2320 	ldrsh.w	r2, [r4, #800]	; 0x320
 8002180:	f930 5011 	ldrsh.w	r5, [r0, r1, lsl #1]
 8002184:	42aa      	cmp	r2, r5
 8002186:	d008      	beq.n	800219a <CCA02M2_AUDIO_IN_SetVolume+0x2e>
        (void)PDM_Filter_setConfig((PDM_Filter_Handler_t *)&PDM_FilterHandler[index], &PDM_FilterConfig[index]);
 8002188:	f504 7147 	add.w	r1, r4, #796	; 0x31c
 800218c:	f504 70f6 	add.w	r0, r4, #492	; 0x1ec
        PDM_FilterConfig[index].mic_gain = VolumeGain[Volume];
 8002190:	f8a4 5320 	strh.w	r5, [r4, #800]	; 0x320
        (void)PDM_Filter_setConfig((PDM_Filter_Handler_t *)&PDM_FilterHandler[index], &PDM_FilterConfig[index]);
 8002194:	f006 fc5e 	bl	8008a54 <PDM_Filter_setConfig>
    for (index = 0; index < AudioInCtx[Instance].ChannelsNbr; index++)
 8002198:	6923      	ldr	r3, [r4, #16]
 800219a:	2b01      	cmp	r3, #1
 800219c:	d90f      	bls.n	80021be <CCA02M2_AUDIO_IN_SetVolume+0x52>
      if (PDM_FilterConfig[index].mic_gain != VolumeGain[Volume])
 800219e:	f9b4 2326 	ldrsh.w	r2, [r4, #806]	; 0x326
 80021a2:	42aa      	cmp	r2, r5
 80021a4:	d114      	bne.n	80021d0 <CCA02M2_AUDIO_IN_SetVolume+0x64>
    for (index = 0; index < AudioInCtx[Instance].ChannelsNbr; index++)
 80021a6:	2b02      	cmp	r3, #2
 80021a8:	d909      	bls.n	80021be <CCA02M2_AUDIO_IN_SetVolume+0x52>
      if (PDM_FilterConfig[index].mic_gain != VolumeGain[Volume])
 80021aa:	f9b4 232c 	ldrsh.w	r2, [r4, #812]	; 0x32c
 80021ae:	42aa      	cmp	r2, r5
 80021b0:	d117      	bne.n	80021e2 <CCA02M2_AUDIO_IN_SetVolume+0x76>
    for (index = 0; index < AudioInCtx[Instance].ChannelsNbr; index++)
 80021b2:	2b03      	cmp	r3, #3
 80021b4:	d903      	bls.n	80021be <CCA02M2_AUDIO_IN_SetVolume+0x52>
      if (PDM_FilterConfig[index].mic_gain != VolumeGain[Volume])
 80021b6:	f9b4 3332 	ldrsh.w	r3, [r4, #818]	; 0x332
 80021ba:	42ab      	cmp	r3, r5
 80021bc:	d11a      	bne.n	80021f4 <CCA02M2_AUDIO_IN_SetVolume+0x88>
  return BSP_ERROR_NONE;  
 80021be:	2000      	movs	r0, #0
}
 80021c0:	bd38      	pop	{r3, r4, r5, pc}
    AudioInCtx[Instance].Volume = Volume;
 80021c2:	4b12      	ldr	r3, [pc, #72]	; (800220c <CCA02M2_AUDIO_IN_SetVolume+0xa0>)
 80021c4:	2264      	movs	r2, #100	; 0x64
 80021c6:	fb02 3300 	mla	r3, r2, r0, r3
  return BSP_ERROR_NONE;  
 80021ca:	2000      	movs	r0, #0
    AudioInCtx[Instance].Volume = Volume;
 80021cc:	6219      	str	r1, [r3, #32]
}
 80021ce:	bd38      	pop	{r3, r4, r5, pc}
        (void)PDM_Filter_setConfig((PDM_Filter_Handler_t *)&PDM_FilterHandler[index], &PDM_FilterConfig[index]);
 80021d0:	4910      	ldr	r1, [pc, #64]	; (8002214 <CCA02M2_AUDIO_IN_SetVolume+0xa8>)
        PDM_FilterConfig[index].mic_gain = VolumeGain[Volume];
 80021d2:	f8a4 5326 	strh.w	r5, [r4, #806]	; 0x326
        (void)PDM_Filter_setConfig((PDM_Filter_Handler_t *)&PDM_FilterHandler[index], &PDM_FilterConfig[index]);
 80021d6:	f1a1 00ea 	sub.w	r0, r1, #234	; 0xea
 80021da:	f006 fc3b 	bl	8008a54 <PDM_Filter_setConfig>
    for (index = 0; index < AudioInCtx[Instance].ChannelsNbr; index++)
 80021de:	6923      	ldr	r3, [r4, #16]
 80021e0:	e7e1      	b.n	80021a6 <CCA02M2_AUDIO_IN_SetVolume+0x3a>
        (void)PDM_Filter_setConfig((PDM_Filter_Handler_t *)&PDM_FilterHandler[index], &PDM_FilterConfig[index]);
 80021e2:	490d      	ldr	r1, [pc, #52]	; (8002218 <CCA02M2_AUDIO_IN_SetVolume+0xac>)
        PDM_FilterConfig[index].mic_gain = VolumeGain[Volume];
 80021e4:	f8a4 532c 	strh.w	r5, [r4, #812]	; 0x32c
        (void)PDM_Filter_setConfig((PDM_Filter_Handler_t *)&PDM_FilterHandler[index], &PDM_FilterConfig[index]);
 80021e8:	f1a1 00a4 	sub.w	r0, r1, #164	; 0xa4
 80021ec:	f006 fc32 	bl	8008a54 <PDM_Filter_setConfig>
    for (index = 0; index < AudioInCtx[Instance].ChannelsNbr; index++)
 80021f0:	6923      	ldr	r3, [r4, #16]
 80021f2:	e7de      	b.n	80021b2 <CCA02M2_AUDIO_IN_SetVolume+0x46>
        (void)PDM_Filter_setConfig((PDM_Filter_Handler_t *)&PDM_FilterHandler[index], &PDM_FilterConfig[index]);
 80021f4:	4909      	ldr	r1, [pc, #36]	; (800221c <CCA02M2_AUDIO_IN_SetVolume+0xb0>)
        PDM_FilterConfig[index].mic_gain = VolumeGain[Volume];
 80021f6:	f8a4 5332 	strh.w	r5, [r4, #818]	; 0x332
        (void)PDM_Filter_setConfig((PDM_Filter_Handler_t *)&PDM_FilterHandler[index], &PDM_FilterConfig[index]);
 80021fa:	f1a1 005e 	sub.w	r0, r1, #94	; 0x5e
 80021fe:	f006 fc29 	bl	8008a54 <PDM_Filter_setConfig>
    for (index = 0; index < AudioInCtx[Instance].ChannelsNbr; index++)
 8002202:	e7dc      	b.n	80021be <CCA02M2_AUDIO_IN_SetVolume+0x52>
    return BSP_ERROR_WRONG_PARAM;
 8002204:	f06f 0001 	mvn.w	r0, #1
}
 8002208:	4770      	bx	lr
 800220a:	bf00      	nop
 800220c:	200014d8 	.word	0x200014d8
 8002210:	08009ab8 	.word	0x08009ab8
 8002214:	200017fa 	.word	0x200017fa
 8002218:	20001800 	.word	0x20001800
 800221c:	20001806 	.word	0x20001806

08002220 <HAL_I2S_RxCpltCallback>:
  switch(AudioInCtx[0].ChannelsNbr)
 8002220:	4a6e      	ldr	r2, [pc, #440]	; (80023dc <HAL_I2S_RxCpltCallback+0x1bc>)
{
 8002222:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  switch(AudioInCtx[0].ChannelsNbr)
 8002226:	6913      	ldr	r3, [r2, #16]
 8002228:	2b02      	cmp	r3, #2
 800222a:	d008      	beq.n	800223e <HAL_I2S_RxCpltCallback+0x1e>
 800222c:	2b04      	cmp	r3, #4
 800222e:	d067      	beq.n	8002300 <HAL_I2S_RxCpltCallback+0xe0>
 8002230:	2b01      	cmp	r3, #1
 8002232:	d03d      	beq.n	80022b0 <HAL_I2S_RxCpltCallback+0x90>
  CCA02M2_AUDIO_IN_TransferComplete_CallBack(0);
 8002234:	2000      	movs	r0, #0
 8002236:	f7ff f8a7 	bl	8001388 <CCA02M2_AUDIO_IN_TransferComplete_CallBack>
}
 800223a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      uint16_t * DataTempI2S = &(I2S_InternalBuffer[AudioInCtx[0].Size/2U]);
 800223e:	69d3      	ldr	r3, [r2, #28]
 8002240:	f602 378c 	addw	r7, r2, #2956	; 0xb8c
 8002244:	f023 0101 	bic.w	r1, r3, #1
      for(index=0; index<(AudioInCtx[0].Size/2U); index++) 
 8002248:	085b      	lsrs	r3, r3, #1
      uint16_t * DataTempI2S = &(I2S_InternalBuffer[AudioInCtx[0].Size/2U]);
 800224a:	440f      	add	r7, r1
      for(index=0; index<(AudioInCtx[0].Size/2U); index++) 
 800224c:	d0f2      	beq.n	8002234 <HAL_I2S_RxCpltCallback+0x14>
 800224e:	4b64      	ldr	r3, [pc, #400]	; (80023e0 <HAL_I2S_RxCpltCallback+0x1c0>)
 8002250:	2601      	movs	r6, #1
 8002252:	2500      	movs	r5, #0
        a = ((uint8_t *)(DataTempI2S))[(index*2U)];
 8002254:	f817 1015 	ldrb.w	r1, [r7, r5, lsl #1]
        b = ((uint8_t *)(DataTempI2S))[(index*2U)+1U];
 8002258:	5db8      	ldrb	r0, [r7, r6]
        ((uint8_t *)(AudioInCtx[0].pBuff))[(index*2U)] = Channel_Demux[a & CHANNEL_DEMUX_MASK] | (Channel_Demux[b & CHANNEL_DEMUX_MASK] << 4);;
 800225a:	f001 0455 	and.w	r4, r1, #85	; 0x55
 800225e:	f000 0c55 	and.w	ip, r0, #85	; 0x55
 8002262:	449c      	add	ip, r3
 8002264:	441c      	add	r4, r3
 8002266:	f89c e104 	ldrb.w	lr, [ip, #260]	; 0x104
 800226a:	f894 c104 	ldrb.w	ip, [r4, #260]	; 0x104
 800226e:	6954      	ldr	r4, [r2, #20]
        ((uint8_t *)(AudioInCtx[0].pBuff))[(index*2U)+1U] = Channel_Demux[(a>>1) & CHANNEL_DEMUX_MASK] | (Channel_Demux[(b>>1) & CHANNEL_DEMUX_MASK] << 4);
 8002270:	0840      	lsrs	r0, r0, #1
 8002272:	0849      	lsrs	r1, r1, #1
 8002274:	f000 0055 	and.w	r0, r0, #85	; 0x55
 8002278:	f001 0155 	and.w	r1, r1, #85	; 0x55
 800227c:	4418      	add	r0, r3
        ((uint8_t *)(AudioInCtx[0].pBuff))[(index*2U)] = Channel_Demux[a & CHANNEL_DEMUX_MASK] | (Channel_Demux[b & CHANNEL_DEMUX_MASK] << 4);;
 800227e:	ea4c 1c0e 	orr.w	ip, ip, lr, lsl #4
        ((uint8_t *)(AudioInCtx[0].pBuff))[(index*2U)+1U] = Channel_Demux[(a>>1) & CHANNEL_DEMUX_MASK] | (Channel_Demux[(b>>1) & CHANNEL_DEMUX_MASK] << 4);
 8002282:	4419      	add	r1, r3
        ((uint8_t *)(AudioInCtx[0].pBuff))[(index*2U)] = Channel_Demux[a & CHANNEL_DEMUX_MASK] | (Channel_Demux[b & CHANNEL_DEMUX_MASK] << 4);;
 8002284:	f804 c015 	strb.w	ip, [r4, r5, lsl #1]
        ((uint8_t *)(AudioInCtx[0].pBuff))[(index*2U)+1U] = Channel_Demux[(a>>1) & CHANNEL_DEMUX_MASK] | (Channel_Demux[(b>>1) & CHANNEL_DEMUX_MASK] << 4);
 8002288:	f891 1104 	ldrb.w	r1, [r1, #260]	; 0x104
 800228c:	f890 4104 	ldrb.w	r4, [r0, #260]	; 0x104
 8002290:	6950      	ldr	r0, [r2, #20]
 8002292:	ea41 1104 	orr.w	r1, r1, r4, lsl #4
 8002296:	5581      	strb	r1, [r0, r6]
      for(index=0; index<(AudioInCtx[0].Size/2U); index++) 
 8002298:	69d1      	ldr	r1, [r2, #28]
 800229a:	3501      	adds	r5, #1
 800229c:	ebb5 0f51 	cmp.w	r5, r1, lsr #1
 80022a0:	f106 0602 	add.w	r6, r6, #2
 80022a4:	d3d6      	bcc.n	8002254 <HAL_I2S_RxCpltCallback+0x34>
  CCA02M2_AUDIO_IN_TransferComplete_CallBack(0);
 80022a6:	2000      	movs	r0, #0
 80022a8:	f7ff f86e 	bl	8001388 <CCA02M2_AUDIO_IN_TransferComplete_CallBack>
}
 80022ac:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      uint16_t * DataTempI2S = &I2S_InternalBuffer[AudioInCtx[0].Size/4U] ;
 80022b0:	69d3      	ldr	r3, [r2, #28]
 80022b2:	f602 308c 	addw	r0, r2, #2956	; 0xb8c
 80022b6:	089e      	lsrs	r6, r3, #2
 80022b8:	0074      	lsls	r4, r6, #1
 80022ba:	eb00 0546 	add.w	r5, r0, r6, lsl #1
      for(index = 0; index < (AudioInCtx[0].Size/4U); index++)
 80022be:	2e00      	cmp	r6, #0
 80022c0:	d0b8      	beq.n	8002234 <HAL_I2S_RxCpltCallback+0x14>
        AudioInCtx[0].pBuff[index] = (DataTempI2S[index]);
 80022c2:	6951      	ldr	r1, [r2, #20]
 80022c4:	1ca2      	adds	r2, r4, #2
 80022c6:	4410      	add	r0, r2
 80022c8:	4281      	cmp	r1, r0
 80022ca:	d07c      	beq.n	80023c6 <HAL_I2S_RxCpltCallback+0x1a6>
 80022cc:	1e72      	subs	r2, r6, #1
 80022ce:	2a09      	cmp	r2, #9
 80022d0:	d979      	bls.n	80023c6 <HAL_I2S_RxCpltCallback+0x1a6>
 80022d2:	08da      	lsrs	r2, r3, #3
 80022d4:	4628      	mov	r0, r5
 80022d6:	460b      	mov	r3, r1
 80022d8:	eb01 0782 	add.w	r7, r1, r2, lsl #2
 80022dc:	f850 4b04 	ldr.w	r4, [r0], #4
 80022e0:	f843 4b04 	str.w	r4, [r3], #4
      for(index = 0; index < (AudioInCtx[0].Size/4U); index++)
 80022e4:	429f      	cmp	r7, r3
 80022e6:	d1f9      	bne.n	80022dc <HAL_I2S_RxCpltCallback+0xbc>
 80022e8:	ebb6 0f42 	cmp.w	r6, r2, lsl #1
 80022ec:	d0a2      	beq.n	8002234 <HAL_I2S_RxCpltCallback+0x14>
        AudioInCtx[0].pBuff[index] = (DataTempI2S[index]);
 80022ee:	f835 3022 	ldrh.w	r3, [r5, r2, lsl #2]
 80022f2:	f821 3022 	strh.w	r3, [r1, r2, lsl #2]
  CCA02M2_AUDIO_IN_TransferComplete_CallBack(0);
 80022f6:	2000      	movs	r0, #0
 80022f8:	f7ff f846 	bl	8001388 <CCA02M2_AUDIO_IN_TransferComplete_CallBack>
}
 80022fc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      uint16_t * DataTempI2S = &(I2S_InternalBuffer[AudioInCtx[0].Size/2U]);
 8002300:	69d3      	ldr	r3, [r2, #28]
 8002302:	f602 348c 	addw	r4, r2, #2956	; 0xb8c
 8002306:	f023 0101 	bic.w	r1, r3, #1
      uint16_t * DataTempSPI = &(SPI_InternalBuffer[AudioInCtx[0].Size/2U]);
 800230a:	f202 5e8c 	addw	lr, r2, #1420	; 0x58c
      for(index=0; index<(AudioInCtx[0].Size/2U); index++) 
 800230e:	085b      	lsrs	r3, r3, #1
      uint16_t * DataTempI2S = &(I2S_InternalBuffer[AudioInCtx[0].Size/2U]);
 8002310:	440c      	add	r4, r1
      uint16_t * DataTempSPI = &(SPI_InternalBuffer[AudioInCtx[0].Size/2U]);
 8002312:	448e      	add	lr, r1
      for(index=0; index<(AudioInCtx[0].Size/2U); index++) 
 8002314:	d08e      	beq.n	8002234 <HAL_I2S_RxCpltCallback+0x14>
 8002316:	f04f 0c00 	mov.w	ip, #0
 800231a:	4b31      	ldr	r3, [pc, #196]	; (80023e0 <HAL_I2S_RxCpltCallback+0x1c0>)
 800231c:	4660      	mov	r0, ip
 800231e:	1c66      	adds	r6, r4, #1
 8002320:	f10e 0501 	add.w	r5, lr, #1
        a = ((uint8_t *)(DataTempI2S))[(index*2U)];
 8002324:	f814 7010 	ldrb.w	r7, [r4, r0, lsl #1]
        b = ((uint8_t *)(DataTempI2S))[(index*2U)+1U];
 8002328:	f816 1010 	ldrb.w	r1, [r6, r0, lsl #1]
        ((uint8_t *)(AudioInCtx[0].pBuff))[(index*4U)] = Channel_Demux[a & CHANNEL_DEMUX_MASK] |
 800232c:	f007 0855 	and.w	r8, r7, #85	; 0x55
          (Channel_Demux[b & CHANNEL_DEMUX_MASK] << 4);;
 8002330:	f001 0955 	and.w	r9, r1, #85	; 0x55
          ((uint8_t *)(AudioInCtx[0].pBuff))[(index*4U)+1U] = Channel_Demux[(a>>1) & CHANNEL_DEMUX_MASK] |
 8002334:	087f      	lsrs	r7, r7, #1
            (Channel_Demux[(b>>1) & CHANNEL_DEMUX_MASK] << 4);
 8002336:	0849      	lsrs	r1, r1, #1
          ((uint8_t *)(AudioInCtx[0].pBuff))[(index*4U)+1U] = Channel_Demux[(a>>1) & CHANNEL_DEMUX_MASK] |
 8002338:	f007 0755 	and.w	r7, r7, #85	; 0x55
            (Channel_Demux[(b>>1) & CHANNEL_DEMUX_MASK] << 4);
 800233c:	f001 0155 	and.w	r1, r1, #85	; 0x55
          ((uint8_t *)(AudioInCtx[0].pBuff))[(index*4U)+1U] = Channel_Demux[(a>>1) & CHANNEL_DEMUX_MASK] |
 8002340:	441f      	add	r7, r3
            (Channel_Demux[(b>>1) & CHANNEL_DEMUX_MASK] << 4);
 8002342:	4419      	add	r1, r3
        ((uint8_t *)(AudioInCtx[0].pBuff))[(index*4U)] = Channel_Demux[a & CHANNEL_DEMUX_MASK] |
 8002344:	4498      	add	r8, r3
          (Channel_Demux[b & CHANNEL_DEMUX_MASK] << 4);;
 8002346:	4499      	add	r9, r3
            (Channel_Demux[(b>>1) & CHANNEL_DEMUX_MASK] << 4);
 8002348:	f891 1104 	ldrb.w	r1, [r1, #260]	; 0x104
          ((uint8_t *)(AudioInCtx[0].pBuff))[(index*4U)+1U] = Channel_Demux[(a>>1) & CHANNEL_DEMUX_MASK] |
 800234c:	f897 7104 	ldrb.w	r7, [r7, #260]	; 0x104
          (Channel_Demux[b & CHANNEL_DEMUX_MASK] << 4);;
 8002350:	f899 9104 	ldrb.w	r9, [r9, #260]	; 0x104
        ((uint8_t *)(AudioInCtx[0].pBuff))[(index*4U)] = Channel_Demux[a & CHANNEL_DEMUX_MASK] |
 8002354:	f898 8104 	ldrb.w	r8, [r8, #260]	; 0x104
          ((uint8_t *)(AudioInCtx[0].pBuff))[(index*4U)+1U] = Channel_Demux[(a>>1) & CHANNEL_DEMUX_MASK] |
 8002358:	ea47 1701 	orr.w	r7, r7, r1, lsl #4
        ((uint8_t *)(AudioInCtx[0].pBuff))[(index*4U)] = Channel_Demux[a & CHANNEL_DEMUX_MASK] |
 800235c:	6951      	ldr	r1, [r2, #20]
 800235e:	ea48 1809 	orr.w	r8, r8, r9, lsl #4
 8002362:	f801 800c 	strb.w	r8, [r1, ip]
          ((uint8_t *)(AudioInCtx[0].pBuff))[(index*4U)+1U] = Channel_Demux[(a>>1) & CHANNEL_DEMUX_MASK] |
 8002366:	6951      	ldr	r1, [r2, #20]
 8002368:	4461      	add	r1, ip
 800236a:	704f      	strb	r7, [r1, #1]
            a = ((uint8_t *)(DataTempSPI))[(index*2U)];
 800236c:	f81e 1010 	ldrb.w	r1, [lr, r0, lsl #1]
            b = ((uint8_t *)(DataTempSPI))[(index*2U)+1U];
 8002370:	f815 7010 	ldrb.w	r7, [r5, r0, lsl #1]
            ((uint8_t *)(AudioInCtx[0].pBuff))[(index*4U)+2U] = Channel_Demux[a & CHANNEL_DEMUX_MASK] |
 8002374:	f001 0955 	and.w	r9, r1, #85	; 0x55
              (Channel_Demux[b & CHANNEL_DEMUX_MASK] << 4);;
 8002378:	f007 0855 	and.w	r8, r7, #85	; 0x55
              ((uint8_t *)(AudioInCtx[0].pBuff))[(index*4U)+3U] = Channel_Demux[(a>>1) & CHANNEL_DEMUX_MASK] |
 800237c:	0849      	lsrs	r1, r1, #1
                (Channel_Demux[(b>>1) & CHANNEL_DEMUX_MASK] << 4);
 800237e:	087f      	lsrs	r7, r7, #1
 8002380:	f007 0755 	and.w	r7, r7, #85	; 0x55
              ((uint8_t *)(AudioInCtx[0].pBuff))[(index*4U)+3U] = Channel_Demux[(a>>1) & CHANNEL_DEMUX_MASK] |
 8002384:	f001 0155 	and.w	r1, r1, #85	; 0x55
                (Channel_Demux[(b>>1) & CHANNEL_DEMUX_MASK] << 4);
 8002388:	441f      	add	r7, r3
              ((uint8_t *)(AudioInCtx[0].pBuff))[(index*4U)+3U] = Channel_Demux[(a>>1) & CHANNEL_DEMUX_MASK] |
 800238a:	4419      	add	r1, r3
                (Channel_Demux[(b>>1) & CHANNEL_DEMUX_MASK] << 4);
 800238c:	f897 7104 	ldrb.w	r7, [r7, #260]	; 0x104
              ((uint8_t *)(AudioInCtx[0].pBuff))[(index*4U)+3U] = Channel_Demux[(a>>1) & CHANNEL_DEMUX_MASK] |
 8002390:	f891 1104 	ldrb.w	r1, [r1, #260]	; 0x104
              (Channel_Demux[b & CHANNEL_DEMUX_MASK] << 4);;
 8002394:	4498      	add	r8, r3
            ((uint8_t *)(AudioInCtx[0].pBuff))[(index*4U)+2U] = Channel_Demux[a & CHANNEL_DEMUX_MASK] |
 8002396:	4499      	add	r9, r3
              ((uint8_t *)(AudioInCtx[0].pBuff))[(index*4U)+3U] = Channel_Demux[(a>>1) & CHANNEL_DEMUX_MASK] |
 8002398:	ea41 1707 	orr.w	r7, r1, r7, lsl #4
            ((uint8_t *)(AudioInCtx[0].pBuff))[(index*4U)+2U] = Channel_Demux[a & CHANNEL_DEMUX_MASK] |
 800239c:	6951      	ldr	r1, [r2, #20]
              (Channel_Demux[b & CHANNEL_DEMUX_MASK] << 4);;
 800239e:	f898 8104 	ldrb.w	r8, [r8, #260]	; 0x104
            ((uint8_t *)(AudioInCtx[0].pBuff))[(index*4U)+2U] = Channel_Demux[a & CHANNEL_DEMUX_MASK] |
 80023a2:	f899 9104 	ldrb.w	r9, [r9, #260]	; 0x104
 80023a6:	4461      	add	r1, ip
 80023a8:	ea49 1808 	orr.w	r8, r9, r8, lsl #4
 80023ac:	f881 8002 	strb.w	r8, [r1, #2]
              ((uint8_t *)(AudioInCtx[0].pBuff))[(index*4U)+3U] = Channel_Demux[(a>>1) & CHANNEL_DEMUX_MASK] |
 80023b0:	6951      	ldr	r1, [r2, #20]
 80023b2:	4461      	add	r1, ip
      for(index=0; index<(AudioInCtx[0].Size/2U); index++) 
 80023b4:	3001      	adds	r0, #1
              ((uint8_t *)(AudioInCtx[0].pBuff))[(index*4U)+3U] = Channel_Demux[(a>>1) & CHANNEL_DEMUX_MASK] |
 80023b6:	70cf      	strb	r7, [r1, #3]
      for(index=0; index<(AudioInCtx[0].Size/2U); index++) 
 80023b8:	69d1      	ldr	r1, [r2, #28]
 80023ba:	ebb0 0f51 	cmp.w	r0, r1, lsr #1
 80023be:	f10c 0c04 	add.w	ip, ip, #4
 80023c2:	d3af      	bcc.n	8002324 <HAL_I2S_RxCpltCallback+0x104>
 80023c4:	e736      	b.n	8002234 <HAL_I2S_RxCpltCallback+0x14>
 80023c6:	3c02      	subs	r4, #2
 80023c8:	1eab      	subs	r3, r5, #2
 80023ca:	3902      	subs	r1, #2
 80023cc:	4425      	add	r5, r4
        AudioInCtx[0].pBuff[index] = (DataTempI2S[index]);
 80023ce:	f833 2f02 	ldrh.w	r2, [r3, #2]!
 80023d2:	f821 2f02 	strh.w	r2, [r1, #2]!
      for(index = 0; index < (AudioInCtx[0].Size/4U); index++)
 80023d6:	42ab      	cmp	r3, r5
 80023d8:	d1f9      	bne.n	80023ce <HAL_I2S_RxCpltCallback+0x1ae>
 80023da:	e72b      	b.n	8002234 <HAL_I2S_RxCpltCallback+0x14>
 80023dc:	200014d8 	.word	0x200014d8
 80023e0:	08009ab8 	.word	0x08009ab8

080023e4 <HAL_I2S_RxHalfCpltCallback>:
  switch(AudioInCtx[0].ChannelsNbr)
 80023e4:	4a6c      	ldr	r2, [pc, #432]	; (8002598 <HAL_I2S_RxHalfCpltCallback+0x1b4>)
 80023e6:	6913      	ldr	r3, [r2, #16]
 80023e8:	2b02      	cmp	r3, #2
{
 80023ea:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  switch(AudioInCtx[0].ChannelsNbr)
 80023ee:	d008      	beq.n	8002402 <HAL_I2S_RxHalfCpltCallback+0x1e>
 80023f0:	2b04      	cmp	r3, #4
 80023f2:	d066      	beq.n	80024c2 <HAL_I2S_RxHalfCpltCallback+0xde>
 80023f4:	2b01      	cmp	r3, #1
 80023f6:	d03d      	beq.n	8002474 <HAL_I2S_RxHalfCpltCallback+0x90>
  CCA02M2_AUDIO_IN_HalfTransfer_CallBack(0);
 80023f8:	2000      	movs	r0, #0
 80023fa:	f7fe ffb3 	bl	8001364 <CCA02M2_AUDIO_IN_HalfTransfer_CallBack>
}
 80023fe:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      for(index=0; index<(AudioInCtx[0].Size/2U); index++) 
 8002402:	69d3      	ldr	r3, [r2, #28]
 8002404:	085b      	lsrs	r3, r3, #1
 8002406:	d0f7      	beq.n	80023f8 <HAL_I2S_RxHalfCpltCallback+0x14>
 8002408:	4b64      	ldr	r3, [pc, #400]	; (800259c <HAL_I2S_RxHalfCpltCallback+0x1b8>)
 800240a:	f04f 0c01 	mov.w	ip, #1
 800240e:	2600      	movs	r6, #0
 8002410:	f602 348c 	addw	r4, r2, #2956	; 0xb8c
        a = ((uint8_t *)(DataTempI2S))[(index*2U)];
 8002414:	f814 1016 	ldrb.w	r1, [r4, r6, lsl #1]
        b = ((uint8_t *)(DataTempI2S))[(index*2U)+1U];
 8002418:	f814 000c 	ldrb.w	r0, [r4, ip]
        ((uint8_t *)(AudioInCtx[0].pBuff))[(index*2U)] = Channel_Demux[a & CHANNEL_DEMUX_MASK] |
 800241c:	f001 0555 	and.w	r5, r1, #85	; 0x55
          (Channel_Demux[b & CHANNEL_DEMUX_MASK] << 4);;
 8002420:	f000 0755 	and.w	r7, r0, #85	; 0x55
 8002424:	441f      	add	r7, r3
        ((uint8_t *)(AudioInCtx[0].pBuff))[(index*2U)] = Channel_Demux[a & CHANNEL_DEMUX_MASK] |
 8002426:	441d      	add	r5, r3
          (Channel_Demux[b & CHANNEL_DEMUX_MASK] << 4);;
 8002428:	f897 e104 	ldrb.w	lr, [r7, #260]	; 0x104
        ((uint8_t *)(AudioInCtx[0].pBuff))[(index*2U)] = Channel_Demux[a & CHANNEL_DEMUX_MASK] |
 800242c:	f895 7104 	ldrb.w	r7, [r5, #260]	; 0x104
 8002430:	6955      	ldr	r5, [r2, #20]
            (Channel_Demux[(b>>1) & CHANNEL_DEMUX_MASK] << 4);
 8002432:	0840      	lsrs	r0, r0, #1
          ((uint8_t *)(AudioInCtx[0].pBuff))[(index*2U)+1U] = Channel_Demux[(a>>1) & CHANNEL_DEMUX_MASK] |
 8002434:	0849      	lsrs	r1, r1, #1
            (Channel_Demux[(b>>1) & CHANNEL_DEMUX_MASK] << 4);
 8002436:	f000 0055 	and.w	r0, r0, #85	; 0x55
          ((uint8_t *)(AudioInCtx[0].pBuff))[(index*2U)+1U] = Channel_Demux[(a>>1) & CHANNEL_DEMUX_MASK] |
 800243a:	f001 0155 	and.w	r1, r1, #85	; 0x55
            (Channel_Demux[(b>>1) & CHANNEL_DEMUX_MASK] << 4);
 800243e:	4418      	add	r0, r3
        ((uint8_t *)(AudioInCtx[0].pBuff))[(index*2U)] = Channel_Demux[a & CHANNEL_DEMUX_MASK] |
 8002440:	ea47 170e 	orr.w	r7, r7, lr, lsl #4
          ((uint8_t *)(AudioInCtx[0].pBuff))[(index*2U)+1U] = Channel_Demux[(a>>1) & CHANNEL_DEMUX_MASK] |
 8002444:	4419      	add	r1, r3
        ((uint8_t *)(AudioInCtx[0].pBuff))[(index*2U)] = Channel_Demux[a & CHANNEL_DEMUX_MASK] |
 8002446:	f805 7016 	strb.w	r7, [r5, r6, lsl #1]
          ((uint8_t *)(AudioInCtx[0].pBuff))[(index*2U)+1U] = Channel_Demux[(a>>1) & CHANNEL_DEMUX_MASK] |
 800244a:	f891 1104 	ldrb.w	r1, [r1, #260]	; 0x104
            (Channel_Demux[(b>>1) & CHANNEL_DEMUX_MASK] << 4);
 800244e:	f890 5104 	ldrb.w	r5, [r0, #260]	; 0x104
          ((uint8_t *)(AudioInCtx[0].pBuff))[(index*2U)+1U] = Channel_Demux[(a>>1) & CHANNEL_DEMUX_MASK] |
 8002452:	6950      	ldr	r0, [r2, #20]
 8002454:	ea41 1105 	orr.w	r1, r1, r5, lsl #4
 8002458:	f800 100c 	strb.w	r1, [r0, ip]
      for(index=0; index<(AudioInCtx[0].Size/2U); index++) 
 800245c:	69d1      	ldr	r1, [r2, #28]
 800245e:	3601      	adds	r6, #1
 8002460:	ebb6 0f51 	cmp.w	r6, r1, lsr #1
 8002464:	f10c 0c02 	add.w	ip, ip, #2
 8002468:	d3d4      	bcc.n	8002414 <HAL_I2S_RxHalfCpltCallback+0x30>
  CCA02M2_AUDIO_IN_HalfTransfer_CallBack(0);
 800246a:	2000      	movs	r0, #0
 800246c:	f7fe ff7a 	bl	8001364 <CCA02M2_AUDIO_IN_HalfTransfer_CallBack>
}
 8002470:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      for(index = 0; index < (AudioInCtx[0].Size/4U); index++)
 8002474:	69d4      	ldr	r4, [r2, #28]
 8002476:	ea5f 0c94 	movs.w	ip, r4, lsr #2
 800247a:	d0bd      	beq.n	80023f8 <HAL_I2S_RxHalfCpltCallback+0x14>
 800247c:	f10c 33ff 	add.w	r3, ip, #4294967295	; 0xffffffff
 8002480:	2b09      	cmp	r3, #9
        AudioInCtx[0].pBuff[index] = (DataTempI2S[index]);
 8002482:	6950      	ldr	r0, [r2, #20]
 8002484:	d97c      	bls.n	8002580 <HAL_I2S_RxHalfCpltCallback+0x19c>
 8002486:	f602 338e 	addw	r3, r2, #2958	; 0xb8e
 800248a:	4298      	cmp	r0, r3
 800248c:	d078      	beq.n	8002580 <HAL_I2S_RxHalfCpltCallback+0x19c>
 800248e:	08e4      	lsrs	r4, r4, #3
 8002490:	4601      	mov	r1, r0
 8002492:	00a3      	lsls	r3, r4, #2
 8002494:	eb00 0784 	add.w	r7, r0, r4, lsl #2
 8002498:	f602 358c 	addw	r5, r2, #2956	; 0xb8c
 800249c:	f855 6b04 	ldr.w	r6, [r5], #4
 80024a0:	f841 6b04 	str.w	r6, [r1], #4
      for(index = 0; index < (AudioInCtx[0].Size/4U); index++)
 80024a4:	428f      	cmp	r7, r1
 80024a6:	d1f9      	bne.n	800249c <HAL_I2S_RxHalfCpltCallback+0xb8>
 80024a8:	ebbc 0f44 	cmp.w	ip, r4, lsl #1
 80024ac:	d0a4      	beq.n	80023f8 <HAL_I2S_RxHalfCpltCallback+0x14>
        AudioInCtx[0].pBuff[index] = (DataTempI2S[index]);
 80024ae:	441a      	add	r2, r3
 80024b0:	f8b2 3b8c 	ldrh.w	r3, [r2, #2956]	; 0xb8c
 80024b4:	f820 3024 	strh.w	r3, [r0, r4, lsl #2]
  CCA02M2_AUDIO_IN_HalfTransfer_CallBack(0);
 80024b8:	2000      	movs	r0, #0
 80024ba:	f7fe ff53 	bl	8001364 <CCA02M2_AUDIO_IN_HalfTransfer_CallBack>
}
 80024be:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      for(index=0; index<(AudioInCtx[0].Size/2U); index++) 
 80024c2:	69d3      	ldr	r3, [r2, #28]
 80024c4:	085b      	lsrs	r3, r3, #1
 80024c6:	d097      	beq.n	80023f8 <HAL_I2S_RxHalfCpltCallback+0x14>
 80024c8:	f04f 0e00 	mov.w	lr, #0
 80024cc:	4b33      	ldr	r3, [pc, #204]	; (800259c <HAL_I2S_RxHalfCpltCallback+0x1b8>)
 80024ce:	46f4      	mov	ip, lr
 80024d0:	f602 348c 	addw	r4, r2, #2956	; 0xb8c
 80024d4:	f202 558c 	addw	r5, r2, #1420	; 0x58c
        b = ((uint8_t *)(DataTempI2S))[(index*2U)+1U];
 80024d8:	eb04 004c 	add.w	r0, r4, ip, lsl #1
        a = ((uint8_t *)(DataTempI2S))[(index*2U)];
 80024dc:	f814 101c 	ldrb.w	r1, [r4, ip, lsl #1]
        b = ((uint8_t *)(DataTempI2S))[(index*2U)+1U];
 80024e0:	7846      	ldrb	r6, [r0, #1]
        ((uint8_t *)(AudioInCtx[0].pBuff))[(index*4U)] = Channel_Demux[a & CHANNEL_DEMUX_MASK] |
 80024e2:	6950      	ldr	r0, [r2, #20]
          (Channel_Demux[b & CHANNEL_DEMUX_MASK] << 4);;
 80024e4:	f006 0755 	and.w	r7, r6, #85	; 0x55
        ((uint8_t *)(AudioInCtx[0].pBuff))[(index*4U)] = Channel_Demux[a & CHANNEL_DEMUX_MASK] |
 80024e8:	f001 0855 	and.w	r8, r1, #85	; 0x55
          (Channel_Demux[b & CHANNEL_DEMUX_MASK] << 4);;
 80024ec:	441f      	add	r7, r3
        ((uint8_t *)(AudioInCtx[0].pBuff))[(index*4U)] = Channel_Demux[a & CHANNEL_DEMUX_MASK] |
 80024ee:	4498      	add	r8, r3
          (Channel_Demux[b & CHANNEL_DEMUX_MASK] << 4);;
 80024f0:	f897 7104 	ldrb.w	r7, [r7, #260]	; 0x104
        ((uint8_t *)(AudioInCtx[0].pBuff))[(index*4U)] = Channel_Demux[a & CHANNEL_DEMUX_MASK] |
 80024f4:	f898 8104 	ldrb.w	r8, [r8, #260]	; 0x104
            (Channel_Demux[(b>>1) & CHANNEL_DEMUX_MASK] << 4);
 80024f8:	0876      	lsrs	r6, r6, #1
        ((uint8_t *)(AudioInCtx[0].pBuff))[(index*4U)] = Channel_Demux[a & CHANNEL_DEMUX_MASK] |
 80024fa:	ea48 1707 	orr.w	r7, r8, r7, lsl #4
          ((uint8_t *)(AudioInCtx[0].pBuff))[(index*4U)+1U] = Channel_Demux[(a>>1) & CHANNEL_DEMUX_MASK] |
 80024fe:	0849      	lsrs	r1, r1, #1
        ((uint8_t *)(AudioInCtx[0].pBuff))[(index*4U)] = Channel_Demux[a & CHANNEL_DEMUX_MASK] |
 8002500:	f800 700e 	strb.w	r7, [r0, lr]
            (Channel_Demux[(b>>1) & CHANNEL_DEMUX_MASK] << 4);
 8002504:	f006 0655 	and.w	r6, r6, #85	; 0x55
          ((uint8_t *)(AudioInCtx[0].pBuff))[(index*4U)+1U] = Channel_Demux[(a>>1) & CHANNEL_DEMUX_MASK] |
 8002508:	f001 0155 	and.w	r1, r1, #85	; 0x55
            (Channel_Demux[(b>>1) & CHANNEL_DEMUX_MASK] << 4);
 800250c:	441e      	add	r6, r3
          ((uint8_t *)(AudioInCtx[0].pBuff))[(index*4U)+1U] = Channel_Demux[(a>>1) & CHANNEL_DEMUX_MASK] |
 800250e:	4419      	add	r1, r3
 8002510:	6950      	ldr	r0, [r2, #20]
            (Channel_Demux[(b>>1) & CHANNEL_DEMUX_MASK] << 4);
 8002512:	f896 6104 	ldrb.w	r6, [r6, #260]	; 0x104
          ((uint8_t *)(AudioInCtx[0].pBuff))[(index*4U)+1U] = Channel_Demux[(a>>1) & CHANNEL_DEMUX_MASK] |
 8002516:	f891 1104 	ldrb.w	r1, [r1, #260]	; 0x104
 800251a:	4470      	add	r0, lr
 800251c:	ea41 1106 	orr.w	r1, r1, r6, lsl #4
            b = ((uint8_t *)(DataTempSPI))[(index*2U)+1U];
 8002520:	eb05 064c 	add.w	r6, r5, ip, lsl #1
          ((uint8_t *)(AudioInCtx[0].pBuff))[(index*4U)+1U] = Channel_Demux[(a>>1) & CHANNEL_DEMUX_MASK] |
 8002524:	7041      	strb	r1, [r0, #1]
            b = ((uint8_t *)(DataTempSPI))[(index*2U)+1U];
 8002526:	7870      	ldrb	r0, [r6, #1]
            a = ((uint8_t *)(DataTempSPI))[(index*2U)];
 8002528:	f815 101c 	ldrb.w	r1, [r5, ip, lsl #1]
            ((uint8_t *)(AudioInCtx[0].pBuff))[(index*4U)+2U] = Channel_Demux[a & CHANNEL_DEMUX_MASK] |
 800252c:	6956      	ldr	r6, [r2, #20]
              (Channel_Demux[b & CHANNEL_DEMUX_MASK] << 4);;
 800252e:	f000 0755 	and.w	r7, r0, #85	; 0x55
                (Channel_Demux[(b>>1) & CHANNEL_DEMUX_MASK] << 4);
 8002532:	0840      	lsrs	r0, r0, #1
 8002534:	f000 0055 	and.w	r0, r0, #85	; 0x55
 8002538:	4418      	add	r0, r3
              (Channel_Demux[b & CHANNEL_DEMUX_MASK] << 4);;
 800253a:	441f      	add	r7, r3
                (Channel_Demux[(b>>1) & CHANNEL_DEMUX_MASK] << 4);
 800253c:	f890 8104 	ldrb.w	r8, [r0, #260]	; 0x104
              (Channel_Demux[b & CHANNEL_DEMUX_MASK] << 4);;
 8002540:	f897 7104 	ldrb.w	r7, [r7, #260]	; 0x104
            ((uint8_t *)(AudioInCtx[0].pBuff))[(index*4U)+2U] = Channel_Demux[a & CHANNEL_DEMUX_MASK] |
 8002544:	f001 0055 	and.w	r0, r1, #85	; 0x55
 8002548:	4418      	add	r0, r3
 800254a:	4476      	add	r6, lr
 800254c:	f890 0104 	ldrb.w	r0, [r0, #260]	; 0x104
              ((uint8_t *)(AudioInCtx[0].pBuff))[(index*4U)+3U] = Channel_Demux[(a>>1) & CHANNEL_DEMUX_MASK] |
 8002550:	0849      	lsrs	r1, r1, #1
            ((uint8_t *)(AudioInCtx[0].pBuff))[(index*4U)+2U] = Channel_Demux[a & CHANNEL_DEMUX_MASK] |
 8002552:	ea40 1707 	orr.w	r7, r0, r7, lsl #4
              ((uint8_t *)(AudioInCtx[0].pBuff))[(index*4U)+3U] = Channel_Demux[(a>>1) & CHANNEL_DEMUX_MASK] |
 8002556:	f001 0155 	and.w	r1, r1, #85	; 0x55
            ((uint8_t *)(AudioInCtx[0].pBuff))[(index*4U)+2U] = Channel_Demux[a & CHANNEL_DEMUX_MASK] |
 800255a:	70b7      	strb	r7, [r6, #2]
              ((uint8_t *)(AudioInCtx[0].pBuff))[(index*4U)+3U] = Channel_Demux[(a>>1) & CHANNEL_DEMUX_MASK] |
 800255c:	4419      	add	r1, r3
 800255e:	6950      	ldr	r0, [r2, #20]
 8002560:	f891 1104 	ldrb.w	r1, [r1, #260]	; 0x104
 8002564:	4470      	add	r0, lr
 8002566:	ea41 1808 	orr.w	r8, r1, r8, lsl #4
 800256a:	f880 8003 	strb.w	r8, [r0, #3]
      for(index=0; index<(AudioInCtx[0].Size/2U); index++) 
 800256e:	69d1      	ldr	r1, [r2, #28]
 8002570:	f10c 0c01 	add.w	ip, ip, #1
 8002574:	ebbc 0f51 	cmp.w	ip, r1, lsr #1
 8002578:	f10e 0e04 	add.w	lr, lr, #4
 800257c:	d3ac      	bcc.n	80024d8 <HAL_I2S_RxHalfCpltCallback+0xf4>
 800257e:	e73b      	b.n	80023f8 <HAL_I2S_RxHalfCpltCallback+0x14>
 8002580:	3802      	subs	r0, #2
 8002582:	4b07      	ldr	r3, [pc, #28]	; (80025a0 <HAL_I2S_RxHalfCpltCallback+0x1bc>)
 8002584:	eb00 0c4c 	add.w	ip, r0, ip, lsl #1
        AudioInCtx[0].pBuff[index] = (DataTempI2S[index]);
 8002588:	f833 2b02 	ldrh.w	r2, [r3], #2
 800258c:	f820 2f02 	strh.w	r2, [r0, #2]!
      for(index = 0; index < (AudioInCtx[0].Size/4U); index++)
 8002590:	4560      	cmp	r0, ip
 8002592:	d1f9      	bne.n	8002588 <HAL_I2S_RxHalfCpltCallback+0x1a4>
 8002594:	e730      	b.n	80023f8 <HAL_I2S_RxHalfCpltCallback+0x14>
 8002596:	bf00      	nop
 8002598:	200014d8 	.word	0x200014d8
 800259c:	08009ab8 	.word	0x08009ab8
 80025a0:	20002064 	.word	0x20002064

080025a4 <SystemInit>:
  */
void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
  SCB->CPACR |= ((3UL << 10 * 2) | (3UL << 11 * 2)); /* set CP10 and CP11 Full Access */
 80025a4:	4910      	ldr	r1, [pc, #64]	; (80025e8 <SystemInit+0x44>)
#endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 80025a6:	4b11      	ldr	r3, [pc, #68]	; (80025ec <SystemInit+0x48>)
  SCB->CPACR |= ((3UL << 10 * 2) | (3UL << 11 * 2)); /* set CP10 and CP11 Full Access */
 80025a8:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 80025ac:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
{
 80025b0:	b410      	push	{r4}
  SCB->CPACR |= ((3UL << 10 * 2) | (3UL << 11 * 2)); /* set CP10 and CP11 Full Access */
 80025b2:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  RCC->CR |= (uint32_t)0x00000001;
 80025b6:	681a      	ldr	r2, [r3, #0]

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 80025b8:	4c0d      	ldr	r4, [pc, #52]	; (80025f0 <SystemInit+0x4c>)
  RCC->CFGR = 0x00000000;
 80025ba:	2000      	movs	r0, #0
  RCC->CR |= (uint32_t)0x00000001;
 80025bc:	f042 0201 	orr.w	r2, r2, #1
 80025c0:	601a      	str	r2, [r3, #0]
  RCC->CFGR = 0x00000000;
 80025c2:	6098      	str	r0, [r3, #8]
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 80025c4:	681a      	ldr	r2, [r3, #0]
 80025c6:	f022 7284 	bic.w	r2, r2, #17301504	; 0x1080000
 80025ca:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 80025ce:	601a      	str	r2, [r3, #0]
  RCC->PLLCFGR = 0x24003010;
 80025d0:	605c      	str	r4, [r3, #4]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 80025d2:	681a      	ldr	r2, [r3, #0]

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 80025d4:	f04f 6400 	mov.w	r4, #134217728	; 0x8000000
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 80025d8:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 80025dc:	601a      	str	r2, [r3, #0]
  RCC->CIR = 0x00000000;
 80025de:	60d8      	str	r0, [r3, #12]
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 80025e0:	608c      	str	r4, [r1, #8]
#endif
}
 80025e2:	f85d 4b04 	ldr.w	r4, [sp], #4
 80025e6:	4770      	bx	lr
 80025e8:	e000ed00 	.word	0xe000ed00
 80025ec:	40023800 	.word	0x40023800
 80025f0:	24003010 	.word	0x24003010

080025f4 <HAL_MspInit>:
__weak void HAL_MspInit(void)
{
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_MspInit could be implemented in the user file
   */
}
 80025f4:	4770      	bx	lr
 80025f6:	bf00      	nop

080025f8 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 80025f8:	b570      	push	{r4, r5, r6, lr}
  /* Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
 80025fa:	4b0e      	ldr	r3, [pc, #56]	; (8002634 <HAL_InitTick+0x3c>)
 80025fc:	4e0e      	ldr	r6, [pc, #56]	; (8002638 <HAL_InitTick+0x40>)
 80025fe:	681b      	ldr	r3, [r3, #0]
 8002600:	7832      	ldrb	r2, [r6, #0]
{
 8002602:	4605      	mov	r5, r0
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
 8002604:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8002608:	fbb0 f0f2 	udiv	r0, r0, r2
 800260c:	fbb3 f0f0 	udiv	r0, r3, r0
 8002610:	f000 f8b0 	bl	8002774 <HAL_SYSTICK_Config>
 8002614:	b908      	cbnz	r0, 800261a <HAL_InitTick+0x22>
  {
    return HAL_ERROR;
  }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 8002616:	2d0f      	cmp	r5, #15
 8002618:	d901      	bls.n	800261e <HAL_InitTick+0x26>
    return HAL_ERROR;
 800261a:	2001      	movs	r0, #1
    return HAL_ERROR;
  }

  /* Return function status */
  return HAL_OK;
}
 800261c:	bd70      	pop	{r4, r5, r6, pc}
 800261e:	4604      	mov	r4, r0
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 8002620:	4602      	mov	r2, r0
 8002622:	4629      	mov	r1, r5
 8002624:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8002628:	f000 f858 	bl	80026dc <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
 800262c:	6075      	str	r5, [r6, #4]
 800262e:	4620      	mov	r0, r4
}
 8002630:	bd70      	pop	{r4, r5, r6, pc}
 8002632:	bf00      	nop
 8002634:	20000078 	.word	0x20000078
 8002638:	2000007c 	.word	0x2000007c

0800263c <HAL_Init>:
{
 800263c:	b508      	push	{r3, lr}
  __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
 800263e:	4b0b      	ldr	r3, [pc, #44]	; (800266c <HAL_Init+0x30>)
 8002640:	681a      	ldr	r2, [r3, #0]
 8002642:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8002646:	601a      	str	r2, [r3, #0]
  __HAL_FLASH_DATA_CACHE_ENABLE();
 8002648:	681a      	ldr	r2, [r3, #0]
 800264a:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 800264e:	601a      	str	r2, [r3, #0]
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8002650:	681a      	ldr	r2, [r3, #0]
 8002652:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8002656:	601a      	str	r2, [r3, #0]
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8002658:	2003      	movs	r0, #3
 800265a:	f000 f82d 	bl	80026b8 <HAL_NVIC_SetPriorityGrouping>
  HAL_InitTick(TICK_INT_PRIORITY);
 800265e:	200f      	movs	r0, #15
 8002660:	f7ff ffca 	bl	80025f8 <HAL_InitTick>
  HAL_MspInit();
 8002664:	f7ff ffc6 	bl	80025f4 <HAL_MspInit>
}
 8002668:	2000      	movs	r0, #0
 800266a:	bd08      	pop	{r3, pc}
 800266c:	40023c00 	.word	0x40023c00

08002670 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += uwTickFreq;
 8002670:	4a03      	ldr	r2, [pc, #12]	; (8002680 <HAL_IncTick+0x10>)
 8002672:	4b04      	ldr	r3, [pc, #16]	; (8002684 <HAL_IncTick+0x14>)
 8002674:	6811      	ldr	r1, [r2, #0]
 8002676:	781b      	ldrb	r3, [r3, #0]
 8002678:	440b      	add	r3, r1
 800267a:	6013      	str	r3, [r2, #0]
}
 800267c:	4770      	bx	lr
 800267e:	bf00      	nop
 8002680:	2000267c 	.word	0x2000267c
 8002684:	2000007c 	.word	0x2000007c

08002688 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 8002688:	4b01      	ldr	r3, [pc, #4]	; (8002690 <HAL_GetTick+0x8>)
 800268a:	6818      	ldr	r0, [r3, #0]
}
 800268c:	4770      	bx	lr
 800268e:	bf00      	nop
 8002690:	2000267c 	.word	0x2000267c

08002694 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 8002694:	b538      	push	{r3, r4, r5, lr}
 8002696:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 8002698:	f7ff fff6 	bl	8002688 <HAL_GetTick>
  uint32_t wait = Delay;

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 800269c:	1c63      	adds	r3, r4, #1
  uint32_t tickstart = HAL_GetTick();
 800269e:	4605      	mov	r5, r0
  if (wait < HAL_MAX_DELAY)
 80026a0:	d002      	beq.n	80026a8 <HAL_Delay+0x14>
  {
    wait += (uint32_t)(uwTickFreq);
 80026a2:	4b04      	ldr	r3, [pc, #16]	; (80026b4 <HAL_Delay+0x20>)
 80026a4:	781b      	ldrb	r3, [r3, #0]
 80026a6:	441c      	add	r4, r3
  }

  while((HAL_GetTick() - tickstart) < wait)
 80026a8:	f7ff ffee 	bl	8002688 <HAL_GetTick>
 80026ac:	1b43      	subs	r3, r0, r5
 80026ae:	42a3      	cmp	r3, r4
 80026b0:	d3fa      	bcc.n	80026a8 <HAL_Delay+0x14>
  {
  }
}
 80026b2:	bd38      	pop	{r3, r4, r5, pc}
 80026b4:	2000007c 	.word	0x2000007c

080026b8 <HAL_NVIC_SetPriorityGrouping>:
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 80026b8:	4907      	ldr	r1, [pc, #28]	; (80026d8 <HAL_NVIC_SetPriorityGrouping+0x20>)
 80026ba:	68ca      	ldr	r2, [r1, #12]
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 80026bc:	0203      	lsls	r3, r0, #8
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 80026be:	f64f 00ff 	movw	r0, #63743	; 0xf8ff
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 80026c2:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 80026c6:	4002      	ands	r2, r0
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 80026c8:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 80026ca:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 80026ce:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  SCB->AIRCR =  reg_value;
 80026d2:	60cb      	str	r3, [r1, #12]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
 80026d4:	4770      	bx	lr
 80026d6:	bf00      	nop
 80026d8:	e000ed00 	.word	0xe000ed00

080026dc <HAL_NVIC_SetPriority>:
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 80026dc:	4b1c      	ldr	r3, [pc, #112]	; (8002750 <HAL_NVIC_SetPriority+0x74>)
 80026de:	68db      	ldr	r3, [r3, #12]
 80026e0:	f3c3 2302 	ubfx	r3, r3, #8, #3
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 80026e4:	b500      	push	{lr}
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 80026e6:	f1c3 0e07 	rsb	lr, r3, #7
 80026ea:	f1be 0f04 	cmp.w	lr, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80026ee:	f103 0c04 	add.w	ip, r3, #4
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 80026f2:	bf28      	it	cs
 80026f4:	f04f 0e04 	movcs.w	lr, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80026f8:	f1bc 0f06 	cmp.w	ip, #6
 80026fc:	d91b      	bls.n	8002736 <HAL_NVIC_SetPriority+0x5a>
 80026fe:	3b03      	subs	r3, #3

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8002700:	f04f 3cff 	mov.w	ip, #4294967295	; 0xffffffff
 8002704:	fa0c fc03 	lsl.w	ip, ip, r3
 8002708:	ea22 020c 	bic.w	r2, r2, ip
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800270c:	f04f 3cff 	mov.w	ip, #4294967295	; 0xffffffff
 8002710:	fa0c fc0e 	lsl.w	ip, ip, lr
 8002714:	ea21 010c 	bic.w	r1, r1, ip
 8002718:	4099      	lsls	r1, r3
  if ((int32_t)(IRQn) >= 0)
 800271a:	2800      	cmp	r0, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800271c:	ea41 0102 	orr.w	r1, r1, r2
  if ((int32_t)(IRQn) >= 0)
 8002720:	db0c      	blt.n	800273c <HAL_NVIC_SetPriority+0x60>
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8002722:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
 8002726:	0109      	lsls	r1, r1, #4
 8002728:	f500 4061 	add.w	r0, r0, #57600	; 0xe100
 800272c:	b2c9      	uxtb	r1, r1
 800272e:	f880 1300 	strb.w	r1, [r0, #768]	; 0x300
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  
  prioritygroup = NVIC_GetPriorityGrouping();
  
  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 8002732:	f85d fb04 	ldr.w	pc, [sp], #4
 8002736:	2200      	movs	r2, #0
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8002738:	4613      	mov	r3, r2
 800273a:	e7e7      	b.n	800270c <HAL_NVIC_SetPriority+0x30>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800273c:	4b05      	ldr	r3, [pc, #20]	; (8002754 <HAL_NVIC_SetPriority+0x78>)
 800273e:	f000 000f 	and.w	r0, r0, #15
 8002742:	0109      	lsls	r1, r1, #4
 8002744:	4403      	add	r3, r0
 8002746:	b2c9      	uxtb	r1, r1
 8002748:	7619      	strb	r1, [r3, #24]
 800274a:	f85d fb04 	ldr.w	pc, [sp], #4
 800274e:	bf00      	nop
 8002750:	e000ed00 	.word	0xe000ed00
 8002754:	e000ecfc 	.word	0xe000ecfc

08002758 <HAL_NVIC_EnableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 8002758:	2800      	cmp	r0, #0
 800275a:	db08      	blt.n	800276e <HAL_NVIC_EnableIRQ+0x16>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 800275c:	4a04      	ldr	r2, [pc, #16]	; (8002770 <HAL_NVIC_EnableIRQ+0x18>)
 800275e:	0941      	lsrs	r1, r0, #5
 8002760:	2301      	movs	r3, #1
 8002762:	f000 001f 	and.w	r0, r0, #31
 8002766:	fa03 f000 	lsl.w	r0, r3, r0
 800276a:	f842 0021 	str.w	r0, [r2, r1, lsl #2]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
 800276e:	4770      	bx	lr
 8002770:	e000e100 	.word	0xe000e100

08002774 <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8002774:	3801      	subs	r0, #1
 8002776:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 800277a:	d210      	bcs.n	800279e <HAL_SYSTICK_Config+0x2a>
  * @param  TicksNumb Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 800277c:	b410      	push	{r4}
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 800277e:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8002782:	4c08      	ldr	r4, [pc, #32]	; (80027a4 <HAL_SYSTICK_Config+0x30>)
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8002784:	6158      	str	r0, [r3, #20]
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8002786:	f04f 0cf0 	mov.w	ip, #240	; 0xf0
 800278a:	f884 c023 	strb.w	ip, [r4, #35]	; 0x23
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 800278e:	2200      	movs	r2, #0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8002790:	2107      	movs	r1, #7
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 8002792:	4610      	mov	r0, r2
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8002794:	619a      	str	r2, [r3, #24]
   return SysTick_Config(TicksNumb);
}
 8002796:	f85d 4b04 	ldr.w	r4, [sp], #4
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 800279a:	6119      	str	r1, [r3, #16]
 800279c:	4770      	bx	lr
    return (1UL);                                                   /* Reload value impossible */
 800279e:	2001      	movs	r0, #1
 80027a0:	4770      	bx	lr
 80027a2:	bf00      	nop
 80027a4:	e000ed00 	.word	0xe000ed00

080027a8 <HAL_DMA_Init>:
  * @param  hdma Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
{
 80027a8:	b538      	push	{r3, r4, r5, lr}
 80027aa:	4604      	mov	r4, r0
  uint32_t tmp = 0U;
  uint32_t tickstart = HAL_GetTick();
 80027ac:	f7ff ff6c 	bl	8002688 <HAL_GetTick>
  DMA_Base_Registers *regs;

  /* Check the DMA peripheral state */
  if(hdma == NULL)
 80027b0:	2c00      	cmp	r4, #0
 80027b2:	d052      	beq.n	800285a <HAL_DMA_Init+0xb2>

  /* Allocate lock resource */
  __HAL_UNLOCK(hdma);
  
  /* Disable the peripheral */
  __HAL_DMA_DISABLE(hdma);
 80027b4:	6823      	ldr	r3, [r4, #0]
  __HAL_UNLOCK(hdma);
 80027b6:	2200      	movs	r2, #0
  hdma->State = HAL_DMA_STATE_BUSY;
 80027b8:	2102      	movs	r1, #2
 80027ba:	f884 1035 	strb.w	r1, [r4, #53]	; 0x35
  __HAL_UNLOCK(hdma);
 80027be:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
  __HAL_DMA_DISABLE(hdma);
 80027c2:	681a      	ldr	r2, [r3, #0]
 80027c4:	f022 0201 	bic.w	r2, r2, #1
 80027c8:	4605      	mov	r5, r0
 80027ca:	601a      	str	r2, [r3, #0]
  
  /* Check if the DMA Stream is effectively disabled */
  while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
 80027cc:	e005      	b.n	80027da <HAL_DMA_Init+0x32>
  {
    /* Check for the Timeout */
    if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
 80027ce:	f7ff ff5b 	bl	8002688 <HAL_GetTick>
 80027d2:	1b43      	subs	r3, r0, r5
 80027d4:	2b05      	cmp	r3, #5
 80027d6:	d839      	bhi.n	800284c <HAL_DMA_Init+0xa4>
  while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
 80027d8:	6823      	ldr	r3, [r4, #0]
 80027da:	681a      	ldr	r2, [r3, #0]
 80027dc:	07d1      	lsls	r1, r2, #31
 80027de:	d4f6      	bmi.n	80027ce <HAL_DMA_Init+0x26>
                      DMA_SxCR_PL    | DMA_SxCR_MSIZE  | DMA_SxCR_PSIZE  | \
                      DMA_SxCR_MINC  | DMA_SxCR_PINC   | DMA_SxCR_CIRC   | \
                      DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM));

  /* Prepare the DMA Stream configuration */
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 80027e0:	e9d4 2001 	ldrd	r2, r0, [r4, #4]
 80027e4:	68e1      	ldr	r1, [r4, #12]
 80027e6:	4302      	orrs	r2, r0
 80027e8:	430a      	orrs	r2, r1
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 80027ea:	e9d4 5104 	ldrd	r5, r1, [r4, #16]
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 80027ee:	69a0      	ldr	r0, [r4, #24]
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 80027f0:	432a      	orrs	r2, r5
 80027f2:	430a      	orrs	r2, r1
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 80027f4:	69e1      	ldr	r1, [r4, #28]
  tmp = hdma->Instance->CR;
 80027f6:	681d      	ldr	r5, [r3, #0]
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 80027f8:	4302      	orrs	r2, r0
 80027fa:	430a      	orrs	r2, r1
  tmp &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
 80027fc:	4933      	ldr	r1, [pc, #204]	; (80028cc <HAL_DMA_Init+0x124>)
 80027fe:	4029      	ands	r1, r5
          hdma->Init.Mode                | hdma->Init.Priority;
 8002800:	6a25      	ldr	r5, [r4, #32]
 8002802:	432a      	orrs	r2, r5
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 8002804:	430a      	orrs	r2, r1

  /* the Memory burst and peripheral burst are not used when the FIFO is disabled */
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 8002806:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8002808:	2904      	cmp	r1, #4
 800280a:	d028      	beq.n	800285e <HAL_DMA_Init+0xb6>
    /* Get memory burst and peripheral burst */
    tmp |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
  }
  
  /* Write to DMA Stream CR register */
  hdma->Instance->CR = tmp;  
 800280c:	601a      	str	r2, [r3, #0]

  /* Get the FCR register value */
  tmp = hdma->Instance->FCR;
 800280e:	695a      	ldr	r2, [r3, #20]

  /* Clear Direct mode and FIFO threshold bits */
  tmp &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
 8002810:	f022 0207 	bic.w	r2, r2, #7

  /* Prepare the DMA Stream FIFO configuration */
  tmp |= hdma->Init.FIFOMode;
 8002814:	4311      	orrs	r1, r2
  *                     the configuration information for the specified DMA Stream. 
  * @retval Stream base address
  */
static uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma)
{
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
 8002816:	b2d8      	uxtb	r0, r3
 8002818:	4a2d      	ldr	r2, [pc, #180]	; (80028d0 <HAL_DMA_Init+0x128>)
  hdma->Instance->FCR = tmp;
 800281a:	6159      	str	r1, [r3, #20]
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
 800281c:	3810      	subs	r0, #16
 800281e:	fba2 5200 	umull	r5, r2, r2, r0
 8002822:	0912      	lsrs	r2, r2, #4
  
  /* lookup table for necessary bitshift of flags within status registers */
  static const uint8_t flagBitshiftOffset[8U] = {0U, 6U, 16U, 22U, 0U, 6U, 16U, 22U};
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
 8002824:	492b      	ldr	r1, [pc, #172]	; (80028d4 <HAL_DMA_Init+0x12c>)
  
  if (stream_number > 3U)
  {
    /* return pointer to HISR and HIFCR */
    hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU)) + 4U);
 8002826:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
 800282a:	5c89      	ldrb	r1, [r1, r2]
 800282c:	65e1      	str	r1, [r4, #92]	; 0x5c
    hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU)) + 4U);
 800282e:	f023 0303 	bic.w	r3, r3, #3
  if (stream_number > 3U)
 8002832:	285f      	cmp	r0, #95	; 0x5f
    hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU)) + 4U);
 8002834:	bf88      	it	hi
 8002836:	3304      	addhi	r3, #4
  regs->IFCR = 0x3FU << hdma->StreamIndex;
 8002838:	223f      	movs	r2, #63	; 0x3f
 800283a:	408a      	lsls	r2, r1
 800283c:	65a3      	str	r3, [r4, #88]	; 0x58
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 800283e:	2000      	movs	r0, #0
  regs->IFCR = 0x3FU << hdma->StreamIndex;
 8002840:	609a      	str	r2, [r3, #8]
  hdma->State = HAL_DMA_STATE_READY;
 8002842:	2301      	movs	r3, #1
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8002844:	6560      	str	r0, [r4, #84]	; 0x54
  hdma->State = HAL_DMA_STATE_READY;
 8002846:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
}
 800284a:	bd38      	pop	{r3, r4, r5, pc}
      hdma->State = HAL_DMA_STATE_TIMEOUT;
 800284c:	2303      	movs	r3, #3
      hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
 800284e:	2220      	movs	r2, #32
 8002850:	6562      	str	r2, [r4, #84]	; 0x54
      hdma->State = HAL_DMA_STATE_TIMEOUT;
 8002852:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
      return HAL_TIMEOUT;
 8002856:	4618      	mov	r0, r3
}
 8002858:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_ERROR;
 800285a:	2001      	movs	r0, #1
}
 800285c:	bd38      	pop	{r3, r4, r5, pc}
    tmp |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
 800285e:	e9d4 510b 	ldrd	r5, r1, [r4, #44]	; 0x2c
 8002862:	4329      	orrs	r1, r5
 8002864:	430a      	orrs	r2, r1
  hdma->Instance->CR = tmp;  
 8002866:	601a      	str	r2, [r3, #0]
  tmp = hdma->Instance->FCR;
 8002868:	6959      	ldr	r1, [r3, #20]
    tmp |= hdma->Init.FIFOThreshold;
 800286a:	6aa2      	ldr	r2, [r4, #40]	; 0x28
  tmp &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
 800286c:	f021 0107 	bic.w	r1, r1, #7
 8002870:	4311      	orrs	r1, r2
    tmp |= hdma->Init.FIFOThreshold;
 8002872:	f041 0104 	orr.w	r1, r1, #4
    if (hdma->Init.MemBurst != DMA_MBURST_SINGLE)
 8002876:	2d00      	cmp	r5, #0
 8002878:	d0cd      	beq.n	8002816 <HAL_DMA_Init+0x6e>
{
  HAL_StatusTypeDef status = HAL_OK;
  uint32_t tmp = hdma->Init.FIFOThreshold;
  
  /* Memory Data size equal to Byte */
  if(hdma->Init.MemDataAlignment == DMA_MDATAALIGN_BYTE)
 800287a:	b178      	cbz	r0, 800289c <HAL_DMA_Init+0xf4>
      break;
    }
  }
  
  /* Memory Data size equal to Half-Word */
  else if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
 800287c:	f5b0 5f00 	cmp.w	r0, #8192	; 0x2000
 8002880:	d016      	beq.n	80028b0 <HAL_DMA_Init+0x108>
  }
  
  /* Memory Data size equal to Word */
  else
  {
    switch (tmp)
 8002882:	2a02      	cmp	r2, #2
 8002884:	d903      	bls.n	800288e <HAL_DMA_Init+0xe6>
 8002886:	2a03      	cmp	r2, #3
 8002888:	d1c5      	bne.n	8002816 <HAL_DMA_Init+0x6e>
    case DMA_FIFO_THRESHOLD_HALFFULL:
    case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
      status = HAL_ERROR;
      break;
    case DMA_FIFO_THRESHOLD_FULL:
      if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
 800288a:	01ea      	lsls	r2, r5, #7
 800288c:	d5c3      	bpl.n	8002816 <HAL_DMA_Init+0x6e>
        hdma->State = HAL_DMA_STATE_READY;
 800288e:	2301      	movs	r3, #1
        hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
 8002890:	2240      	movs	r2, #64	; 0x40
 8002892:	6562      	str	r2, [r4, #84]	; 0x54
        hdma->State = HAL_DMA_STATE_READY;
 8002894:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
        return HAL_ERROR; 
 8002898:	4618      	mov	r0, r3
}
 800289a:	bd38      	pop	{r3, r4, r5, pc}
    switch (tmp)
 800289c:	2a01      	cmp	r2, #1
 800289e:	d003      	beq.n	80028a8 <HAL_DMA_Init+0x100>
 80028a0:	f032 0202 	bics.w	r2, r2, #2
 80028a4:	d1b7      	bne.n	8002816 <HAL_DMA_Init+0x6e>
 80028a6:	e7f0      	b.n	800288a <HAL_DMA_Init+0xe2>
      if (hdma->Init.MemBurst == DMA_MBURST_INC16)
 80028a8:	f1b5 7fc0 	cmp.w	r5, #25165824	; 0x1800000
 80028ac:	d1b3      	bne.n	8002816 <HAL_DMA_Init+0x6e>
 80028ae:	e7ee      	b.n	800288e <HAL_DMA_Init+0xe6>
    switch (tmp)
 80028b0:	2a03      	cmp	r2, #3
 80028b2:	d8b0      	bhi.n	8002816 <HAL_DMA_Init+0x6e>
 80028b4:	a001      	add	r0, pc, #4	; (adr r0, 80028bc <HAL_DMA_Init+0x114>)
 80028b6:	f850 f022 	ldr.w	pc, [r0, r2, lsl #2]
 80028ba:	bf00      	nop
 80028bc:	0800288f 	.word	0x0800288f
 80028c0:	0800288b 	.word	0x0800288b
 80028c4:	0800288f 	.word	0x0800288f
 80028c8:	080028a9 	.word	0x080028a9
 80028cc:	f010803f 	.word	0xf010803f
 80028d0:	aaaaaaab 	.word	0xaaaaaaab
 80028d4:	08009c54 	.word	0x08009c54

080028d8 <HAL_DMA_DeInit>:
{
 80028d8:	b430      	push	{r4, r5}
  if(hdma == NULL)
 80028da:	2800      	cmp	r0, #0
 80028dc:	d035      	beq.n	800294a <HAL_DMA_DeInit+0x72>
  if(hdma->State == HAL_DMA_STATE_BUSY)
 80028de:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
 80028e2:	2b02      	cmp	r3, #2
 80028e4:	b2dc      	uxtb	r4, r3
 80028e6:	d02d      	beq.n	8002944 <HAL_DMA_DeInit+0x6c>
  __HAL_DMA_DISABLE(hdma);
 80028e8:	6803      	ldr	r3, [r0, #0]
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
 80028ea:	4a1a      	ldr	r2, [pc, #104]	; (8002954 <HAL_DMA_DeInit+0x7c>)
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
 80028ec:	4d1a      	ldr	r5, [pc, #104]	; (8002958 <HAL_DMA_DeInit+0x80>)
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
 80028ee:	b2d9      	uxtb	r1, r3
 80028f0:	3910      	subs	r1, #16
 80028f2:	fba2 4201 	umull	r4, r2, r2, r1
 80028f6:	0912      	lsrs	r2, r2, #4
  __HAL_DMA_DISABLE(hdma);
 80028f8:	681c      	ldr	r4, [r3, #0]
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
 80028fa:	5cad      	ldrb	r5, [r5, r2]
  __HAL_DMA_DISABLE(hdma);
 80028fc:	f024 0401 	bic.w	r4, r4, #1
  hdma->Instance->CR   = 0U;
 8002900:	2200      	movs	r2, #0
  __HAL_DMA_DISABLE(hdma);
 8002902:	601c      	str	r4, [r3, #0]
  hdma->Instance->CR   = 0U;
 8002904:	601a      	str	r2, [r3, #0]
  hdma->Instance->NDTR = 0U;
 8002906:	605a      	str	r2, [r3, #4]
  hdma->Instance->PAR  = 0U;
 8002908:	609a      	str	r2, [r3, #8]
  hdma->Instance->M0AR = 0U;
 800290a:	60da      	str	r2, [r3, #12]
  hdma->Instance->M1AR = 0U;
 800290c:	611a      	str	r2, [r3, #16]
  hdma->Instance->FCR  = 0x00000021U;
 800290e:	2221      	movs	r2, #33	; 0x21
 8002910:	615a      	str	r2, [r3, #20]
    hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU)) + 4U);
 8002912:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
 8002916:	f023 0303 	bic.w	r3, r3, #3
  if (stream_number > 3U)
 800291a:	295f      	cmp	r1, #95	; 0x5f
    hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU)) + 4U);
 800291c:	bf88      	it	hi
 800291e:	3304      	addhi	r3, #4
  regs->IFCR = 0x3FU << hdma->StreamIndex;
 8002920:	213f      	movs	r1, #63	; 0x3f
  hdma->XferCpltCallback = NULL;
 8002922:	2200      	movs	r2, #0
  regs->IFCR = 0x3FU << hdma->StreamIndex;
 8002924:	40a9      	lsls	r1, r5
  hdma->XferHalfCpltCallback = NULL;
 8002926:	e9c0 220f 	strd	r2, r2, [r0, #60]	; 0x3c
  hdma->XferM1HalfCpltCallback = NULL;
 800292a:	e9c0 2211 	strd	r2, r2, [r0, #68]	; 0x44
  hdma->XferAbortCallback = NULL;
 800292e:	e9c0 2213 	strd	r2, r2, [r0, #76]	; 0x4c
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
 8002932:	65c5      	str	r5, [r0, #92]	; 0x5c
    hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU)) + 4U);
 8002934:	6583      	str	r3, [r0, #88]	; 0x58
  return HAL_OK;
 8002936:	4614      	mov	r4, r2
  regs->IFCR = 0x3FU << hdma->StreamIndex;
 8002938:	6099      	str	r1, [r3, #8]
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 800293a:	6542      	str	r2, [r0, #84]	; 0x54
  __HAL_UNLOCK(hdma);
 800293c:	f880 2034 	strb.w	r2, [r0, #52]	; 0x34
  hdma->State = HAL_DMA_STATE_RESET;
 8002940:	f880 2035 	strb.w	r2, [r0, #53]	; 0x35
}
 8002944:	4620      	mov	r0, r4
 8002946:	bc30      	pop	{r4, r5}
 8002948:	4770      	bx	lr
    return HAL_ERROR;
 800294a:	2401      	movs	r4, #1
}
 800294c:	4620      	mov	r0, r4
 800294e:	bc30      	pop	{r4, r5}
 8002950:	4770      	bx	lr
 8002952:	bf00      	nop
 8002954:	aaaaaaab 	.word	0xaaaaaaab
 8002958:	08009c54 	.word	0x08009c54

0800295c <HAL_DMA_Start_IT>:
{
 800295c:	b470      	push	{r4, r5, r6}
  __HAL_LOCK(hdma);
 800295e:	f890 4034 	ldrb.w	r4, [r0, #52]	; 0x34
  DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
 8002962:	6d85      	ldr	r5, [r0, #88]	; 0x58
  __HAL_LOCK(hdma);
 8002964:	2c01      	cmp	r4, #1
 8002966:	d035      	beq.n	80029d4 <HAL_DMA_Start_IT+0x78>
  if(HAL_DMA_STATE_READY == hdma->State)
 8002968:	f890 4035 	ldrb.w	r4, [r0, #53]	; 0x35
  __HAL_LOCK(hdma);
 800296c:	f04f 0c01 	mov.w	ip, #1
  if(HAL_DMA_STATE_READY == hdma->State)
 8002970:	4564      	cmp	r4, ip
  __HAL_LOCK(hdma);
 8002972:	f880 c034 	strb.w	ip, [r0, #52]	; 0x34
  if(HAL_DMA_STATE_READY == hdma->State)
 8002976:	d005      	beq.n	8002984 <HAL_DMA_Start_IT+0x28>
    __HAL_UNLOCK(hdma);	  
 8002978:	2300      	movs	r3, #0
 800297a:	f880 3034 	strb.w	r3, [r0, #52]	; 0x34
}
 800297e:	bc70      	pop	{r4, r5, r6}
    status = HAL_BUSY;
 8002980:	2002      	movs	r0, #2
}
 8002982:	4770      	bx	lr
    hdma->State = HAL_DMA_STATE_BUSY;
 8002984:	2602      	movs	r6, #2
 8002986:	f880 6035 	strb.w	r6, [r0, #53]	; 0x35
  hdma->Instance->CR &= (uint32_t)(~DMA_SxCR_DBM);
 800298a:	6804      	ldr	r4, [r0, #0]
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 800298c:	2600      	movs	r6, #0
 800298e:	6546      	str	r6, [r0, #84]	; 0x54
  hdma->Instance->CR &= (uint32_t)(~DMA_SxCR_DBM);
 8002990:	6826      	ldr	r6, [r4, #0]
 8002992:	f426 2680 	bic.w	r6, r6, #262144	; 0x40000
 8002996:	6026      	str	r6, [r4, #0]
  hdma->Instance->NDTR = DataLength;
 8002998:	6063      	str	r3, [r4, #4]
  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 800299a:	6883      	ldr	r3, [r0, #8]
 800299c:	2b40      	cmp	r3, #64	; 0x40
    hdma->Instance->PAR = DstAddress;
 800299e:	bf0e      	itee	eq
 80029a0:	60a2      	streq	r2, [r4, #8]
    hdma->Instance->PAR = SrcAddress;
 80029a2:	60a1      	strne	r1, [r4, #8]
    hdma->Instance->M0AR = DstAddress;
 80029a4:	60e2      	strne	r2, [r4, #12]
    regs->IFCR = 0x3FU << hdma->StreamIndex;
 80029a6:	6dc2      	ldr	r2, [r0, #92]	; 0x5c
    hdma->Instance->M0AR = SrcAddress;
 80029a8:	bf08      	it	eq
 80029aa:	60e1      	streq	r1, [r4, #12]
    regs->IFCR = 0x3FU << hdma->StreamIndex;
 80029ac:	233f      	movs	r3, #63	; 0x3f
 80029ae:	4093      	lsls	r3, r2
 80029b0:	60ab      	str	r3, [r5, #8]
    hdma->Instance->CR  |= DMA_IT_TC | DMA_IT_TE | DMA_IT_DME;
 80029b2:	6823      	ldr	r3, [r4, #0]
    if(hdma->XferHalfCpltCallback != NULL)
 80029b4:	6c02      	ldr	r2, [r0, #64]	; 0x40
    hdma->Instance->CR  |= DMA_IT_TC | DMA_IT_TE | DMA_IT_DME;
 80029b6:	f043 0316 	orr.w	r3, r3, #22
 80029ba:	6023      	str	r3, [r4, #0]
    if(hdma->XferHalfCpltCallback != NULL)
 80029bc:	b11a      	cbz	r2, 80029c6 <HAL_DMA_Start_IT+0x6a>
      hdma->Instance->CR  |= DMA_IT_HT;
 80029be:	6823      	ldr	r3, [r4, #0]
 80029c0:	f043 0308 	orr.w	r3, r3, #8
 80029c4:	6023      	str	r3, [r4, #0]
    __HAL_DMA_ENABLE(hdma);
 80029c6:	6823      	ldr	r3, [r4, #0]
 80029c8:	f043 0301 	orr.w	r3, r3, #1
  HAL_StatusTypeDef status = HAL_OK;
 80029cc:	2000      	movs	r0, #0
    __HAL_DMA_ENABLE(hdma);
 80029ce:	6023      	str	r3, [r4, #0]
}
 80029d0:	bc70      	pop	{r4, r5, r6}
 80029d2:	4770      	bx	lr
  __HAL_LOCK(hdma);
 80029d4:	2002      	movs	r0, #2
}
 80029d6:	bc70      	pop	{r4, r5, r6}
 80029d8:	4770      	bx	lr
 80029da:	bf00      	nop

080029dc <HAL_DMA_IRQHandler>:
{
 80029dc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80029e0:	b082      	sub	sp, #8
  uint32_t timeout = SystemCoreClock / 9600U;
 80029e2:	4a74      	ldr	r2, [pc, #464]	; (8002bb4 <HAL_DMA_IRQHandler+0x1d8>)
  DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
 80029e4:	6d86      	ldr	r6, [r0, #88]	; 0x58
  uint32_t timeout = SystemCoreClock / 9600U;
 80029e6:	6815      	ldr	r5, [r2, #0]
  __IO uint32_t count = 0U;
 80029e8:	2300      	movs	r3, #0
 80029ea:	9301      	str	r3, [sp, #4]
  if ((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
 80029ec:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
  tmpisr = regs->ISR;
 80029ee:	6834      	ldr	r4, [r6, #0]
  if ((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
 80029f0:	2208      	movs	r2, #8
 80029f2:	409a      	lsls	r2, r3
 80029f4:	4222      	tst	r2, r4
{
 80029f6:	4680      	mov	r8, r0
  if ((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
 80029f8:	d004      	beq.n	8002a04 <HAL_DMA_IRQHandler+0x28>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != RESET)
 80029fa:	6801      	ldr	r1, [r0, #0]
 80029fc:	680f      	ldr	r7, [r1, #0]
 80029fe:	0778      	lsls	r0, r7, #29
 8002a00:	f100 808a 	bmi.w	8002b18 <HAL_DMA_IRQHandler+0x13c>
  if ((tmpisr & (DMA_FLAG_FEIF0_4 << hdma->StreamIndex)) != RESET)
 8002a04:	2201      	movs	r2, #1
 8002a06:	409a      	lsls	r2, r3
 8002a08:	4222      	tst	r2, r4
 8002a0a:	d004      	beq.n	8002a16 <HAL_DMA_IRQHandler+0x3a>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_FE) != RESET)
 8002a0c:	f8d8 1000 	ldr.w	r1, [r8]
 8002a10:	6949      	ldr	r1, [r1, #20]
 8002a12:	0609      	lsls	r1, r1, #24
 8002a14:	d478      	bmi.n	8002b08 <HAL_DMA_IRQHandler+0x12c>
  if ((tmpisr & (DMA_FLAG_DMEIF0_4 << hdma->StreamIndex)) != RESET)
 8002a16:	2204      	movs	r2, #4
 8002a18:	409a      	lsls	r2, r3
 8002a1a:	4222      	tst	r2, r4
 8002a1c:	d004      	beq.n	8002a28 <HAL_DMA_IRQHandler+0x4c>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_DME) != RESET)
 8002a1e:	f8d8 1000 	ldr.w	r1, [r8]
 8002a22:	6809      	ldr	r1, [r1, #0]
 8002a24:	078f      	lsls	r7, r1, #30
 8002a26:	d467      	bmi.n	8002af8 <HAL_DMA_IRQHandler+0x11c>
  if ((tmpisr & (DMA_FLAG_HTIF0_4 << hdma->StreamIndex)) != RESET)
 8002a28:	2210      	movs	r2, #16
 8002a2a:	409a      	lsls	r2, r3
 8002a2c:	4222      	tst	r2, r4
 8002a2e:	d004      	beq.n	8002a3a <HAL_DMA_IRQHandler+0x5e>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != RESET)
 8002a30:	f8d8 1000 	ldr.w	r1, [r8]
 8002a34:	680f      	ldr	r7, [r1, #0]
 8002a36:	0738      	lsls	r0, r7, #28
 8002a38:	d449      	bmi.n	8002ace <HAL_DMA_IRQHandler+0xf2>
  if ((tmpisr & (DMA_FLAG_TCIF0_4 << hdma->StreamIndex)) != RESET)
 8002a3a:	2220      	movs	r2, #32
 8002a3c:	409a      	lsls	r2, r3
 8002a3e:	4222      	tst	r2, r4
 8002a40:	d017      	beq.n	8002a72 <HAL_DMA_IRQHandler+0x96>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != RESET)
 8002a42:	f8d8 1000 	ldr.w	r1, [r8]
 8002a46:	680c      	ldr	r4, [r1, #0]
 8002a48:	06e0      	lsls	r0, r4, #27
 8002a4a:	d512      	bpl.n	8002a72 <HAL_DMA_IRQHandler+0x96>
      regs->IFCR = DMA_FLAG_TCIF0_4 << hdma->StreamIndex;
 8002a4c:	60b2      	str	r2, [r6, #8]
      if(HAL_DMA_STATE_ABORT == hdma->State)
 8002a4e:	f898 2035 	ldrb.w	r2, [r8, #53]	; 0x35
 8002a52:	2a05      	cmp	r2, #5
 8002a54:	d073      	beq.n	8002b3e <HAL_DMA_IRQHandler+0x162>
      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
 8002a56:	680b      	ldr	r3, [r1, #0]
 8002a58:	f413 2f80 	tst.w	r3, #262144	; 0x40000
        if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
 8002a5c:	680b      	ldr	r3, [r1, #0]
      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
 8002a5e:	f000 8090 	beq.w	8002b82 <HAL_DMA_IRQHandler+0x1a6>
        if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
 8002a62:	0319      	lsls	r1, r3, #12
 8002a64:	f140 809b 	bpl.w	8002b9e <HAL_DMA_IRQHandler+0x1c2>
        if(hdma->XferCpltCallback != NULL)
 8002a68:	f8d8 303c 	ldr.w	r3, [r8, #60]	; 0x3c
 8002a6c:	b10b      	cbz	r3, 8002a72 <HAL_DMA_IRQHandler+0x96>
          hdma->XferCpltCallback(hdma);
 8002a6e:	4640      	mov	r0, r8
 8002a70:	4798      	blx	r3
  if(hdma->ErrorCode != HAL_DMA_ERROR_NONE)
 8002a72:	f8d8 3054 	ldr.w	r3, [r8, #84]	; 0x54
 8002a76:	b33b      	cbz	r3, 8002ac8 <HAL_DMA_IRQHandler+0xec>
    if((hdma->ErrorCode & HAL_DMA_ERROR_TE) != RESET)
 8002a78:	f8d8 3054 	ldr.w	r3, [r8, #84]	; 0x54
 8002a7c:	07da      	lsls	r2, r3, #31
 8002a7e:	d51b      	bpl.n	8002ab8 <HAL_DMA_IRQHandler+0xdc>
      __HAL_DMA_DISABLE(hdma);
 8002a80:	f8d8 2000 	ldr.w	r2, [r8]
  uint32_t timeout = SystemCoreClock / 9600U;
 8002a84:	494c      	ldr	r1, [pc, #304]	; (8002bb8 <HAL_DMA_IRQHandler+0x1dc>)
      hdma->State = HAL_DMA_STATE_ABORT;
 8002a86:	2305      	movs	r3, #5
 8002a88:	f888 3035 	strb.w	r3, [r8, #53]	; 0x35
      __HAL_DMA_DISABLE(hdma);
 8002a8c:	6813      	ldr	r3, [r2, #0]
  uint32_t timeout = SystemCoreClock / 9600U;
 8002a8e:	fba1 1505 	umull	r1, r5, r1, r5
      __HAL_DMA_DISABLE(hdma);
 8002a92:	f023 0301 	bic.w	r3, r3, #1
  uint32_t timeout = SystemCoreClock / 9600U;
 8002a96:	0aad      	lsrs	r5, r5, #10
      __HAL_DMA_DISABLE(hdma);
 8002a98:	6013      	str	r3, [r2, #0]
 8002a9a:	e002      	b.n	8002aa2 <HAL_DMA_IRQHandler+0xc6>
      while((hdma->Instance->CR & DMA_SxCR_EN) != RESET);
 8002a9c:	6813      	ldr	r3, [r2, #0]
 8002a9e:	07db      	lsls	r3, r3, #31
 8002aa0:	d504      	bpl.n	8002aac <HAL_DMA_IRQHandler+0xd0>
        if (++count > timeout)
 8002aa2:	9b01      	ldr	r3, [sp, #4]
 8002aa4:	3301      	adds	r3, #1
 8002aa6:	42ab      	cmp	r3, r5
 8002aa8:	9301      	str	r3, [sp, #4]
 8002aaa:	d9f7      	bls.n	8002a9c <HAL_DMA_IRQHandler+0xc0>
      hdma->State = HAL_DMA_STATE_READY;
 8002aac:	2201      	movs	r2, #1
      __HAL_UNLOCK(hdma);
 8002aae:	2300      	movs	r3, #0
      hdma->State = HAL_DMA_STATE_READY;
 8002ab0:	f888 2035 	strb.w	r2, [r8, #53]	; 0x35
      __HAL_UNLOCK(hdma);
 8002ab4:	f888 3034 	strb.w	r3, [r8, #52]	; 0x34
    if(hdma->XferErrorCallback != NULL)
 8002ab8:	f8d8 304c 	ldr.w	r3, [r8, #76]	; 0x4c
 8002abc:	b123      	cbz	r3, 8002ac8 <HAL_DMA_IRQHandler+0xec>
      hdma->XferErrorCallback(hdma);
 8002abe:	4640      	mov	r0, r8
}
 8002ac0:	b002      	add	sp, #8
 8002ac2:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
      hdma->XferErrorCallback(hdma);
 8002ac6:	4718      	bx	r3
}
 8002ac8:	b002      	add	sp, #8
 8002aca:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      regs->IFCR = DMA_FLAG_HTIF0_4 << hdma->StreamIndex;
 8002ace:	60b2      	str	r2, [r6, #8]
      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
 8002ad0:	680a      	ldr	r2, [r1, #0]
 8002ad2:	f412 2f80 	tst.w	r2, #262144	; 0x40000
        if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
 8002ad6:	680a      	ldr	r2, [r1, #0]
      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
 8002ad8:	d12a      	bne.n	8002b30 <HAL_DMA_IRQHandler+0x154>
        if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)
 8002ada:	05d7      	lsls	r7, r2, #23
 8002adc:	d403      	bmi.n	8002ae6 <HAL_DMA_IRQHandler+0x10a>
          hdma->Instance->CR  &= ~(DMA_IT_HT);
 8002ade:	680a      	ldr	r2, [r1, #0]
 8002ae0:	f022 0208 	bic.w	r2, r2, #8
 8002ae4:	600a      	str	r2, [r1, #0]
        if(hdma->XferHalfCpltCallback != NULL)
 8002ae6:	f8d8 2040 	ldr.w	r2, [r8, #64]	; 0x40
 8002aea:	2a00      	cmp	r2, #0
 8002aec:	d0a5      	beq.n	8002a3a <HAL_DMA_IRQHandler+0x5e>
          hdma->XferHalfCpltCallback(hdma);
 8002aee:	4640      	mov	r0, r8
 8002af0:	4790      	blx	r2
  if ((tmpisr & (DMA_FLAG_TCIF0_4 << hdma->StreamIndex)) != RESET)
 8002af2:	f8d8 305c 	ldr.w	r3, [r8, #92]	; 0x5c
 8002af6:	e7a0      	b.n	8002a3a <HAL_DMA_IRQHandler+0x5e>
      regs->IFCR = DMA_FLAG_DMEIF0_4 << hdma->StreamIndex;
 8002af8:	60b2      	str	r2, [r6, #8]
      hdma->ErrorCode |= HAL_DMA_ERROR_DME;
 8002afa:	f8d8 2054 	ldr.w	r2, [r8, #84]	; 0x54
 8002afe:	f042 0204 	orr.w	r2, r2, #4
 8002b02:	f8c8 2054 	str.w	r2, [r8, #84]	; 0x54
 8002b06:	e78f      	b.n	8002a28 <HAL_DMA_IRQHandler+0x4c>
      regs->IFCR = DMA_FLAG_FEIF0_4 << hdma->StreamIndex;
 8002b08:	60b2      	str	r2, [r6, #8]
      hdma->ErrorCode |= HAL_DMA_ERROR_FE;
 8002b0a:	f8d8 2054 	ldr.w	r2, [r8, #84]	; 0x54
 8002b0e:	f042 0202 	orr.w	r2, r2, #2
 8002b12:	f8c8 2054 	str.w	r2, [r8, #84]	; 0x54
 8002b16:	e77e      	b.n	8002a16 <HAL_DMA_IRQHandler+0x3a>
      hdma->Instance->CR  &= ~(DMA_IT_TE);
 8002b18:	680f      	ldr	r7, [r1, #0]
 8002b1a:	f027 0704 	bic.w	r7, r7, #4
 8002b1e:	600f      	str	r7, [r1, #0]
      regs->IFCR = DMA_FLAG_TEIF0_4 << hdma->StreamIndex;
 8002b20:	60b2      	str	r2, [r6, #8]
      hdma->ErrorCode |= HAL_DMA_ERROR_TE;
 8002b22:	f8d8 2054 	ldr.w	r2, [r8, #84]	; 0x54
 8002b26:	f042 0201 	orr.w	r2, r2, #1
 8002b2a:	f8c8 2054 	str.w	r2, [r8, #84]	; 0x54
 8002b2e:	e769      	b.n	8002a04 <HAL_DMA_IRQHandler+0x28>
        if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
 8002b30:	0312      	lsls	r2, r2, #12
 8002b32:	d5d8      	bpl.n	8002ae6 <HAL_DMA_IRQHandler+0x10a>
          if(hdma->XferM1HalfCpltCallback != NULL)
 8002b34:	f8d8 2048 	ldr.w	r2, [r8, #72]	; 0x48
 8002b38:	2a00      	cmp	r2, #0
 8002b3a:	d1d8      	bne.n	8002aee <HAL_DMA_IRQHandler+0x112>
 8002b3c:	e77d      	b.n	8002a3a <HAL_DMA_IRQHandler+0x5e>
        hdma->Instance->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
 8002b3e:	680a      	ldr	r2, [r1, #0]
 8002b40:	f022 0216 	bic.w	r2, r2, #22
 8002b44:	600a      	str	r2, [r1, #0]
        hdma->Instance->FCR &= ~(DMA_IT_FE);
 8002b46:	694a      	ldr	r2, [r1, #20]
 8002b48:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8002b4c:	614a      	str	r2, [r1, #20]
        if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
 8002b4e:	f8d8 2040 	ldr.w	r2, [r8, #64]	; 0x40
 8002b52:	b352      	cbz	r2, 8002baa <HAL_DMA_IRQHandler+0x1ce>
          hdma->Instance->CR  &= ~(DMA_IT_HT);
 8002b54:	680a      	ldr	r2, [r1, #0]
 8002b56:	f022 0208 	bic.w	r2, r2, #8
 8002b5a:	600a      	str	r2, [r1, #0]
        regs->IFCR = 0x3FU << hdma->StreamIndex;
 8002b5c:	223f      	movs	r2, #63	; 0x3f
 8002b5e:	fa02 f303 	lsl.w	r3, r2, r3
        if(hdma->XferAbortCallback != NULL)
 8002b62:	f8d8 1050 	ldr.w	r1, [r8, #80]	; 0x50
        regs->IFCR = 0x3FU << hdma->StreamIndex;
 8002b66:	60b3      	str	r3, [r6, #8]
        hdma->State = HAL_DMA_STATE_READY;
 8002b68:	2201      	movs	r2, #1
        __HAL_UNLOCK(hdma);
 8002b6a:	2300      	movs	r3, #0
        hdma->State = HAL_DMA_STATE_READY;
 8002b6c:	f888 2035 	strb.w	r2, [r8, #53]	; 0x35
        __HAL_UNLOCK(hdma);
 8002b70:	f888 3034 	strb.w	r3, [r8, #52]	; 0x34
        if(hdma->XferAbortCallback != NULL)
 8002b74:	2900      	cmp	r1, #0
 8002b76:	d0a7      	beq.n	8002ac8 <HAL_DMA_IRQHandler+0xec>
          hdma->XferAbortCallback(hdma);
 8002b78:	4640      	mov	r0, r8
}
 8002b7a:	b002      	add	sp, #8
 8002b7c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
          hdma->XferAbortCallback(hdma);
 8002b80:	4708      	bx	r1
        if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)
 8002b82:	f413 7380 	ands.w	r3, r3, #256	; 0x100
 8002b86:	f47f af6f 	bne.w	8002a68 <HAL_DMA_IRQHandler+0x8c>
          hdma->Instance->CR  &= ~(DMA_IT_TC);
 8002b8a:	680a      	ldr	r2, [r1, #0]
 8002b8c:	f022 0210 	bic.w	r2, r2, #16
 8002b90:	600a      	str	r2, [r1, #0]
          hdma->State = HAL_DMA_STATE_READY;
 8002b92:	2201      	movs	r2, #1
 8002b94:	f888 2035 	strb.w	r2, [r8, #53]	; 0x35
          __HAL_UNLOCK(hdma);
 8002b98:	f888 3034 	strb.w	r3, [r8, #52]	; 0x34
 8002b9c:	e764      	b.n	8002a68 <HAL_DMA_IRQHandler+0x8c>
          if(hdma->XferM1CpltCallback != NULL)
 8002b9e:	f8d8 3044 	ldr.w	r3, [r8, #68]	; 0x44
 8002ba2:	2b00      	cmp	r3, #0
 8002ba4:	f47f af63 	bne.w	8002a6e <HAL_DMA_IRQHandler+0x92>
 8002ba8:	e763      	b.n	8002a72 <HAL_DMA_IRQHandler+0x96>
        if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
 8002baa:	f8d8 2048 	ldr.w	r2, [r8, #72]	; 0x48
 8002bae:	2a00      	cmp	r2, #0
 8002bb0:	d1d0      	bne.n	8002b54 <HAL_DMA_IRQHandler+0x178>
 8002bb2:	e7d3      	b.n	8002b5c <HAL_DMA_IRQHandler+0x180>
 8002bb4:	20000078 	.word	0x20000078
 8002bb8:	1b4e81b5 	.word	0x1b4e81b5

08002bbc <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8002bbc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  for(position = 0U; position < GPIO_NUMBER; position++)
  {
    /* Get the IO position */
    ioposition = 0x01U << position;
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8002bc0:	2200      	movs	r2, #0
 8002bc2:	680c      	ldr	r4, [r1, #0]
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
        SYSCFG->EXTICR[position >> 2U] = temp;

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
 8002bc4:	4e70      	ldr	r6, [pc, #448]	; (8002d88 <HAL_GPIO_Init+0x1cc>)
{
 8002bc6:	b085      	sub	sp, #20
  for(position = 0U; position < GPIO_NUMBER; position++)
 8002bc8:	4613      	mov	r3, r2
    ioposition = 0x01U << position;
 8002bca:	f04f 0a01 	mov.w	sl, #1
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8002bce:	4689      	mov	r9, r1
 8002bd0:	e004      	b.n	8002bdc <HAL_GPIO_Init+0x20>
  for(position = 0U; position < GPIO_NUMBER; position++)
 8002bd2:	3301      	adds	r3, #1
 8002bd4:	2b10      	cmp	r3, #16
 8002bd6:	f102 0202 	add.w	r2, r2, #2
 8002bda:	d078      	beq.n	8002cce <HAL_GPIO_Init+0x112>
    ioposition = 0x01U << position;
 8002bdc:	fa0a f103 	lsl.w	r1, sl, r3
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8002be0:	ea01 0b04 	and.w	fp, r1, r4
    if(iocurrent == ioposition)
 8002be4:	43a1      	bics	r1, r4
 8002be6:	d1f4      	bne.n	8002bd2 <HAL_GPIO_Init+0x16>
      if(((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || \
 8002be8:	f8d9 c004 	ldr.w	ip, [r9, #4]
 8002bec:	f00c 0103 	and.w	r1, ip, #3
 8002bf0:	1e4d      	subs	r5, r1, #1
 8002bf2:	2d01      	cmp	r5, #1
 8002bf4:	d96e      	bls.n	8002cd4 <HAL_GPIO_Init+0x118>
      if((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
 8002bf6:	2903      	cmp	r1, #3
 8002bf8:	f040 80ae 	bne.w	8002d58 <HAL_GPIO_Init+0x19c>
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
 8002bfc:	4091      	lsls	r1, r2
 8002bfe:	43cd      	mvns	r5, r1
      temp = GPIOx->MODER;
 8002c00:	6807      	ldr	r7, [r0, #0]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 8002c02:	403d      	ands	r5, r7
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8002c04:	4329      	orrs	r1, r5
      if((GPIO_Init->Mode & EXTI_MODE) != 0x00U)
 8002c06:	f41c 3f40 	tst.w	ip, #196608	; 0x30000
      GPIOx->MODER = temp;
 8002c0a:	6001      	str	r1, [r0, #0]
      if((GPIO_Init->Mode & EXTI_MODE) != 0x00U)
 8002c0c:	d0e1      	beq.n	8002bd2 <HAL_GPIO_Init+0x16>
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8002c0e:	4d5f      	ldr	r5, [pc, #380]	; (8002d8c <HAL_GPIO_Init+0x1d0>)
 8002c10:	2100      	movs	r1, #0
 8002c12:	9103      	str	r1, [sp, #12]
 8002c14:	6c69      	ldr	r1, [r5, #68]	; 0x44
 8002c16:	f441 4180 	orr.w	r1, r1, #16384	; 0x4000
 8002c1a:	6469      	str	r1, [r5, #68]	; 0x44
 8002c1c:	6c69      	ldr	r1, [r5, #68]	; 0x44
 8002c1e:	f401 4180 	and.w	r1, r1, #16384	; 0x4000
 8002c22:	9103      	str	r1, [sp, #12]
 8002c24:	9903      	ldr	r1, [sp, #12]
        temp = SYSCFG->EXTICR[position >> 2U];
 8002c26:	f023 0103 	bic.w	r1, r3, #3
 8002c2a:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
 8002c2e:	f501 319c 	add.w	r1, r1, #79872	; 0x13800
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
 8002c32:	f003 0703 	and.w	r7, r3, #3
        temp = SYSCFG->EXTICR[position >> 2U];
 8002c36:	f8d1 e008 	ldr.w	lr, [r1, #8]
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
 8002c3a:	00bf      	lsls	r7, r7, #2
 8002c3c:	250f      	movs	r5, #15
 8002c3e:	40bd      	lsls	r5, r7
 8002c40:	ea2e 0805 	bic.w	r8, lr, r5
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 8002c44:	4d52      	ldr	r5, [pc, #328]	; (8002d90 <HAL_GPIO_Init+0x1d4>)
 8002c46:	42a8      	cmp	r0, r5
 8002c48:	d017      	beq.n	8002c7a <HAL_GPIO_Init+0xbe>
 8002c4a:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8002c4e:	42a8      	cmp	r0, r5
 8002c50:	f000 8086 	beq.w	8002d60 <HAL_GPIO_Init+0x1a4>
 8002c54:	4d4f      	ldr	r5, [pc, #316]	; (8002d94 <HAL_GPIO_Init+0x1d8>)
 8002c56:	42a8      	cmp	r0, r5
 8002c58:	f000 8087 	beq.w	8002d6a <HAL_GPIO_Init+0x1ae>
 8002c5c:	4d4e      	ldr	r5, [pc, #312]	; (8002d98 <HAL_GPIO_Init+0x1dc>)
 8002c5e:	42a8      	cmp	r0, r5
 8002c60:	f000 808a 	beq.w	8002d78 <HAL_GPIO_Init+0x1bc>
 8002c64:	4d4d      	ldr	r5, [pc, #308]	; (8002d9c <HAL_GPIO_Init+0x1e0>)
 8002c66:	42a8      	cmp	r0, r5
 8002c68:	bf0c      	ite	eq
 8002c6a:	f04f 0e04 	moveq.w	lr, #4
 8002c6e:	f04f 0e07 	movne.w	lr, #7
 8002c72:	fa0e f707 	lsl.w	r7, lr, r7
 8002c76:	ea48 0807 	orr.w	r8, r8, r7
        SYSCFG->EXTICR[position >> 2U] = temp;
 8002c7a:	f8c1 8008 	str.w	r8, [r1, #8]
        temp = EXTI->RTSR;
 8002c7e:	68b1      	ldr	r1, [r6, #8]
        temp &= ~((uint32_t)iocurrent);
 8002c80:	ea6f 070b 	mvn.w	r7, fp
        if((GPIO_Init->Mode & TRIGGER_RISING) != 0x00U)
 8002c84:	f41c 1f80 	tst.w	ip, #1048576	; 0x100000
        temp &= ~((uint32_t)iocurrent);
 8002c88:	bf0c      	ite	eq
 8002c8a:	4039      	andeq	r1, r7
        {
          temp |= iocurrent;
 8002c8c:	ea4b 0101 	orrne.w	r1, fp, r1
        }
        EXTI->RTSR = temp;
 8002c90:	60b1      	str	r1, [r6, #8]

        temp = EXTI->FTSR;
 8002c92:	68f5      	ldr	r5, [r6, #12]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00U)
 8002c94:	f41c 1f00 	tst.w	ip, #2097152	; 0x200000
        temp &= ~((uint32_t)iocurrent);
 8002c98:	bf0c      	ite	eq
 8002c9a:	403d      	andeq	r5, r7
        {
          temp |= iocurrent;
 8002c9c:	ea4b 0505 	orrne.w	r5, fp, r5
        }
        EXTI->FTSR = temp;
 8002ca0:	60f5      	str	r5, [r6, #12]

        temp = EXTI->EMR;
 8002ca2:	6875      	ldr	r5, [r6, #4]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & EXTI_EVT) != 0x00U)
 8002ca4:	f41c 3f00 	tst.w	ip, #131072	; 0x20000
        temp &= ~((uint32_t)iocurrent);
 8002ca8:	bf0c      	ite	eq
 8002caa:	403d      	andeq	r5, r7
        {
          temp |= iocurrent;
 8002cac:	ea4b 0505 	orrne.w	r5, fp, r5
        }
        EXTI->EMR = temp;
 8002cb0:	6075      	str	r5, [r6, #4]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 8002cb2:	6831      	ldr	r1, [r6, #0]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & EXTI_IT) != 0x00U)
 8002cb4:	f41c 3f80 	tst.w	ip, #65536	; 0x10000
  for(position = 0U; position < GPIO_NUMBER; position++)
 8002cb8:	f103 0301 	add.w	r3, r3, #1
        temp &= ~((uint32_t)iocurrent);
 8002cbc:	bf0c      	ite	eq
 8002cbe:	4039      	andeq	r1, r7
        {
          temp |= iocurrent;
 8002cc0:	ea4b 0101 	orrne.w	r1, fp, r1
  for(position = 0U; position < GPIO_NUMBER; position++)
 8002cc4:	2b10      	cmp	r3, #16
        }
        EXTI->IMR = temp;
 8002cc6:	6031      	str	r1, [r6, #0]
  for(position = 0U; position < GPIO_NUMBER; position++)
 8002cc8:	f102 0202 	add.w	r2, r2, #2
 8002ccc:	d186      	bne.n	8002bdc <HAL_GPIO_Init+0x20>
      }
    }
  }
}
 8002cce:	b005      	add	sp, #20
 8002cd0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        temp |= (GPIO_Init->Speed << (position * 2U));
 8002cd4:	f8d9 500c 	ldr.w	r5, [r9, #12]
        temp = GPIOx->OSPEEDR; 
 8002cd8:	6887      	ldr	r7, [r0, #8]
        temp |= (GPIO_Init->Speed << (position * 2U));
 8002cda:	fa05 f802 	lsl.w	r8, r5, r2
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
 8002cde:	2503      	movs	r5, #3
 8002ce0:	fa05 fe02 	lsl.w	lr, r5, r2
 8002ce4:	ea27 070e 	bic.w	r7, r7, lr
        temp |= (GPIO_Init->Speed << (position * 2U));
 8002ce8:	ea48 0707 	orr.w	r7, r8, r7
        GPIOx->OSPEEDR = temp;
 8002cec:	6087      	str	r7, [r0, #8]
        temp = GPIOx->OTYPER;
 8002cee:	6847      	ldr	r7, [r0, #4]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
 8002cf0:	ea6f 050e 	mvn.w	r5, lr
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 8002cf4:	ea27 0e0b 	bic.w	lr, r7, fp
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 8002cf8:	f3cc 1700 	ubfx	r7, ip, #4, #1
 8002cfc:	409f      	lsls	r7, r3
 8002cfe:	ea47 070e 	orr.w	r7, r7, lr
        GPIOx->OTYPER = temp;
 8002d02:	6047      	str	r7, [r0, #4]
        temp = GPIOx->PUPDR;
 8002d04:	68c7      	ldr	r7, [r0, #12]
        temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));
 8002d06:	ea07 0e05 	and.w	lr, r7, r5
        temp |= ((GPIO_Init->Pull) << (position * 2U));
 8002d0a:	f8d9 7008 	ldr.w	r7, [r9, #8]
 8002d0e:	4097      	lsls	r7, r2
 8002d10:	ea47 070e 	orr.w	r7, r7, lr
      if((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 8002d14:	2902      	cmp	r1, #2
        GPIOx->PUPDR = temp;
 8002d16:	60c7      	str	r7, [r0, #12]
      if((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 8002d18:	fa01 f102 	lsl.w	r1, r1, r2
 8002d1c:	f47f af70 	bne.w	8002c00 <HAL_GPIO_Init+0x44>
        temp = GPIOx->AFR[position >> 3U];
 8002d20:	ea4f 0ed3 	mov.w	lr, r3, lsr #3
 8002d24:	eb00 0e8e 	add.w	lr, r0, lr, lsl #2
        temp &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;
 8002d28:	f003 0807 	and.w	r8, r3, #7
        temp = GPIOx->AFR[position >> 3U];
 8002d2c:	f8de 7020 	ldr.w	r7, [lr, #32]
 8002d30:	9700      	str	r7, [sp, #0]
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & 0x07U) * 4U));
 8002d32:	f8d9 7010 	ldr.w	r7, [r9, #16]
        temp &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;
 8002d36:	ea4f 0888 	mov.w	r8, r8, lsl #2
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & 0x07U) * 4U));
 8002d3a:	fa07 f708 	lsl.w	r7, r7, r8
 8002d3e:	9701      	str	r7, [sp, #4]
        temp &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;
 8002d40:	270f      	movs	r7, #15
 8002d42:	fa07 f808 	lsl.w	r8, r7, r8
 8002d46:	9f00      	ldr	r7, [sp, #0]
 8002d48:	ea27 0808 	bic.w	r8, r7, r8
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & 0x07U) * 4U));
 8002d4c:	9f01      	ldr	r7, [sp, #4]
 8002d4e:	ea47 0708 	orr.w	r7, r7, r8
        GPIOx->AFR[position >> 3U] = temp;
 8002d52:	f8ce 7020 	str.w	r7, [lr, #32]
 8002d56:	e753      	b.n	8002c00 <HAL_GPIO_Init+0x44>
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
 8002d58:	2503      	movs	r5, #3
 8002d5a:	4095      	lsls	r5, r2
 8002d5c:	43ed      	mvns	r5, r5
 8002d5e:	e7d1      	b.n	8002d04 <HAL_GPIO_Init+0x148>
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 8002d60:	fa0a f707 	lsl.w	r7, sl, r7
 8002d64:	ea48 0807 	orr.w	r8, r8, r7
 8002d68:	e787      	b.n	8002c7a <HAL_GPIO_Init+0xbe>
 8002d6a:	f04f 0e02 	mov.w	lr, #2
 8002d6e:	fa0e f707 	lsl.w	r7, lr, r7
 8002d72:	ea48 0807 	orr.w	r8, r8, r7
 8002d76:	e780      	b.n	8002c7a <HAL_GPIO_Init+0xbe>
 8002d78:	f04f 0e03 	mov.w	lr, #3
 8002d7c:	fa0e f707 	lsl.w	r7, lr, r7
 8002d80:	ea48 0807 	orr.w	r8, r8, r7
 8002d84:	e779      	b.n	8002c7a <HAL_GPIO_Init+0xbe>
 8002d86:	bf00      	nop
 8002d88:	40013c00 	.word	0x40013c00
 8002d8c:	40023800 	.word	0x40023800
 8002d90:	40020000 	.word	0x40020000
 8002d94:	40020800 	.word	0x40020800
 8002d98:	40020c00 	.word	0x40020c00
 8002d9c:	40021000 	.word	0x40021000

08002da0 <HAL_I2S_MspInit>:
  UNUSED(hi2s);

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_I2S_MspInit could be implemented in the user file
   */
}
 8002da0:	4770      	bx	lr
 8002da2:	bf00      	nop

08002da4 <HAL_I2S_Init>:
  if (hi2s == NULL)
 8002da4:	2800      	cmp	r0, #0
 8002da6:	f000 8088 	beq.w	8002eba <HAL_I2S_Init+0x116>
{
 8002daa:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if (hi2s->State == HAL_I2S_STATE_RESET)
 8002dac:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
 8002db0:	4604      	mov	r4, r0
 8002db2:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8002db6:	2b00      	cmp	r3, #0
 8002db8:	d074      	beq.n	8002ea4 <HAL_I2S_Init+0x100>
  CLEAR_BIT(hi2s->Instance->I2SCFGR, (SPI_I2SCFGR_CHLEN | SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CKPOL | \
 8002dba:	6821      	ldr	r1, [r4, #0]
  if (hi2s->Init.AudioFreq != I2S_AUDIOFREQ_DEFAULT)
 8002dbc:	6963      	ldr	r3, [r4, #20]
  hi2s->State = HAL_I2S_STATE_BUSY;
 8002dbe:	2202      	movs	r2, #2
 8002dc0:	f884 2041 	strb.w	r2, [r4, #65]	; 0x41
  CLEAR_BIT(hi2s->Instance->I2SCFGR, (SPI_I2SCFGR_CHLEN | SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CKPOL | \
 8002dc4:	69c8      	ldr	r0, [r1, #28]
 8002dc6:	f420 607b 	bic.w	r0, r0, #4016	; 0xfb0
 8002dca:	f020 000f 	bic.w	r0, r0, #15
  if (hi2s->Init.AudioFreq != I2S_AUDIOFREQ_DEFAULT)
 8002dce:	4293      	cmp	r3, r2
  CLEAR_BIT(hi2s->Instance->I2SCFGR, (SPI_I2SCFGR_CHLEN | SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CKPOL | \
 8002dd0:	61c8      	str	r0, [r1, #28]
  hi2s->Instance->I2SPR = 0x0002U;
 8002dd2:	620a      	str	r2, [r1, #32]
  if (hi2s->Init.AudioFreq != I2S_AUDIOFREQ_DEFAULT)
 8002dd4:	d064      	beq.n	8002ea0 <HAL_I2S_Init+0xfc>
    if (hi2s->Init.Standard <= I2S_STANDARD_LSB)
 8002dd6:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
    if (hi2s->Init.DataFormat == I2S_DATAFORMAT_16B)
 8002dda:	2b00      	cmp	r3, #0
 8002ddc:	bf0b      	itete	eq
 8002dde:	2320      	moveq	r3, #32
 8002de0:	2340      	movne	r3, #64	; 0x40
 8002de2:	2510      	moveq	r5, #16
 8002de4:	2520      	movne	r5, #32
    i2sclk = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_I2S);
 8002de6:	2001      	movs	r0, #1
      packetlength = packetlength * 2U;
 8002de8:	2a20      	cmp	r2, #32
 8002dea:	bf98      	it	ls
 8002dec:	461d      	movls	r5, r3
    i2sclk = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_I2S);
 8002dee:	f000 fe87 	bl	8003b00 <HAL_RCCEx_GetPeriphCLKFreq>
    if (hi2s->Init.MCLKOutput == I2S_MCLKOUTPUT_ENABLE)
 8002df2:	6922      	ldr	r2, [r4, #16]
 8002df4:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
 8002df8:	d05b      	beq.n	8002eb2 <HAL_I2S_Init+0x10e>
      tmp = (uint32_t)(((((i2sclk / packetlength) * 10U) / hi2s->Init.AudioFreq)) + 5U);
 8002dfa:	fbb0 f0f5 	udiv	r0, r0, r5
 8002dfe:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8002e02:	6961      	ldr	r1, [r4, #20]
 8002e04:	0043      	lsls	r3, r0, #1
 8002e06:	fbb3 f3f1 	udiv	r3, r3, r1
    tmp = tmp / 10U;
 8002e0a:	492e      	ldr	r1, [pc, #184]	; (8002ec4 <HAL_I2S_Init+0x120>)
      tmp = (uint32_t)(((((i2sclk / packetlength) * 10U) / hi2s->Init.AudioFreq)) + 5U);
 8002e0c:	3305      	adds	r3, #5
    tmp = tmp / 10U;
 8002e0e:	fba1 1303 	umull	r1, r3, r1, r3
    i2sdiv = (uint32_t)((tmp - i2sodd) / 2U);
 8002e12:	0918      	lsrs	r0, r3, #4
  if ((i2sdiv < 2U) || (i2sdiv > 0xFFU))
 8002e14:	1e81      	subs	r1, r0, #2
 8002e16:	29fd      	cmp	r1, #253	; 0xfd
    i2sdiv = (uint32_t)((tmp - i2sodd) / 2U);
 8002e18:	f3c3 03c0 	ubfx	r3, r3, #3, #1
  if ((i2sdiv < 2U) || (i2sdiv > 0xFFU))
 8002e1c:	d905      	bls.n	8002e2a <HAL_I2S_Init+0x86>
    SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_PRESCALER);
 8002e1e:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8002e20:	f043 0310 	orr.w	r3, r3, #16
    return  HAL_ERROR;
 8002e24:	2001      	movs	r0, #1
    SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_PRESCALER);
 8002e26:	6463      	str	r3, [r4, #68]	; 0x44
}
 8002e28:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  hi2s->Instance->I2SPR = (uint32_t)((uint32_t)i2sdiv | (uint32_t)(i2sodd | (uint32_t)hi2s->Init.MCLKOutput));
 8002e2a:	6821      	ldr	r1, [r4, #0]
 8002e2c:	ea40 2303 	orr.w	r3, r0, r3, lsl #8
 8002e30:	4313      	orrs	r3, r2
  MODIFY_REG(hi2s->Instance->I2SCFGR, (SPI_I2SCFGR_CHLEN | SPI_I2SCFGR_DATLEN | \
 8002e32:	e9d4 7001 	ldrd	r7, r0, [r4, #4]
  hi2s->Instance->I2SPR = (uint32_t)((uint32_t)i2sdiv | (uint32_t)(i2sodd | (uint32_t)hi2s->Init.MCLKOutput));
 8002e36:	620b      	str	r3, [r1, #32]
  MODIFY_REG(hi2s->Instance->I2SCFGR, (SPI_I2SCFGR_CHLEN | SPI_I2SCFGR_DATLEN | \
 8002e38:	69cb      	ldr	r3, [r1, #28]
 8002e3a:	4e23      	ldr	r6, [pc, #140]	; (8002ec8 <HAL_I2S_Init+0x124>)
 8002e3c:	68e2      	ldr	r2, [r4, #12]
 8002e3e:	ea47 0500 	orr.w	r5, r7, r0
 8002e42:	4033      	ands	r3, r6
 8002e44:	432b      	orrs	r3, r5
 8002e46:	69a5      	ldr	r5, [r4, #24]
 8002e48:	4313      	orrs	r3, r2
 8002e4a:	432b      	orrs	r3, r5
 8002e4c:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8002e50:	61cb      	str	r3, [r1, #28]
  if (hi2s->Init.FullDuplexMode == I2S_FULLDUPLEXMODE_ENABLE)
 8002e52:	6a23      	ldr	r3, [r4, #32]
 8002e54:	2b01      	cmp	r3, #1
 8002e56:	d11d      	bne.n	8002e94 <HAL_I2S_Init+0xf0>
    CLEAR_BIT(I2SxEXT(hi2s->Instance)->I2SCFGR, (SPI_I2SCFGR_CHLEN | SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CKPOL | \
 8002e58:	4b1c      	ldr	r3, [pc, #112]	; (8002ecc <HAL_I2S_Init+0x128>)
    tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD    | \
 8002e5a:	4302      	orrs	r2, r0
    CLEAR_BIT(I2SxEXT(hi2s->Instance)->I2SCFGR, (SPI_I2SCFGR_CHLEN | SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CKPOL | \
 8002e5c:	481c      	ldr	r0, [pc, #112]	; (8002ed0 <HAL_I2S_Init+0x12c>)
 8002e5e:	4299      	cmp	r1, r3
 8002e60:	bf18      	it	ne
 8002e62:	f04f 2040 	movne.w	r0, #1073758208	; 0x40004000
    if ((hi2s->Init.Mode == I2S_MODE_MASTER_TX) || (hi2s->Init.Mode == I2S_MODE_SLAVE_TX))
 8002e66:	f437 7300 	bics.w	r3, r7, #512	; 0x200
    CLEAR_BIT(I2SxEXT(hi2s->Instance)->I2SCFGR, (SPI_I2SCFGR_CHLEN | SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CKPOL | \
 8002e6a:	69c3      	ldr	r3, [r0, #28]
 8002e6c:	ea06 0603 	and.w	r6, r6, r3
    hi2s->IrqHandlerISR = HAL_I2SEx_FullDuplex_IRQHandler;
 8002e70:	4b18      	ldr	r3, [pc, #96]	; (8002ed4 <HAL_I2S_Init+0x130>)
 8002e72:	6363      	str	r3, [r4, #52]	; 0x34
    I2SxEXT(hi2s->Instance)->I2SPR = 2U;
 8002e74:	f04f 0302 	mov.w	r3, #2
    CLEAR_BIT(I2SxEXT(hi2s->Instance)->I2SCFGR, (SPI_I2SCFGR_CHLEN | SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CKPOL | \
 8002e78:	61c6      	str	r6, [r0, #28]
    I2SxEXT(hi2s->Instance)->I2SPR = 2U;
 8002e7a:	6203      	str	r3, [r0, #32]
    if ((hi2s->Init.Mode == I2S_MODE_MASTER_TX) || (hi2s->Init.Mode == I2S_MODE_SLAVE_TX))
 8002e7c:	bf0c      	ite	eq
 8002e7e:	f44f 7380 	moveq.w	r3, #256	; 0x100
 8002e82:	2300      	movne	r3, #0
    tmpreg = I2SxEXT(hi2s->Instance)->I2SCFGR;
 8002e84:	69c1      	ldr	r1, [r0, #28]
    tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD    | \
 8002e86:	4313      	orrs	r3, r2
 8002e88:	432b      	orrs	r3, r5
 8002e8a:	430b      	orrs	r3, r1
 8002e8c:	b29b      	uxth	r3, r3
    WRITE_REG(I2SxEXT(hi2s->Instance)->I2SCFGR, tmpreg);
 8002e8e:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8002e92:	61c3      	str	r3, [r0, #28]
  hi2s->ErrorCode = HAL_I2S_ERROR_NONE;
 8002e94:	2000      	movs	r0, #0
  hi2s->State     = HAL_I2S_STATE_READY;
 8002e96:	2301      	movs	r3, #1
  hi2s->ErrorCode = HAL_I2S_ERROR_NONE;
 8002e98:	6460      	str	r0, [r4, #68]	; 0x44
  hi2s->State     = HAL_I2S_STATE_READY;
 8002e9a:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
}
 8002e9e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  hi2s->Instance->I2SPR = (uint32_t)((uint32_t)i2sdiv | (uint32_t)(i2sodd | (uint32_t)hi2s->Init.MCLKOutput));
 8002ea0:	6922      	ldr	r2, [r4, #16]
 8002ea2:	e7c5      	b.n	8002e30 <HAL_I2S_Init+0x8c>
    hi2s->IrqHandlerISR = I2S_IRQHandler;
 8002ea4:	4b0c      	ldr	r3, [pc, #48]	; (8002ed8 <HAL_I2S_Init+0x134>)
    hi2s->Lock = HAL_UNLOCKED;
 8002ea6:	f880 2040 	strb.w	r2, [r0, #64]	; 0x40
    hi2s->IrqHandlerISR = I2S_IRQHandler;
 8002eaa:	6343      	str	r3, [r0, #52]	; 0x34
    HAL_I2S_MspInit(hi2s);
 8002eac:	f7ff ff78 	bl	8002da0 <HAL_I2S_MspInit>
 8002eb0:	e783      	b.n	8002dba <HAL_I2S_Init+0x16>
      if (hi2s->Init.DataFormat != I2S_DATAFORMAT_16B)
 8002eb2:	68e3      	ldr	r3, [r4, #12]
 8002eb4:	b11b      	cbz	r3, 8002ebe <HAL_I2S_Init+0x11a>
        tmp = (uint32_t)(((((i2sclk / (packetlength * 4U)) * 10U) / hi2s->Init.AudioFreq)) + 5U);
 8002eb6:	00ad      	lsls	r5, r5, #2
 8002eb8:	e79f      	b.n	8002dfa <HAL_I2S_Init+0x56>
    return HAL_ERROR;
 8002eba:	2001      	movs	r0, #1
}
 8002ebc:	4770      	bx	lr
        tmp = (uint32_t)(((((i2sclk / (packetlength * 8U)) * 10U) / hi2s->Init.AudioFreq)) + 5U);
 8002ebe:	00ed      	lsls	r5, r5, #3
 8002ec0:	e79b      	b.n	8002dfa <HAL_I2S_Init+0x56>
 8002ec2:	bf00      	nop
 8002ec4:	cccccccd 	.word	0xcccccccd
 8002ec8:	fffff040 	.word	0xfffff040
 8002ecc:	40003800 	.word	0x40003800
 8002ed0:	40003400 	.word	0x40003400
 8002ed4:	08003135 	.word	0x08003135
 8002ed8:	08002ffd 	.word	0x08002ffd

08002edc <HAL_I2S_Receive_DMA>:
  */
HAL_StatusTypeDef HAL_I2S_Receive_DMA(I2S_HandleTypeDef *hi2s, uint16_t *pData, uint16_t Size)
{
  uint32_t tmpreg_cfgr;

  if ((pData == NULL) || (Size == 0U))
 8002edc:	2900      	cmp	r1, #0
 8002ede:	d04f      	beq.n	8002f80 <HAL_I2S_Receive_DMA+0xa4>
 8002ee0:	2a00      	cmp	r2, #0
 8002ee2:	d04d      	beq.n	8002f80 <HAL_I2S_Receive_DMA+0xa4>
{
 8002ee4:	b530      	push	{r4, r5, lr}
  {
    return  HAL_ERROR;
  }

  /* Process Locked */
  __HAL_LOCK(hi2s);
 8002ee6:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
 8002eea:	2b01      	cmp	r3, #1
{
 8002eec:	b083      	sub	sp, #12
 8002eee:	4604      	mov	r4, r0
  __HAL_LOCK(hi2s);
 8002ef0:	d04d      	beq.n	8002f8e <HAL_I2S_Receive_DMA+0xb2>
 8002ef2:	2301      	movs	r3, #1
 8002ef4:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40

  if (hi2s->State != HAL_I2S_STATE_READY)
 8002ef8:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
 8002efc:	2b01      	cmp	r3, #1
 8002efe:	d148      	bne.n	8002f92 <HAL_I2S_Receive_DMA+0xb6>
    __HAL_UNLOCK(hi2s);
    return HAL_BUSY;
  }

  /* Set state and reset error code */
  hi2s->State = HAL_I2S_STATE_BUSY_RX;
 8002f00:	2304      	movs	r3, #4
 8002f02:	f880 3041 	strb.w	r3, [r0, #65]	; 0x41
  hi2s->ErrorCode = HAL_I2S_ERROR_NONE;
  hi2s->pRxBuffPtr = pData;

  tmpreg_cfgr = hi2s->Instance->I2SCFGR & (SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CHLEN);
 8002f06:	6805      	ldr	r5, [r0, #0]
  hi2s->ErrorCode = HAL_I2S_ERROR_NONE;
 8002f08:	2300      	movs	r3, #0
 8002f0a:	6443      	str	r3, [r0, #68]	; 0x44
  tmpreg_cfgr = hi2s->Instance->I2SCFGR & (SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CHLEN);
 8002f0c:	69eb      	ldr	r3, [r5, #28]
  hi2s->pRxBuffPtr = pData;
 8002f0e:	62c1      	str	r1, [r0, #44]	; 0x2c
  tmpreg_cfgr = hi2s->Instance->I2SCFGR & (SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CHLEN);
 8002f10:	f003 0307 	and.w	r3, r3, #7

  if ((tmpreg_cfgr == I2S_DATAFORMAT_24B) || (tmpreg_cfgr == I2S_DATAFORMAT_32B))
 8002f14:	2b03      	cmp	r3, #3
 8002f16:	d035      	beq.n	8002f84 <HAL_I2S_Receive_DMA+0xa8>
 8002f18:	2b05      	cmp	r3, #5
 8002f1a:	d033      	beq.n	8002f84 <HAL_I2S_Receive_DMA+0xa8>
    hi2s->RxXferSize = (Size << 1U);
    hi2s->RxXferCount = (Size << 1U);
  }
  else
  {
    hi2s->RxXferSize = Size;
 8002f1c:	8602      	strh	r2, [r0, #48]	; 0x30
    hi2s->RxXferCount = Size;
 8002f1e:	8642      	strh	r2, [r0, #50]	; 0x32
  }

  /* Set the I2S Rx DMA Half transfer complete callback */
  hi2s->hdmarx->XferHalfCpltCallback = I2S_DMARxHalfCplt;
 8002f20:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 8002f22:	4b25      	ldr	r3, [pc, #148]	; (8002fb8 <HAL_I2S_Receive_DMA+0xdc>)
 8002f24:	6403      	str	r3, [r0, #64]	; 0x40

  /* Set the I2S Rx DMA transfer complete callback */
  hi2s->hdmarx->XferCpltCallback = I2S_DMARxCplt;
 8002f26:	4b25      	ldr	r3, [pc, #148]	; (8002fbc <HAL_I2S_Receive_DMA+0xe0>)
 8002f28:	63c3      	str	r3, [r0, #60]	; 0x3c

  /* Set the DMA error callback */
  hi2s->hdmarx->XferErrorCallback = I2S_DMAError;
 8002f2a:	4b25      	ldr	r3, [pc, #148]	; (8002fc0 <HAL_I2S_Receive_DMA+0xe4>)
 8002f2c:	64c3      	str	r3, [r0, #76]	; 0x4c

  /* Check if Master Receiver mode is selected */
  if ((hi2s->Instance->I2SCFGR & SPI_I2SCFGR_I2SCFG) == I2S_MODE_MASTER_RX)
 8002f2e:	69eb      	ldr	r3, [r5, #28]
 8002f30:	f403 7340 	and.w	r3, r3, #768	; 0x300
 8002f34:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 8002f38:	d106      	bne.n	8002f48 <HAL_I2S_Receive_DMA+0x6c>
  {
    /* Clear the Overrun Flag by a read operation to the SPI_DR register followed by a read
    access to the SPI_SR register. */
    __HAL_I2S_CLEAR_OVRFLAG(hi2s);
 8002f3a:	2300      	movs	r3, #0
 8002f3c:	9301      	str	r3, [sp, #4]
 8002f3e:	68eb      	ldr	r3, [r5, #12]
 8002f40:	9301      	str	r3, [sp, #4]
 8002f42:	68ab      	ldr	r3, [r5, #8]
 8002f44:	9301      	str	r3, [sp, #4]
 8002f46:	9b01      	ldr	r3, [sp, #4]
  }

  /* Enable the Rx DMA Stream/Channel */
  if (HAL_OK != HAL_DMA_Start_IT(hi2s->hdmarx, (uint32_t)&hi2s->Instance->DR, (uint32_t)hi2s->pRxBuffPtr,
                                 hi2s->RxXferSize))
 8002f48:	8e23      	ldrh	r3, [r4, #48]	; 0x30
  if (HAL_OK != HAL_DMA_Start_IT(hi2s->hdmarx, (uint32_t)&hi2s->Instance->DR, (uint32_t)hi2s->pRxBuffPtr,
 8002f4a:	460a      	mov	r2, r1
 8002f4c:	b29b      	uxth	r3, r3
 8002f4e:	f105 010c 	add.w	r1, r5, #12
 8002f52:	f7ff fd03 	bl	800295c <HAL_DMA_Start_IT>
 8002f56:	bb10      	cbnz	r0, 8002f9e <HAL_I2S_Receive_DMA+0xc2>
    __HAL_UNLOCK(hi2s);
    return HAL_ERROR;
  }

  /* Check if the I2S is already enabled */
  if (HAL_IS_BIT_CLR(hi2s->Instance->I2SCFGR, SPI_I2SCFGR_I2SE))
 8002f58:	6823      	ldr	r3, [r4, #0]
 8002f5a:	69da      	ldr	r2, [r3, #28]
 8002f5c:	0551      	lsls	r1, r2, #21
 8002f5e:	d403      	bmi.n	8002f68 <HAL_I2S_Receive_DMA+0x8c>
  {
    /* Enable I2S peripheral */
    __HAL_I2S_ENABLE(hi2s);
 8002f60:	69da      	ldr	r2, [r3, #28]
 8002f62:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8002f66:	61da      	str	r2, [r3, #28]
  }

  /* Check if the I2S Rx request is already enabled */
  if (HAL_IS_BIT_CLR(hi2s->Instance->CR2, SPI_CR2_RXDMAEN))
 8002f68:	685a      	ldr	r2, [r3, #4]
 8002f6a:	07d2      	lsls	r2, r2, #31
 8002f6c:	d403      	bmi.n	8002f76 <HAL_I2S_Receive_DMA+0x9a>
  {
    /* Enable Rx DMA Request */
    SET_BIT(hi2s->Instance->CR2, SPI_CR2_RXDMAEN);
 8002f6e:	685a      	ldr	r2, [r3, #4]
 8002f70:	f042 0201 	orr.w	r2, r2, #1
 8002f74:	605a      	str	r2, [r3, #4]
  }

  __HAL_UNLOCK(hi2s);
 8002f76:	2300      	movs	r3, #0
 8002f78:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
  return HAL_OK;
}
 8002f7c:	b003      	add	sp, #12
 8002f7e:	bd30      	pop	{r4, r5, pc}
    return  HAL_ERROR;
 8002f80:	2001      	movs	r0, #1
}
 8002f82:	4770      	bx	lr
    hi2s->RxXferSize = (Size << 1U);
 8002f84:	0053      	lsls	r3, r2, #1
 8002f86:	b29b      	uxth	r3, r3
 8002f88:	8623      	strh	r3, [r4, #48]	; 0x30
    hi2s->RxXferCount = (Size << 1U);
 8002f8a:	8663      	strh	r3, [r4, #50]	; 0x32
 8002f8c:	e7c8      	b.n	8002f20 <HAL_I2S_Receive_DMA+0x44>
  __HAL_LOCK(hi2s);
 8002f8e:	2002      	movs	r0, #2
 8002f90:	e7f4      	b.n	8002f7c <HAL_I2S_Receive_DMA+0xa0>
    __HAL_UNLOCK(hi2s);
 8002f92:	2300      	movs	r3, #0
 8002f94:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
    return HAL_BUSY;
 8002f98:	2002      	movs	r0, #2
}
 8002f9a:	b003      	add	sp, #12
 8002f9c:	bd30      	pop	{r4, r5, pc}
    SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_DMA);
 8002f9e:	6c63      	ldr	r3, [r4, #68]	; 0x44
    hi2s->State = HAL_I2S_STATE_READY;
 8002fa0:	2201      	movs	r2, #1
    SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_DMA);
 8002fa2:	f043 0308 	orr.w	r3, r3, #8
    __HAL_UNLOCK(hi2s);
 8002fa6:	2100      	movs	r1, #0
    return HAL_ERROR;
 8002fa8:	4610      	mov	r0, r2
    SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_DMA);
 8002faa:	6463      	str	r3, [r4, #68]	; 0x44
    hi2s->State = HAL_I2S_STATE_READY;
 8002fac:	f884 2041 	strb.w	r2, [r4, #65]	; 0x41
    __HAL_UNLOCK(hi2s);
 8002fb0:	f884 1040 	strb.w	r1, [r4, #64]	; 0x40
}
 8002fb4:	b003      	add	sp, #12
 8002fb6:	bd30      	pop	{r4, r5, pc}
 8002fb8:	08002fc9 	.word	0x08002fc9
 8002fbc:	08002fd5 	.word	0x08002fd5
 8002fc0:	08003105 	.word	0x08003105

08002fc4 <HAL_I2S_TxCpltCallback>:
 8002fc4:	4770      	bx	lr
 8002fc6:	bf00      	nop

08002fc8 <I2S_DMARxHalfCplt>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *                the configuration information for the specified DMA module.
  * @retval None
  */
static void I2S_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
{
 8002fc8:	b508      	push	{r3, lr}

  /* Call user Rx half complete callback */
#if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
  hi2s->RxHalfCpltCallback(hi2s);
#else
  HAL_I2S_RxHalfCpltCallback(hi2s);
 8002fca:	6b80      	ldr	r0, [r0, #56]	; 0x38
 8002fcc:	f7ff fa0a 	bl	80023e4 <HAL_I2S_RxHalfCpltCallback>
#endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
}
 8002fd0:	bd08      	pop	{r3, pc}
 8002fd2:	bf00      	nop

08002fd4 <I2S_DMARxCplt>:
{
 8002fd4:	b508      	push	{r3, lr}
  if (hdma->Init.Mode == DMA_NORMAL)
 8002fd6:	69c3      	ldr	r3, [r0, #28]
  I2S_HandleTypeDef *hi2s = (I2S_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent; /* Derogation MISRAC2012-Rule-11.5 */
 8002fd8:	6b80      	ldr	r0, [r0, #56]	; 0x38
  if (hdma->Init.Mode == DMA_NORMAL)
 8002fda:	b94b      	cbnz	r3, 8002ff0 <I2S_DMARxCplt+0x1c>
    CLEAR_BIT(hi2s->Instance->CR2, SPI_CR2_RXDMAEN);
 8002fdc:	6801      	ldr	r1, [r0, #0]
 8002fde:	684a      	ldr	r2, [r1, #4]
    hi2s->State = HAL_I2S_STATE_READY;
 8002fe0:	f04f 0c01 	mov.w	ip, #1
    CLEAR_BIT(hi2s->Instance->CR2, SPI_CR2_RXDMAEN);
 8002fe4:	f022 0201 	bic.w	r2, r2, #1
 8002fe8:	604a      	str	r2, [r1, #4]
    hi2s->RxXferCount = 0U;
 8002fea:	8643      	strh	r3, [r0, #50]	; 0x32
    hi2s->State = HAL_I2S_STATE_READY;
 8002fec:	f880 c041 	strb.w	ip, [r0, #65]	; 0x41
  HAL_I2S_RxCpltCallback(hi2s);
 8002ff0:	f7ff f916 	bl	8002220 <HAL_I2S_RxCpltCallback>
}
 8002ff4:	bd08      	pop	{r3, pc}
 8002ff6:	bf00      	nop

08002ff8 <HAL_I2S_ErrorCallback>:
 8002ff8:	4770      	bx	lr
 8002ffa:	bf00      	nop

08002ffc <I2S_IRQHandler>:
  * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
  *         the configuration information for I2S module
  * @retval None
  */
static void I2S_IRQHandler(I2S_HandleTypeDef *hi2s)
{
 8002ffc:	b510      	push	{r4, lr}
  __IO uint32_t i2ssr = hi2s->Instance->SR;
 8002ffe:	6803      	ldr	r3, [r0, #0]
{
 8003000:	b084      	sub	sp, #16
  __IO uint32_t i2ssr = hi2s->Instance->SR;
 8003002:	689a      	ldr	r2, [r3, #8]
 8003004:	9201      	str	r2, [sp, #4]

  if (hi2s->State == HAL_I2S_STATE_BUSY_RX)
 8003006:	f890 2041 	ldrb.w	r2, [r0, #65]	; 0x41
 800300a:	2a04      	cmp	r2, #4
{
 800300c:	4604      	mov	r4, r0
  if (hi2s->State == HAL_I2S_STATE_BUSY_RX)
 800300e:	d005      	beq.n	800301c <I2S_IRQHandler+0x20>
      HAL_I2S_ErrorCallback(hi2s);
#endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
    }
  }

  if (hi2s->State == HAL_I2S_STATE_BUSY_TX)
 8003010:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 8003014:	2b03      	cmp	r3, #3
 8003016:	d031      	beq.n	800307c <I2S_IRQHandler+0x80>
#else
      HAL_I2S_ErrorCallback(hi2s);
#endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
    }
  }
}
 8003018:	b004      	add	sp, #16
 800301a:	bd10      	pop	{r4, pc}
    if (((i2ssr & I2S_FLAG_RXNE) == I2S_FLAG_RXNE) && (__HAL_I2S_GET_IT_SOURCE(hi2s, I2S_IT_RXNE) != RESET))
 800301c:	9a01      	ldr	r2, [sp, #4]
 800301e:	07d1      	lsls	r1, r2, #31
 8003020:	d50f      	bpl.n	8003042 <I2S_IRQHandler+0x46>
 8003022:	685a      	ldr	r2, [r3, #4]
 8003024:	0652      	lsls	r2, r2, #25
 8003026:	d50c      	bpl.n	8003042 <I2S_IRQHandler+0x46>
  (*hi2s->pRxBuffPtr) = (uint16_t)hi2s->Instance->DR;
 8003028:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
 800302a:	68da      	ldr	r2, [r3, #12]
 800302c:	f821 2b02 	strh.w	r2, [r1], #2
  hi2s->RxXferCount--;
 8003030:	8e42      	ldrh	r2, [r0, #50]	; 0x32
  hi2s->pRxBuffPtr++;
 8003032:	62c1      	str	r1, [r0, #44]	; 0x2c
  hi2s->RxXferCount--;
 8003034:	3a01      	subs	r2, #1
 8003036:	b292      	uxth	r2, r2
 8003038:	8642      	strh	r2, [r0, #50]	; 0x32
  if (hi2s->RxXferCount == 0U)
 800303a:	8e42      	ldrh	r2, [r0, #50]	; 0x32
 800303c:	b292      	uxth	r2, r2
 800303e:	2a00      	cmp	r2, #0
 8003040:	d04a      	beq.n	80030d8 <I2S_IRQHandler+0xdc>
    if (((i2ssr & I2S_FLAG_OVR) == I2S_FLAG_OVR) && (__HAL_I2S_GET_IT_SOURCE(hi2s, I2S_IT_ERR) != RESET))
 8003042:	9b01      	ldr	r3, [sp, #4]
 8003044:	0659      	lsls	r1, r3, #25
 8003046:	d5e3      	bpl.n	8003010 <I2S_IRQHandler+0x14>
 8003048:	6823      	ldr	r3, [r4, #0]
 800304a:	685a      	ldr	r2, [r3, #4]
 800304c:	0692      	lsls	r2, r2, #26
 800304e:	d5df      	bpl.n	8003010 <I2S_IRQHandler+0x14>
      __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_RXNE | I2S_IT_ERR));
 8003050:	685a      	ldr	r2, [r3, #4]
      __HAL_I2S_CLEAR_OVRFLAG(hi2s);
 8003052:	2100      	movs	r1, #0
      __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_RXNE | I2S_IT_ERR));
 8003054:	f022 0260 	bic.w	r2, r2, #96	; 0x60
 8003058:	605a      	str	r2, [r3, #4]
      __HAL_I2S_CLEAR_OVRFLAG(hi2s);
 800305a:	9102      	str	r1, [sp, #8]
 800305c:	68da      	ldr	r2, [r3, #12]
 800305e:	9202      	str	r2, [sp, #8]
 8003060:	689b      	ldr	r3, [r3, #8]
 8003062:	9302      	str	r3, [sp, #8]
      hi2s->State = HAL_I2S_STATE_READY;
 8003064:	2301      	movs	r3, #1
      __HAL_I2S_CLEAR_OVRFLAG(hi2s);
 8003066:	9a02      	ldr	r2, [sp, #8]
      hi2s->State = HAL_I2S_STATE_READY;
 8003068:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
      SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_OVR);
 800306c:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800306e:	f043 0302 	orr.w	r3, r3, #2
      HAL_I2S_ErrorCallback(hi2s);
 8003072:	4620      	mov	r0, r4
      SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_OVR);
 8003074:	6463      	str	r3, [r4, #68]	; 0x44
      HAL_I2S_ErrorCallback(hi2s);
 8003076:	f7ff ffbf 	bl	8002ff8 <HAL_I2S_ErrorCallback>
 800307a:	e7c9      	b.n	8003010 <I2S_IRQHandler+0x14>
    if (((i2ssr & I2S_FLAG_TXE) == I2S_FLAG_TXE) && (__HAL_I2S_GET_IT_SOURCE(hi2s, I2S_IT_TXE) != RESET))
 800307c:	9b01      	ldr	r3, [sp, #4]
 800307e:	079b      	lsls	r3, r3, #30
 8003080:	d50f      	bpl.n	80030a2 <I2S_IRQHandler+0xa6>
 8003082:	6823      	ldr	r3, [r4, #0]
 8003084:	685a      	ldr	r2, [r3, #4]
 8003086:	0610      	lsls	r0, r2, #24
 8003088:	d50b      	bpl.n	80030a2 <I2S_IRQHandler+0xa6>
  hi2s->Instance->DR = (*hi2s->pTxBuffPtr);
 800308a:	6a61      	ldr	r1, [r4, #36]	; 0x24
 800308c:	f831 2b02 	ldrh.w	r2, [r1], #2
 8003090:	60da      	str	r2, [r3, #12]
  hi2s->TxXferCount--;
 8003092:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
  hi2s->pTxBuffPtr++;
 8003094:	6261      	str	r1, [r4, #36]	; 0x24
  hi2s->TxXferCount--;
 8003096:	3a01      	subs	r2, #1
 8003098:	b292      	uxth	r2, r2
 800309a:	8562      	strh	r2, [r4, #42]	; 0x2a
  if (hi2s->TxXferCount == 0U)
 800309c:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
 800309e:	b292      	uxth	r2, r2
 80030a0:	b322      	cbz	r2, 80030ec <I2S_IRQHandler+0xf0>
    if (((i2ssr & I2S_FLAG_UDR) == I2S_FLAG_UDR) && (__HAL_I2S_GET_IT_SOURCE(hi2s, I2S_IT_ERR) != RESET))
 80030a2:	9b01      	ldr	r3, [sp, #4]
 80030a4:	0719      	lsls	r1, r3, #28
 80030a6:	d5b7      	bpl.n	8003018 <I2S_IRQHandler+0x1c>
 80030a8:	6823      	ldr	r3, [r4, #0]
 80030aa:	685a      	ldr	r2, [r3, #4]
 80030ac:	0692      	lsls	r2, r2, #26
 80030ae:	d5b3      	bpl.n	8003018 <I2S_IRQHandler+0x1c>
      __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_TXE | I2S_IT_ERR));
 80030b0:	685a      	ldr	r2, [r3, #4]
      __HAL_I2S_CLEAR_UDRFLAG(hi2s);
 80030b2:	2100      	movs	r1, #0
      __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_TXE | I2S_IT_ERR));
 80030b4:	f022 02a0 	bic.w	r2, r2, #160	; 0xa0
 80030b8:	605a      	str	r2, [r3, #4]
      __HAL_I2S_CLEAR_UDRFLAG(hi2s);
 80030ba:	9103      	str	r1, [sp, #12]
 80030bc:	689b      	ldr	r3, [r3, #8]
 80030be:	9303      	str	r3, [sp, #12]
      hi2s->State = HAL_I2S_STATE_READY;
 80030c0:	2301      	movs	r3, #1
      __HAL_I2S_CLEAR_UDRFLAG(hi2s);
 80030c2:	9a03      	ldr	r2, [sp, #12]
      hi2s->State = HAL_I2S_STATE_READY;
 80030c4:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
      SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_UDR);
 80030c8:	6c63      	ldr	r3, [r4, #68]	; 0x44
 80030ca:	f043 0304 	orr.w	r3, r3, #4
      HAL_I2S_ErrorCallback(hi2s);
 80030ce:	4620      	mov	r0, r4
      SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_UDR);
 80030d0:	6463      	str	r3, [r4, #68]	; 0x44
      HAL_I2S_ErrorCallback(hi2s);
 80030d2:	f7ff ff91 	bl	8002ff8 <HAL_I2S_ErrorCallback>
}
 80030d6:	e79f      	b.n	8003018 <I2S_IRQHandler+0x1c>
    __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_RXNE | I2S_IT_ERR));
 80030d8:	685a      	ldr	r2, [r3, #4]
    hi2s->State = HAL_I2S_STATE_READY;
 80030da:	2101      	movs	r1, #1
    __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_RXNE | I2S_IT_ERR));
 80030dc:	f022 0260 	bic.w	r2, r2, #96	; 0x60
 80030e0:	605a      	str	r2, [r3, #4]
    hi2s->State = HAL_I2S_STATE_READY;
 80030e2:	f880 1041 	strb.w	r1, [r0, #65]	; 0x41
    HAL_I2S_RxCpltCallback(hi2s);
 80030e6:	f7ff f89b 	bl	8002220 <HAL_I2S_RxCpltCallback>
 80030ea:	e7aa      	b.n	8003042 <I2S_IRQHandler+0x46>
    __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_TXE | I2S_IT_ERR));
 80030ec:	685a      	ldr	r2, [r3, #4]
    hi2s->State = HAL_I2S_STATE_READY;
 80030ee:	2101      	movs	r1, #1
    __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_TXE | I2S_IT_ERR));
 80030f0:	f022 02a0 	bic.w	r2, r2, #160	; 0xa0
 80030f4:	605a      	str	r2, [r3, #4]
    HAL_I2S_TxCpltCallback(hi2s);
 80030f6:	4620      	mov	r0, r4
    hi2s->State = HAL_I2S_STATE_READY;
 80030f8:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
    HAL_I2S_TxCpltCallback(hi2s);
 80030fc:	f7ff ff62 	bl	8002fc4 <HAL_I2S_TxCpltCallback>
 8003100:	e7cf      	b.n	80030a2 <I2S_IRQHandler+0xa6>
 8003102:	bf00      	nop

08003104 <I2S_DMAError>:
  I2S_HandleTypeDef *hi2s = (I2S_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent; /* Derogation MISRAC2012-Rule-11.5 */
 8003104:	6b80      	ldr	r0, [r0, #56]	; 0x38
  CLEAR_BIT(hi2s->Instance->CR2, (SPI_CR2_RXDMAEN | SPI_CR2_TXDMAEN));
 8003106:	6801      	ldr	r1, [r0, #0]
{
 8003108:	b508      	push	{r3, lr}
  CLEAR_BIT(hi2s->Instance->CR2, (SPI_CR2_RXDMAEN | SPI_CR2_TXDMAEN));
 800310a:	684b      	ldr	r3, [r1, #4]
  hi2s->TxXferCount = 0U;
 800310c:	2200      	movs	r2, #0
  hi2s->State = HAL_I2S_STATE_READY;
 800310e:	f04f 0c01 	mov.w	ip, #1
  CLEAR_BIT(hi2s->Instance->CR2, (SPI_CR2_RXDMAEN | SPI_CR2_TXDMAEN));
 8003112:	f023 0303 	bic.w	r3, r3, #3
 8003116:	604b      	str	r3, [r1, #4]
  hi2s->TxXferCount = 0U;
 8003118:	8542      	strh	r2, [r0, #42]	; 0x2a
  hi2s->RxXferCount = 0U;
 800311a:	8642      	strh	r2, [r0, #50]	; 0x32
  hi2s->State = HAL_I2S_STATE_READY;
 800311c:	f880 c041 	strb.w	ip, [r0, #65]	; 0x41
  SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_DMA);
 8003120:	6c43      	ldr	r3, [r0, #68]	; 0x44
 8003122:	f043 0308 	orr.w	r3, r3, #8
 8003126:	6443      	str	r3, [r0, #68]	; 0x44
  HAL_I2S_ErrorCallback(hi2s);
 8003128:	f7ff ff66 	bl	8002ff8 <HAL_I2S_ErrorCallback>
}
 800312c:	bd08      	pop	{r3, pc}
 800312e:	bf00      	nop

08003130 <HAL_I2SEx_TxRxCpltCallback>:
 8003130:	4770      	bx	lr
 8003132:	bf00      	nop

08003134 <HAL_I2SEx_FullDuplex_IRQHandler>:
  * @brief  This function handles I2S/I2Sext interrupt requests in full-duplex mode.
  * @param  hi2s I2S handle
  * @retval HAL status
  */
void HAL_I2SEx_FullDuplex_IRQHandler(I2S_HandleTypeDef *hi2s)
{
 8003134:	b510      	push	{r4, lr}
  __IO uint32_t i2ssr     = hi2s->Instance->SR;
 8003136:	6801      	ldr	r1, [r0, #0]
  __IO uint32_t i2sextsr  = I2SxEXT(hi2s->Instance)->SR;
 8003138:	4a93      	ldr	r2, [pc, #588]	; (8003388 <HAL_I2SEx_FullDuplex_IRQHandler+0x254>)
  __IO uint32_t i2ssr     = hi2s->Instance->SR;
 800313a:	688b      	ldr	r3, [r1, #8]
{
 800313c:	b086      	sub	sp, #24
 800313e:	4604      	mov	r4, r0
  __IO uint32_t i2ssr     = hi2s->Instance->SR;
 8003140:	9300      	str	r3, [sp, #0]
  __IO uint32_t i2sextsr  = I2SxEXT(hi2s->Instance)->SR;
 8003142:	4b92      	ldr	r3, [pc, #584]	; (800338c <HAL_I2SEx_FullDuplex_IRQHandler+0x258>)
 8003144:	4291      	cmp	r1, r2
 8003146:	bf18      	it	ne
 8003148:	f04f 2340 	movne.w	r3, #1073758208	; 0x40004000
 800314c:	689a      	ldr	r2, [r3, #8]
 800314e:	9201      	str	r2, [sp, #4]
  __IO uint32_t i2scr2    = hi2s->Instance->CR2;
 8003150:	684a      	ldr	r2, [r1, #4]
 8003152:	9202      	str	r2, [sp, #8]
  __IO uint32_t i2sextcr2 = I2SxEXT(hi2s->Instance)->CR2;
 8003154:	685a      	ldr	r2, [r3, #4]
 8003156:	9203      	str	r2, [sp, #12]

  /* Check if the I2S_MODE_MASTER_TX or I2S_MODE_SLAVE_TX Mode is selected */
  if ((hi2s->Init.Mode == I2S_MODE_MASTER_TX) || (hi2s->Init.Mode == I2S_MODE_SLAVE_TX))
 8003158:	6842      	ldr	r2, [r0, #4]
 800315a:	f432 7200 	bics.w	r2, r2, #512	; 0x200
 800315e:	d078      	beq.n	8003252 <HAL_I2SEx_FullDuplex_IRQHandler+0x11e>
  }
  /* The I2S_MODE_MASTER_RX or I2S_MODE_SLAVE_RX Mode is selected */
  else
  {
    /* I2Sext in mode Transmitter ----------------------------------------------*/
    if (((i2sextsr & I2S_FLAG_TXE) == I2S_FLAG_TXE) && ((i2sextcr2 & I2S_IT_TXE) != RESET))
 8003160:	9a01      	ldr	r2, [sp, #4]
 8003162:	0792      	lsls	r2, r2, #30
 8003164:	d51a      	bpl.n	800319c <HAL_I2SEx_FullDuplex_IRQHandler+0x68>
 8003166:	9a03      	ldr	r2, [sp, #12]
 8003168:	0611      	lsls	r1, r2, #24
 800316a:	d517      	bpl.n	800319c <HAL_I2SEx_FullDuplex_IRQHandler+0x68>
  * @retval None
  */
static void I2SEx_TxISR_I2SExt(I2S_HandleTypeDef *hi2s)
{
  /* Write Data on DR register */
  I2SxEXT(hi2s->Instance)->DR = (*hi2s->pTxBuffPtr++);
 800316c:	6a42      	ldr	r2, [r0, #36]	; 0x24
 800316e:	1c91      	adds	r1, r2, #2
 8003170:	8812      	ldrh	r2, [r2, #0]
 8003172:	6241      	str	r1, [r0, #36]	; 0x24
 8003174:	60da      	str	r2, [r3, #12]
  hi2s->TxXferCount--;
 8003176:	8d42      	ldrh	r2, [r0, #42]	; 0x2a
 8003178:	3a01      	subs	r2, #1
 800317a:	b292      	uxth	r2, r2
 800317c:	8542      	strh	r2, [r0, #42]	; 0x2a

  if (hi2s->TxXferCount == 0U)
 800317e:	8d42      	ldrh	r2, [r0, #42]	; 0x2a
 8003180:	b292      	uxth	r2, r2
 8003182:	b95a      	cbnz	r2, 800319c <HAL_I2SEx_FullDuplex_IRQHandler+0x68>
  {
    /* Disable I2Sext TXE and ERR interrupt */
    __HAL_I2SEXT_DISABLE_IT(hi2s, (I2S_IT_TXE | I2S_IT_ERR));
 8003184:	685a      	ldr	r2, [r3, #4]
 8003186:	f022 02a0 	bic.w	r2, r2, #160	; 0xa0
 800318a:	605a      	str	r2, [r3, #4]

    if (hi2s->RxXferCount == 0U)
 800318c:	8e43      	ldrh	r3, [r0, #50]	; 0x32
 800318e:	b29b      	uxth	r3, r3
 8003190:	b923      	cbnz	r3, 800319c <HAL_I2SEx_FullDuplex_IRQHandler+0x68>
    {
      hi2s->State = HAL_I2S_STATE_READY;
 8003192:	2301      	movs	r3, #1
 8003194:	f880 3041 	strb.w	r3, [r0, #65]	; 0x41
      /* Call user TxRx complete callback */
#if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
      hi2s->TxRxCpltCallback(hi2s);
#else
      HAL_I2SEx_TxRxCpltCallback(hi2s);
 8003198:	f7ff ffca 	bl	8003130 <HAL_I2SEx_TxRxCpltCallback>
    if (((i2ssr & I2S_FLAG_RXNE) == I2S_FLAG_RXNE) && ((i2scr2 & I2S_IT_RXNE) != RESET))
 800319c:	9b00      	ldr	r3, [sp, #0]
 800319e:	07da      	lsls	r2, r3, #31
 80031a0:	d51c      	bpl.n	80031dc <HAL_I2SEx_FullDuplex_IRQHandler+0xa8>
 80031a2:	9b02      	ldr	r3, [sp, #8]
 80031a4:	065b      	lsls	r3, r3, #25
 80031a6:	d519      	bpl.n	80031dc <HAL_I2SEx_FullDuplex_IRQHandler+0xa8>
  * @retval None
  */
static void I2SEx_RxISR_I2S(I2S_HandleTypeDef *hi2s)
{
  /* Read Data from DR register */
  (*hi2s->pRxBuffPtr++) = hi2s->Instance->DR;
 80031a8:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 80031aa:	6822      	ldr	r2, [r4, #0]
 80031ac:	1c98      	adds	r0, r3, #2
 80031ae:	68d1      	ldr	r1, [r2, #12]
 80031b0:	62e0      	str	r0, [r4, #44]	; 0x2c
 80031b2:	8019      	strh	r1, [r3, #0]
  hi2s->RxXferCount--;
 80031b4:	8e63      	ldrh	r3, [r4, #50]	; 0x32
 80031b6:	3b01      	subs	r3, #1
 80031b8:	b29b      	uxth	r3, r3
 80031ba:	8663      	strh	r3, [r4, #50]	; 0x32

  if (hi2s->RxXferCount == 0U)
 80031bc:	8e63      	ldrh	r3, [r4, #50]	; 0x32
 80031be:	b29b      	uxth	r3, r3
 80031c0:	b963      	cbnz	r3, 80031dc <HAL_I2SEx_FullDuplex_IRQHandler+0xa8>
  {
    /* Disable RXNE and ERR interrupt */
    __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_RXNE | I2S_IT_ERR));
 80031c2:	6853      	ldr	r3, [r2, #4]
 80031c4:	f023 0360 	bic.w	r3, r3, #96	; 0x60
 80031c8:	6053      	str	r3, [r2, #4]

    if (hi2s->TxXferCount == 0U)
 80031ca:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 80031cc:	b29b      	uxth	r3, r3
 80031ce:	b92b      	cbnz	r3, 80031dc <HAL_I2SEx_FullDuplex_IRQHandler+0xa8>
    {
      hi2s->State = HAL_I2S_STATE_READY;
 80031d0:	2301      	movs	r3, #1
 80031d2:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
      /* Call user TxRx complete callback */
#if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
      hi2s->TxRxCpltCallback(hi2s);
#else
      HAL_I2SEx_TxRxCpltCallback(hi2s);
 80031d6:	4620      	mov	r0, r4
 80031d8:	f7ff ffaa 	bl	8003130 <HAL_I2SEx_TxRxCpltCallback>
    if (((i2ssr & I2S_FLAG_OVR) == I2S_FLAG_OVR) && ((i2scr2 & I2S_IT_ERR) != RESET))
 80031dc:	9b00      	ldr	r3, [sp, #0]
 80031de:	0658      	lsls	r0, r3, #25
 80031e0:	d51b      	bpl.n	800321a <HAL_I2SEx_FullDuplex_IRQHandler+0xe6>
 80031e2:	9b02      	ldr	r3, [sp, #8]
 80031e4:	0699      	lsls	r1, r3, #26
 80031e6:	d518      	bpl.n	800321a <HAL_I2SEx_FullDuplex_IRQHandler+0xe6>
      __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_RXNE | I2S_IT_ERR));
 80031e8:	6822      	ldr	r2, [r4, #0]
      __HAL_I2SEXT_DISABLE_IT(hi2s, (I2S_IT_TXE | I2S_IT_ERR));
 80031ea:	4867      	ldr	r0, [pc, #412]	; (8003388 <HAL_I2SEx_FullDuplex_IRQHandler+0x254>)
      __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_RXNE | I2S_IT_ERR));
 80031ec:	6851      	ldr	r1, [r2, #4]
      __HAL_I2SEXT_DISABLE_IT(hi2s, (I2S_IT_TXE | I2S_IT_ERR));
 80031ee:	4b67      	ldr	r3, [pc, #412]	; (800338c <HAL_I2SEx_FullDuplex_IRQHandler+0x258>)
      __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_RXNE | I2S_IT_ERR));
 80031f0:	f021 0160 	bic.w	r1, r1, #96	; 0x60
      __HAL_I2SEXT_DISABLE_IT(hi2s, (I2S_IT_TXE | I2S_IT_ERR));
 80031f4:	4282      	cmp	r2, r0
 80031f6:	bf18      	it	ne
 80031f8:	f04f 2340 	movne.w	r3, #1073758208	; 0x40004000
      __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_RXNE | I2S_IT_ERR));
 80031fc:	6051      	str	r1, [r2, #4]
      __HAL_I2SEXT_DISABLE_IT(hi2s, (I2S_IT_TXE | I2S_IT_ERR));
 80031fe:	685a      	ldr	r2, [r3, #4]
      hi2s->State = HAL_I2S_STATE_READY;
 8003200:	2101      	movs	r1, #1
      __HAL_I2SEXT_DISABLE_IT(hi2s, (I2S_IT_TXE | I2S_IT_ERR));
 8003202:	f022 02a0 	bic.w	r2, r2, #160	; 0xa0
 8003206:	605a      	str	r2, [r3, #4]
      hi2s->State = HAL_I2S_STATE_READY;
 8003208:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
      SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_OVR);
 800320c:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800320e:	f043 0302 	orr.w	r3, r3, #2
      HAL_I2S_ErrorCallback(hi2s);
 8003212:	4620      	mov	r0, r4
      SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_OVR);
 8003214:	6463      	str	r3, [r4, #68]	; 0x44
      HAL_I2S_ErrorCallback(hi2s);
 8003216:	f7ff feef 	bl	8002ff8 <HAL_I2S_ErrorCallback>
    if (((i2sextsr & I2S_FLAG_UDR) == I2S_FLAG_UDR) && ((i2sextcr2 & I2S_IT_ERR) != RESET))
 800321a:	9b01      	ldr	r3, [sp, #4]
 800321c:	071a      	lsls	r2, r3, #28
 800321e:	d571      	bpl.n	8003304 <HAL_I2SEx_FullDuplex_IRQHandler+0x1d0>
 8003220:	9b03      	ldr	r3, [sp, #12]
 8003222:	069b      	lsls	r3, r3, #26
 8003224:	d56e      	bpl.n	8003304 <HAL_I2SEx_FullDuplex_IRQHandler+0x1d0>
      __HAL_I2SEXT_DISABLE_IT(hi2s, (I2S_IT_TXE | I2S_IT_ERR));
 8003226:	6822      	ldr	r2, [r4, #0]
 8003228:	4957      	ldr	r1, [pc, #348]	; (8003388 <HAL_I2SEx_FullDuplex_IRQHandler+0x254>)
 800322a:	4b58      	ldr	r3, [pc, #352]	; (800338c <HAL_I2SEx_FullDuplex_IRQHandler+0x258>)
 800322c:	428a      	cmp	r2, r1
 800322e:	bf18      	it	ne
 8003230:	f04f 2340 	movne.w	r3, #1073758208	; 0x40004000
      hi2s->State = HAL_I2S_STATE_READY;
 8003234:	f04f 0c01 	mov.w	ip, #1
      __HAL_I2SEXT_DISABLE_IT(hi2s, (I2S_IT_TXE | I2S_IT_ERR));
 8003238:	6859      	ldr	r1, [r3, #4]
 800323a:	f021 01a0 	bic.w	r1, r1, #160	; 0xa0
 800323e:	6059      	str	r1, [r3, #4]
      __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_RXNE | I2S_IT_ERR));
 8003240:	6853      	ldr	r3, [r2, #4]
 8003242:	f023 0360 	bic.w	r3, r3, #96	; 0x60
 8003246:	6053      	str	r3, [r2, #4]
      hi2s->State = HAL_I2S_STATE_READY;
 8003248:	f884 c041 	strb.w	ip, [r4, #65]	; 0x41
      SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_UDR);
 800324c:	6c63      	ldr	r3, [r4, #68]	; 0x44
      HAL_I2S_ErrorCallback(hi2s);
 800324e:	4620      	mov	r0, r4
 8003250:	e050      	b.n	80032f4 <HAL_I2SEx_FullDuplex_IRQHandler+0x1c0>
    if (((i2ssr & I2S_FLAG_TXE) == I2S_FLAG_TXE) && ((i2scr2 & I2S_IT_TXE) != RESET))
 8003252:	9b00      	ldr	r3, [sp, #0]
 8003254:	079a      	lsls	r2, r3, #30
 8003256:	d502      	bpl.n	800325e <HAL_I2SEx_FullDuplex_IRQHandler+0x12a>
 8003258:	9b02      	ldr	r3, [sp, #8]
 800325a:	061b      	lsls	r3, r3, #24
 800325c:	d454      	bmi.n	8003308 <HAL_I2SEx_FullDuplex_IRQHandler+0x1d4>
    if (((i2sextsr & I2S_FLAG_RXNE) == I2S_FLAG_RXNE) && ((i2sextcr2 & I2S_IT_RXNE) != RESET))
 800325e:	9b01      	ldr	r3, [sp, #4]
 8003260:	07d8      	lsls	r0, r3, #31
 8003262:	d502      	bpl.n	800326a <HAL_I2SEx_FullDuplex_IRQHandler+0x136>
 8003264:	9b03      	ldr	r3, [sp, #12]
 8003266:	0659      	lsls	r1, r3, #25
 8003268:	d469      	bmi.n	800333e <HAL_I2SEx_FullDuplex_IRQHandler+0x20a>
    if (((i2sextsr & I2S_FLAG_OVR) == I2S_FLAG_OVR) && ((i2sextcr2 & I2S_IT_ERR) != RESET))
 800326a:	9b01      	ldr	r3, [sp, #4]
 800326c:	065a      	lsls	r2, r3, #25
 800326e:	d522      	bpl.n	80032b6 <HAL_I2SEx_FullDuplex_IRQHandler+0x182>
 8003270:	9b03      	ldr	r3, [sp, #12]
 8003272:	069b      	lsls	r3, r3, #26
 8003274:	d51f      	bpl.n	80032b6 <HAL_I2SEx_FullDuplex_IRQHandler+0x182>
      __HAL_I2SEXT_DISABLE_IT(hi2s, (I2S_IT_RXNE | I2S_IT_ERR));
 8003276:	6823      	ldr	r3, [r4, #0]
 8003278:	4943      	ldr	r1, [pc, #268]	; (8003388 <HAL_I2SEx_FullDuplex_IRQHandler+0x254>)
 800327a:	4a44      	ldr	r2, [pc, #272]	; (800338c <HAL_I2SEx_FullDuplex_IRQHandler+0x258>)
 800327c:	428b      	cmp	r3, r1
 800327e:	bf18      	it	ne
 8003280:	f04f 2240 	movne.w	r2, #1073758208	; 0x40004000
      __HAL_I2S_CLEAR_OVRFLAG(hi2s);
 8003284:	2000      	movs	r0, #0
      __HAL_I2SEXT_DISABLE_IT(hi2s, (I2S_IT_RXNE | I2S_IT_ERR));
 8003286:	6851      	ldr	r1, [r2, #4]
 8003288:	f021 0160 	bic.w	r1, r1, #96	; 0x60
 800328c:	6051      	str	r1, [r2, #4]
      __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_TXE | I2S_IT_ERR));
 800328e:	685a      	ldr	r2, [r3, #4]
 8003290:	f022 02a0 	bic.w	r2, r2, #160	; 0xa0
 8003294:	605a      	str	r2, [r3, #4]
      __HAL_I2S_CLEAR_OVRFLAG(hi2s);
 8003296:	9004      	str	r0, [sp, #16]
 8003298:	68da      	ldr	r2, [r3, #12]
 800329a:	9204      	str	r2, [sp, #16]
 800329c:	689b      	ldr	r3, [r3, #8]
 800329e:	9304      	str	r3, [sp, #16]
      hi2s->State = HAL_I2S_STATE_READY;
 80032a0:	2101      	movs	r1, #1
      __HAL_I2S_CLEAR_OVRFLAG(hi2s);
 80032a2:	9b04      	ldr	r3, [sp, #16]
      hi2s->State = HAL_I2S_STATE_READY;
 80032a4:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
      SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_OVR);
 80032a8:	6c63      	ldr	r3, [r4, #68]	; 0x44
 80032aa:	f043 0302 	orr.w	r3, r3, #2
      HAL_I2S_ErrorCallback(hi2s);
 80032ae:	4620      	mov	r0, r4
      SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_OVR);
 80032b0:	6463      	str	r3, [r4, #68]	; 0x44
      HAL_I2S_ErrorCallback(hi2s);
 80032b2:	f7ff fea1 	bl	8002ff8 <HAL_I2S_ErrorCallback>
    if (((i2ssr & I2S_FLAG_UDR) == I2S_FLAG_UDR) && ((i2scr2 & I2S_IT_ERR) != RESET))
 80032b6:	9b00      	ldr	r3, [sp, #0]
 80032b8:	0718      	lsls	r0, r3, #28
 80032ba:	d523      	bpl.n	8003304 <HAL_I2SEx_FullDuplex_IRQHandler+0x1d0>
 80032bc:	9b02      	ldr	r3, [sp, #8]
 80032be:	0699      	lsls	r1, r3, #26
 80032c0:	d520      	bpl.n	8003304 <HAL_I2SEx_FullDuplex_IRQHandler+0x1d0>
      __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_TXE | I2S_IT_ERR));
 80032c2:	6823      	ldr	r3, [r4, #0]
      __HAL_I2SEXT_DISABLE_IT(hi2s, (I2S_IT_RXNE | I2S_IT_ERR));
 80032c4:	4830      	ldr	r0, [pc, #192]	; (8003388 <HAL_I2SEx_FullDuplex_IRQHandler+0x254>)
      __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_TXE | I2S_IT_ERR));
 80032c6:	6859      	ldr	r1, [r3, #4]
      __HAL_I2SEXT_DISABLE_IT(hi2s, (I2S_IT_RXNE | I2S_IT_ERR));
 80032c8:	4a30      	ldr	r2, [pc, #192]	; (800338c <HAL_I2SEx_FullDuplex_IRQHandler+0x258>)
      __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_TXE | I2S_IT_ERR));
 80032ca:	f021 01a0 	bic.w	r1, r1, #160	; 0xa0
      __HAL_I2SEXT_DISABLE_IT(hi2s, (I2S_IT_RXNE | I2S_IT_ERR));
 80032ce:	4283      	cmp	r3, r0
 80032d0:	bf18      	it	ne
 80032d2:	f04f 2240 	movne.w	r2, #1073758208	; 0x40004000
      __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_TXE | I2S_IT_ERR));
 80032d6:	6059      	str	r1, [r3, #4]
      __HAL_I2SEXT_DISABLE_IT(hi2s, (I2S_IT_RXNE | I2S_IT_ERR));
 80032d8:	6851      	ldr	r1, [r2, #4]
      __HAL_I2S_CLEAR_UDRFLAG(hi2s);
 80032da:	2000      	movs	r0, #0
      __HAL_I2SEXT_DISABLE_IT(hi2s, (I2S_IT_RXNE | I2S_IT_ERR));
 80032dc:	f021 0160 	bic.w	r1, r1, #96	; 0x60
 80032e0:	6051      	str	r1, [r2, #4]
      __HAL_I2S_CLEAR_UDRFLAG(hi2s);
 80032e2:	9005      	str	r0, [sp, #20]
 80032e4:	689b      	ldr	r3, [r3, #8]
 80032e6:	9305      	str	r3, [sp, #20]
      hi2s->State = HAL_I2S_STATE_READY;
 80032e8:	2301      	movs	r3, #1
      __HAL_I2S_CLEAR_UDRFLAG(hi2s);
 80032ea:	9a05      	ldr	r2, [sp, #20]
      hi2s->State = HAL_I2S_STATE_READY;
 80032ec:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
      SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_UDR);
 80032f0:	6c63      	ldr	r3, [r4, #68]	; 0x44
      HAL_I2S_ErrorCallback(hi2s);
 80032f2:	4620      	mov	r0, r4
      SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_UDR);
 80032f4:	f043 0304 	orr.w	r3, r3, #4
 80032f8:	6463      	str	r3, [r4, #68]	; 0x44
}
 80032fa:	b006      	add	sp, #24
 80032fc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      HAL_I2S_ErrorCallback(hi2s);
 8003300:	f7ff be7a 	b.w	8002ff8 <HAL_I2S_ErrorCallback>
}
 8003304:	b006      	add	sp, #24
 8003306:	bd10      	pop	{r4, pc}
  hi2s->Instance->DR = (*hi2s->pTxBuffPtr++);
 8003308:	6a43      	ldr	r3, [r0, #36]	; 0x24
 800330a:	1c9a      	adds	r2, r3, #2
 800330c:	881b      	ldrh	r3, [r3, #0]
 800330e:	6242      	str	r2, [r0, #36]	; 0x24
 8003310:	60cb      	str	r3, [r1, #12]
  hi2s->TxXferCount--;
 8003312:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 8003314:	3b01      	subs	r3, #1
 8003316:	b29b      	uxth	r3, r3
 8003318:	8543      	strh	r3, [r0, #42]	; 0x2a
  if (hi2s->TxXferCount == 0U)
 800331a:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 800331c:	b29b      	uxth	r3, r3
 800331e:	2b00      	cmp	r3, #0
 8003320:	d19d      	bne.n	800325e <HAL_I2SEx_FullDuplex_IRQHandler+0x12a>
    __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_TXE | I2S_IT_ERR));
 8003322:	684b      	ldr	r3, [r1, #4]
 8003324:	f023 03a0 	bic.w	r3, r3, #160	; 0xa0
 8003328:	604b      	str	r3, [r1, #4]
    if (hi2s->RxXferCount == 0U)
 800332a:	8e43      	ldrh	r3, [r0, #50]	; 0x32
 800332c:	b29b      	uxth	r3, r3
 800332e:	2b00      	cmp	r3, #0
 8003330:	d195      	bne.n	800325e <HAL_I2SEx_FullDuplex_IRQHandler+0x12a>
      hi2s->State = HAL_I2S_STATE_READY;
 8003332:	2301      	movs	r3, #1
 8003334:	f880 3041 	strb.w	r3, [r0, #65]	; 0x41
      HAL_I2SEx_TxRxCpltCallback(hi2s);
 8003338:	f7ff fefa 	bl	8003130 <HAL_I2SEx_TxRxCpltCallback>
 800333c:	e78f      	b.n	800325e <HAL_I2SEx_FullDuplex_IRQHandler+0x12a>
  * @retval None
  */
static void I2SEx_RxISR_I2SExt(I2S_HandleTypeDef *hi2s)
{
  /* Read Data from DR register */
  (*hi2s->pRxBuffPtr++) = I2SxEXT(hi2s->Instance)->DR;
 800333e:	6820      	ldr	r0, [r4, #0]
 8003340:	4911      	ldr	r1, [pc, #68]	; (8003388 <HAL_I2SEx_FullDuplex_IRQHandler+0x254>)
 8003342:	4a12      	ldr	r2, [pc, #72]	; (800338c <HAL_I2SEx_FullDuplex_IRQHandler+0x258>)
 8003344:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8003346:	4288      	cmp	r0, r1
 8003348:	bf18      	it	ne
 800334a:	f04f 2240 	movne.w	r2, #1073758208	; 0x40004000
 800334e:	1c98      	adds	r0, r3, #2
 8003350:	68d1      	ldr	r1, [r2, #12]
 8003352:	62e0      	str	r0, [r4, #44]	; 0x2c
 8003354:	8019      	strh	r1, [r3, #0]
  hi2s->RxXferCount--;
 8003356:	8e63      	ldrh	r3, [r4, #50]	; 0x32
 8003358:	3b01      	subs	r3, #1
 800335a:	b29b      	uxth	r3, r3
 800335c:	8663      	strh	r3, [r4, #50]	; 0x32

  if (hi2s->RxXferCount == 0U)
 800335e:	8e63      	ldrh	r3, [r4, #50]	; 0x32
 8003360:	b29b      	uxth	r3, r3
 8003362:	2b00      	cmp	r3, #0
 8003364:	d181      	bne.n	800326a <HAL_I2SEx_FullDuplex_IRQHandler+0x136>
  {
    /* Disable I2Sext RXNE and ERR interrupt */
    __HAL_I2SEXT_DISABLE_IT(hi2s, (I2S_IT_RXNE | I2S_IT_ERR));
 8003366:	6853      	ldr	r3, [r2, #4]
 8003368:	f023 0360 	bic.w	r3, r3, #96	; 0x60
 800336c:	6053      	str	r3, [r2, #4]

    if (hi2s->TxXferCount == 0U)
 800336e:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8003370:	b29b      	uxth	r3, r3
 8003372:	2b00      	cmp	r3, #0
 8003374:	f47f af79 	bne.w	800326a <HAL_I2SEx_FullDuplex_IRQHandler+0x136>
    {
      hi2s->State = HAL_I2S_STATE_READY;
 8003378:	2301      	movs	r3, #1
 800337a:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
      /* Call user TxRx complete callback */
#if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
      hi2s->TxRxCpltCallback(hi2s);
#else
      HAL_I2SEx_TxRxCpltCallback(hi2s);
 800337e:	4620      	mov	r0, r4
 8003380:	f7ff fed6 	bl	8003130 <HAL_I2SEx_TxRxCpltCallback>
 8003384:	e771      	b.n	800326a <HAL_I2SEx_FullDuplex_IRQHandler+0x136>
 8003386:	bf00      	nop
 8003388:	40003800 	.word	0x40003800
 800338c:	40003400 	.word	0x40003400

08003390 <HAL_PCDEx_SetTxFiFo>:
  * @param  fifo The number of Tx fifo
  * @param  size Fifo size
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_SetTxFiFo(PCD_HandleTypeDef *hpcd, uint8_t fifo, uint16_t size)
{
 8003390:	b410      	push	{r4}
         --> Txn should be configured with the minimum space of 16 words
     The FIFO is used optimally when used TxFIFOs are allocated in the top
         of the FIFO.Ex: use EP1 and EP2 as IN instead of EP1 and EP3 as IN ones.
     When DMA is used 3n * FIFO locations should be reserved for internal DMA registers */

  Tx_Offset = hpcd->Instance->GRXFSIZ;
 8003392:	6804      	ldr	r4, [r0, #0]
 8003394:	6a60      	ldr	r0, [r4, #36]	; 0x24

  if (fifo == 0U)
 8003396:	b931      	cbnz	r1, 80033a6 <HAL_PCDEx_SetTxFiFo+0x16>
  {
    hpcd->Instance->DIEPTXF0_HNPTXFSIZ = ((uint32_t)size << 16) | Tx_Offset;
 8003398:	ea40 4002 	orr.w	r0, r0, r2, lsl #16
 800339c:	62a0      	str	r0, [r4, #40]	; 0x28
    /* Multiply Tx_Size by 2 to get higher performance */
    hpcd->Instance->DIEPTXF[fifo - 1U] = ((uint32_t)size << 16) | Tx_Offset;
  }

  return HAL_OK;
}
 800339e:	2000      	movs	r0, #0
 80033a0:	f85d 4b04 	ldr.w	r4, [sp], #4
 80033a4:	4770      	bx	lr
    Tx_Offset += (hpcd->Instance->DIEPTXF0_HNPTXFSIZ) >> 16;
 80033a6:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    for (i = 0U; i < (fifo - 1U); i++)
 80033a8:	f1b1 0c01 	subs.w	ip, r1, #1
    Tx_Offset += (hpcd->Instance->DIEPTXF0_HNPTXFSIZ) >> 16;
 80033ac:	eb00 4013 	add.w	r0, r0, r3, lsr #16
    for (i = 0U; i < (fifo - 1U); i++)
 80033b0:	d00b      	beq.n	80033ca <HAL_PCDEx_SetTxFiFo+0x3a>
 80033b2:	2300      	movs	r3, #0
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16);
 80033b4:	f103 0140 	add.w	r1, r3, #64	; 0x40
 80033b8:	eb04 0181 	add.w	r1, r4, r1, lsl #2
    for (i = 0U; i < (fifo - 1U); i++)
 80033bc:	3301      	adds	r3, #1
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16);
 80033be:	6849      	ldr	r1, [r1, #4]
    for (i = 0U; i < (fifo - 1U); i++)
 80033c0:	b2db      	uxtb	r3, r3
 80033c2:	4563      	cmp	r3, ip
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16);
 80033c4:	eb00 4011 	add.w	r0, r0, r1, lsr #16
    for (i = 0U; i < (fifo - 1U); i++)
 80033c8:	d3f4      	bcc.n	80033b4 <HAL_PCDEx_SetTxFiFo+0x24>
    hpcd->Instance->DIEPTXF[fifo - 1U] = ((uint32_t)size << 16) | Tx_Offset;
 80033ca:	f10c 0c40 	add.w	ip, ip, #64	; 0x40
 80033ce:	eb04 0c8c 	add.w	ip, r4, ip, lsl #2
 80033d2:	ea40 4002 	orr.w	r0, r0, r2, lsl #16
 80033d6:	f8cc 0004 	str.w	r0, [ip, #4]
}
 80033da:	f85d 4b04 	ldr.w	r4, [sp], #4
 80033de:	2000      	movs	r0, #0
 80033e0:	4770      	bx	lr
 80033e2:	bf00      	nop

080033e4 <HAL_PCDEx_SetRxFiFo>:
  * @param  size Size of Rx fifo
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_SetRxFiFo(PCD_HandleTypeDef *hpcd, uint16_t size)
{
  hpcd->Instance->GRXFSIZ = size;
 80033e4:	6803      	ldr	r3, [r0, #0]

  return HAL_OK;
}
 80033e6:	2000      	movs	r0, #0
  hpcd->Instance->GRXFSIZ = size;
 80033e8:	6259      	str	r1, [r3, #36]	; 0x24
}
 80033ea:	4770      	bx	lr

080033ec <HAL_PCDEx_LPM_Callback>:
  UNUSED(msg);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_PCDEx_LPM_Callback could be implemented in the user file
   */
}
 80033ec:	4770      	bx	lr
 80033ee:	bf00      	nop

080033f0 <HAL_RCC_OscConfig>:
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
  uint32_t tickstart, pll_config;

  /* Check Null pointer */
  if(RCC_OscInitStruct == NULL)
 80033f0:	2800      	cmp	r0, #0
 80033f2:	f000 81a6 	beq.w	8003742 <HAL_RCC_OscConfig+0x352>
{
 80033f6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 80033fa:	6803      	ldr	r3, [r0, #0]
 80033fc:	07dd      	lsls	r5, r3, #31
{
 80033fe:	b082      	sub	sp, #8
 8003400:	4604      	mov	r4, r0
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8003402:	d531      	bpl.n	8003468 <HAL_RCC_OscConfig+0x78>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
 8003404:	49a0      	ldr	r1, [pc, #640]	; (8003688 <HAL_RCC_OscConfig+0x298>)
 8003406:	688a      	ldr	r2, [r1, #8]
 8003408:	f002 020c 	and.w	r2, r2, #12
 800340c:	2a04      	cmp	r2, #4
 800340e:	f000 80ef 	beq.w	80035f0 <HAL_RCC_OscConfig+0x200>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 8003412:	688a      	ldr	r2, [r1, #8]
 8003414:	f002 020c 	and.w	r2, r2, #12
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
 8003418:	2a08      	cmp	r2, #8
 800341a:	f000 80e5 	beq.w	80035e8 <HAL_RCC_OscConfig+0x1f8>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 800341e:	6863      	ldr	r3, [r4, #4]
 8003420:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8003424:	f000 80ee 	beq.w	8003604 <HAL_RCC_OscConfig+0x214>
 8003428:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 800342c:	f000 8179 	beq.w	8003722 <HAL_RCC_OscConfig+0x332>
 8003430:	4d95      	ldr	r5, [pc, #596]	; (8003688 <HAL_RCC_OscConfig+0x298>)
 8003432:	682a      	ldr	r2, [r5, #0]
 8003434:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8003438:	602a      	str	r2, [r5, #0]
 800343a:	682a      	ldr	r2, [r5, #0]
 800343c:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8003440:	602a      	str	r2, [r5, #0]

      /* Check the HSE State */
      if((RCC_OscInitStruct->HSEState) != RCC_HSE_OFF)
 8003442:	2b00      	cmp	r3, #0
 8003444:	f040 80e3 	bne.w	800360e <HAL_RCC_OscConfig+0x21e>
        }
      }
      else
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8003448:	f7ff f91e 	bl	8002688 <HAL_GetTick>

        /* Wait till HSE is bypassed or disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 800344c:	f241 3788 	movw	r7, #5000	; 0x1388
        tickstart = HAL_GetTick();
 8003450:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8003452:	e005      	b.n	8003460 <HAL_RCC_OscConfig+0x70>
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8003454:	f7ff f918 	bl	8002688 <HAL_GetTick>
 8003458:	1b80      	subs	r0, r0, r6
 800345a:	42b8      	cmp	r0, r7
 800345c:	f200 8103 	bhi.w	8003666 <HAL_RCC_OscConfig+0x276>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8003460:	682b      	ldr	r3, [r5, #0]
 8003462:	039b      	lsls	r3, r3, #14
 8003464:	d4f6      	bmi.n	8003454 <HAL_RCC_OscConfig+0x64>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8003466:	6823      	ldr	r3, [r4, #0]
 8003468:	079f      	lsls	r7, r3, #30
 800346a:	d528      	bpl.n	80034be <HAL_RCC_OscConfig+0xce>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
 800346c:	4a86      	ldr	r2, [pc, #536]	; (8003688 <HAL_RCC_OscConfig+0x298>)
 800346e:	6891      	ldr	r1, [r2, #8]
 8003470:	f011 0f0c 	tst.w	r1, #12
 8003474:	f000 8090 	beq.w	8003598 <HAL_RCC_OscConfig+0x1a8>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 8003478:	6891      	ldr	r1, [r2, #8]
 800347a:	f001 010c 	and.w	r1, r1, #12
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
 800347e:	2908      	cmp	r1, #8
 8003480:	f000 8086 	beq.w	8003590 <HAL_RCC_OscConfig+0x1a0>
      }
    }
    else
    {
      /* Check the HSI State */
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
 8003484:	68e3      	ldr	r3, [r4, #12]
 8003486:	2b00      	cmp	r3, #0
 8003488:	f000 8110 	beq.w	80036ac <HAL_RCC_OscConfig+0x2bc>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 800348c:	4b7f      	ldr	r3, [pc, #508]	; (800368c <HAL_RCC_OscConfig+0x29c>)

        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800348e:	4e7e      	ldr	r6, [pc, #504]	; (8003688 <HAL_RCC_OscConfig+0x298>)
        __HAL_RCC_HSI_ENABLE();
 8003490:	2201      	movs	r2, #1
 8003492:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 8003494:	f7ff f8f8 	bl	8002688 <HAL_GetTick>
 8003498:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800349a:	e005      	b.n	80034a8 <HAL_RCC_OscConfig+0xb8>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 800349c:	f7ff f8f4 	bl	8002688 <HAL_GetTick>
 80034a0:	1b40      	subs	r0, r0, r5
 80034a2:	2802      	cmp	r0, #2
 80034a4:	f200 80df 	bhi.w	8003666 <HAL_RCC_OscConfig+0x276>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 80034a8:	6833      	ldr	r3, [r6, #0]
 80034aa:	0798      	lsls	r0, r3, #30
 80034ac:	d5f6      	bpl.n	800349c <HAL_RCC_OscConfig+0xac>
            return HAL_TIMEOUT;
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value. */
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 80034ae:	6833      	ldr	r3, [r6, #0]
 80034b0:	6922      	ldr	r2, [r4, #16]
 80034b2:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 80034b6:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
 80034ba:	6033      	str	r3, [r6, #0]
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 80034bc:	6823      	ldr	r3, [r4, #0]
 80034be:	071a      	lsls	r2, r3, #28
 80034c0:	d451      	bmi.n	8003566 <HAL_RCC_OscConfig+0x176>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 80034c2:	0758      	lsls	r0, r3, #29
 80034c4:	d52f      	bpl.n	8003526 <HAL_RCC_OscConfig+0x136>
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 80034c6:	4a70      	ldr	r2, [pc, #448]	; (8003688 <HAL_RCC_OscConfig+0x298>)
 80034c8:	6c13      	ldr	r3, [r2, #64]	; 0x40
 80034ca:	f013 5380 	ands.w	r3, r3, #268435456	; 0x10000000
 80034ce:	d07f      	beq.n	80035d0 <HAL_RCC_OscConfig+0x1e0>
    FlagStatus       pwrclkchanged = RESET;
 80034d0:	2500      	movs	r5, #0
    {
      __HAL_RCC_PWR_CLK_ENABLE();
      pwrclkchanged = SET;
    }

    if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 80034d2:	4e6f      	ldr	r6, [pc, #444]	; (8003690 <HAL_RCC_OscConfig+0x2a0>)
 80034d4:	6833      	ldr	r3, [r6, #0]
 80034d6:	05d9      	lsls	r1, r3, #23
 80034d8:	f140 80b5 	bpl.w	8003646 <HAL_RCC_OscConfig+0x256>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80034dc:	68a3      	ldr	r3, [r4, #8]
 80034de:	2b01      	cmp	r3, #1
 80034e0:	f000 80c5 	beq.w	800366e <HAL_RCC_OscConfig+0x27e>
 80034e4:	2b05      	cmp	r3, #5
 80034e6:	f000 812e 	beq.w	8003746 <HAL_RCC_OscConfig+0x356>
 80034ea:	4e67      	ldr	r6, [pc, #412]	; (8003688 <HAL_RCC_OscConfig+0x298>)
 80034ec:	6f32      	ldr	r2, [r6, #112]	; 0x70
 80034ee:	f022 0201 	bic.w	r2, r2, #1
 80034f2:	6732      	str	r2, [r6, #112]	; 0x70
 80034f4:	6f32      	ldr	r2, [r6, #112]	; 0x70
 80034f6:	f022 0204 	bic.w	r2, r2, #4
 80034fa:	6732      	str	r2, [r6, #112]	; 0x70
    /* Check the LSE State */
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
 80034fc:	2b00      	cmp	r3, #0
 80034fe:	f040 80bb 	bne.w	8003678 <HAL_RCC_OscConfig+0x288>
      }
    }
    else
    {
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 8003502:	f7ff f8c1 	bl	8002688 <HAL_GetTick>

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8003506:	f241 3888 	movw	r8, #5000	; 0x1388
      tickstart = HAL_GetTick();
 800350a:	4607      	mov	r7, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 800350c:	e005      	b.n	800351a <HAL_RCC_OscConfig+0x12a>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 800350e:	f7ff f8bb 	bl	8002688 <HAL_GetTick>
 8003512:	1bc0      	subs	r0, r0, r7
 8003514:	4540      	cmp	r0, r8
 8003516:	f200 80a6 	bhi.w	8003666 <HAL_RCC_OscConfig+0x276>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 800351a:	6f33      	ldr	r3, [r6, #112]	; 0x70
 800351c:	0798      	lsls	r0, r3, #30
 800351e:	d4f6      	bmi.n	800350e <HAL_RCC_OscConfig+0x11e>
        }
      }
    }

    /* Restore clock configuration if changed */
    if(pwrclkchanged == SET)
 8003520:	2d00      	cmp	r5, #0
 8003522:	f040 8108 	bne.w	8003736 <HAL_RCC_OscConfig+0x346>
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 8003526:	69a0      	ldr	r0, [r4, #24]
 8003528:	b1c8      	cbz	r0, 800355e <HAL_RCC_OscConfig+0x16e>
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 800352a:	4d57      	ldr	r5, [pc, #348]	; (8003688 <HAL_RCC_OscConfig+0x298>)
 800352c:	68ab      	ldr	r3, [r5, #8]
 800352e:	f003 030c 	and.w	r3, r3, #12
 8003532:	2b08      	cmp	r3, #8
 8003534:	f000 80cb 	beq.w	80036ce <HAL_RCC_OscConfig+0x2de>
        assert_param(IS_RCC_PLLN_VALUE(RCC_OscInitStruct->PLL.PLLN));
        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 8003538:	4b54      	ldr	r3, [pc, #336]	; (800368c <HAL_RCC_OscConfig+0x29c>)
 800353a:	2200      	movs	r2, #0
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 800353c:	2802      	cmp	r0, #2
        __HAL_RCC_PLL_DISABLE();
 800353e:	661a      	str	r2, [r3, #96]	; 0x60
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 8003540:	f000 810b 	beq.w	800375a <HAL_RCC_OscConfig+0x36a>
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8003544:	f7ff f8a0 	bl	8002688 <HAL_GetTick>
 8003548:	4604      	mov	r4, r0

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 800354a:	e005      	b.n	8003558 <HAL_RCC_OscConfig+0x168>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 800354c:	f7ff f89c 	bl	8002688 <HAL_GetTick>
 8003550:	1b00      	subs	r0, r0, r4
 8003552:	2802      	cmp	r0, #2
 8003554:	f200 8087 	bhi.w	8003666 <HAL_RCC_OscConfig+0x276>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8003558:	682b      	ldr	r3, [r5, #0]
 800355a:	019b      	lsls	r3, r3, #6
 800355c:	d4f6      	bmi.n	800354c <HAL_RCC_OscConfig+0x15c>
          return HAL_ERROR;
        }
      }
    }
  }
  return HAL_OK;
 800355e:	2000      	movs	r0, #0
}
 8003560:	b002      	add	sp, #8
 8003562:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
 8003566:	6963      	ldr	r3, [r4, #20]
 8003568:	b30b      	cbz	r3, 80035ae <HAL_RCC_OscConfig+0x1be>
      __HAL_RCC_LSI_ENABLE();
 800356a:	4b48      	ldr	r3, [pc, #288]	; (800368c <HAL_RCC_OscConfig+0x29c>)
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 800356c:	4e46      	ldr	r6, [pc, #280]	; (8003688 <HAL_RCC_OscConfig+0x298>)
      __HAL_RCC_LSI_ENABLE();
 800356e:	2201      	movs	r2, #1
 8003570:	f8c3 2e80 	str.w	r2, [r3, #3712]	; 0xe80
      tickstart = HAL_GetTick();
 8003574:	f7ff f888 	bl	8002688 <HAL_GetTick>
 8003578:	4605      	mov	r5, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 800357a:	e004      	b.n	8003586 <HAL_RCC_OscConfig+0x196>
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 800357c:	f7ff f884 	bl	8002688 <HAL_GetTick>
 8003580:	1b40      	subs	r0, r0, r5
 8003582:	2802      	cmp	r0, #2
 8003584:	d86f      	bhi.n	8003666 <HAL_RCC_OscConfig+0x276>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8003586:	6f73      	ldr	r3, [r6, #116]	; 0x74
 8003588:	079b      	lsls	r3, r3, #30
 800358a:	d5f7      	bpl.n	800357c <HAL_RCC_OscConfig+0x18c>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 800358c:	6823      	ldr	r3, [r4, #0]
 800358e:	e798      	b.n	80034c2 <HAL_RCC_OscConfig+0xd2>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 8003590:	6852      	ldr	r2, [r2, #4]
 8003592:	0256      	lsls	r6, r2, #9
 8003594:	f53f af76 	bmi.w	8003484 <HAL_RCC_OscConfig+0x94>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 8003598:	4a3b      	ldr	r2, [pc, #236]	; (8003688 <HAL_RCC_OscConfig+0x298>)
 800359a:	6812      	ldr	r2, [r2, #0]
 800359c:	0795      	lsls	r5, r2, #30
 800359e:	d546      	bpl.n	800362e <HAL_RCC_OscConfig+0x23e>
 80035a0:	68e2      	ldr	r2, [r4, #12]
 80035a2:	2a01      	cmp	r2, #1
 80035a4:	d043      	beq.n	800362e <HAL_RCC_OscConfig+0x23e>
        return HAL_ERROR;
 80035a6:	2001      	movs	r0, #1
}
 80035a8:	b002      	add	sp, #8
 80035aa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      __HAL_RCC_LSI_DISABLE();
 80035ae:	4a37      	ldr	r2, [pc, #220]	; (800368c <HAL_RCC_OscConfig+0x29c>)
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 80035b0:	4e35      	ldr	r6, [pc, #212]	; (8003688 <HAL_RCC_OscConfig+0x298>)
      __HAL_RCC_LSI_DISABLE();
 80035b2:	f8c2 3e80 	str.w	r3, [r2, #3712]	; 0xe80
      tickstart = HAL_GetTick();
 80035b6:	f7ff f867 	bl	8002688 <HAL_GetTick>
 80035ba:	4605      	mov	r5, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 80035bc:	e004      	b.n	80035c8 <HAL_RCC_OscConfig+0x1d8>
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 80035be:	f7ff f863 	bl	8002688 <HAL_GetTick>
 80035c2:	1b40      	subs	r0, r0, r5
 80035c4:	2802      	cmp	r0, #2
 80035c6:	d84e      	bhi.n	8003666 <HAL_RCC_OscConfig+0x276>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 80035c8:	6f73      	ldr	r3, [r6, #116]	; 0x74
 80035ca:	079f      	lsls	r7, r3, #30
 80035cc:	d4f7      	bmi.n	80035be <HAL_RCC_OscConfig+0x1ce>
 80035ce:	e7dd      	b.n	800358c <HAL_RCC_OscConfig+0x19c>
      __HAL_RCC_PWR_CLK_ENABLE();
 80035d0:	9301      	str	r3, [sp, #4]
 80035d2:	6c13      	ldr	r3, [r2, #64]	; 0x40
 80035d4:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 80035d8:	6413      	str	r3, [r2, #64]	; 0x40
 80035da:	6c13      	ldr	r3, [r2, #64]	; 0x40
 80035dc:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80035e0:	9301      	str	r3, [sp, #4]
 80035e2:	9b01      	ldr	r3, [sp, #4]
      pwrclkchanged = SET;
 80035e4:	2501      	movs	r5, #1
 80035e6:	e774      	b.n	80034d2 <HAL_RCC_OscConfig+0xe2>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 80035e8:	684a      	ldr	r2, [r1, #4]
 80035ea:	0250      	lsls	r0, r2, #9
 80035ec:	f57f af17 	bpl.w	800341e <HAL_RCC_OscConfig+0x2e>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 80035f0:	4a25      	ldr	r2, [pc, #148]	; (8003688 <HAL_RCC_OscConfig+0x298>)
 80035f2:	6812      	ldr	r2, [r2, #0]
 80035f4:	0391      	lsls	r1, r2, #14
 80035f6:	f57f af37 	bpl.w	8003468 <HAL_RCC_OscConfig+0x78>
 80035fa:	6862      	ldr	r2, [r4, #4]
 80035fc:	2a00      	cmp	r2, #0
 80035fe:	f47f af33 	bne.w	8003468 <HAL_RCC_OscConfig+0x78>
 8003602:	e7d0      	b.n	80035a6 <HAL_RCC_OscConfig+0x1b6>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8003604:	4a20      	ldr	r2, [pc, #128]	; (8003688 <HAL_RCC_OscConfig+0x298>)
 8003606:	6813      	ldr	r3, [r2, #0]
 8003608:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800360c:	6013      	str	r3, [r2, #0]
        tickstart = HAL_GetTick();
 800360e:	f7ff f83b 	bl	8002688 <HAL_GetTick>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8003612:	4e1d      	ldr	r6, [pc, #116]	; (8003688 <HAL_RCC_OscConfig+0x298>)
        tickstart = HAL_GetTick();
 8003614:	4605      	mov	r5, r0
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8003616:	f241 3788 	movw	r7, #5000	; 0x1388
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800361a:	e004      	b.n	8003626 <HAL_RCC_OscConfig+0x236>
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 800361c:	f7ff f834 	bl	8002688 <HAL_GetTick>
 8003620:	1b40      	subs	r0, r0, r5
 8003622:	42b8      	cmp	r0, r7
 8003624:	d81f      	bhi.n	8003666 <HAL_RCC_OscConfig+0x276>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8003626:	6833      	ldr	r3, [r6, #0]
 8003628:	039a      	lsls	r2, r3, #14
 800362a:	d5f7      	bpl.n	800361c <HAL_RCC_OscConfig+0x22c>
 800362c:	e71b      	b.n	8003466 <HAL_RCC_OscConfig+0x76>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 800362e:	4916      	ldr	r1, [pc, #88]	; (8003688 <HAL_RCC_OscConfig+0x298>)
 8003630:	6920      	ldr	r0, [r4, #16]
 8003632:	680a      	ldr	r2, [r1, #0]
 8003634:	f022 02f8 	bic.w	r2, r2, #248	; 0xf8
 8003638:	ea42 02c0 	orr.w	r2, r2, r0, lsl #3
 800363c:	600a      	str	r2, [r1, #0]
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 800363e:	071a      	lsls	r2, r3, #28
 8003640:	f57f af3f 	bpl.w	80034c2 <HAL_RCC_OscConfig+0xd2>
 8003644:	e78f      	b.n	8003566 <HAL_RCC_OscConfig+0x176>
      SET_BIT(PWR->CR, PWR_CR_DBP);
 8003646:	6833      	ldr	r3, [r6, #0]
 8003648:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800364c:	6033      	str	r3, [r6, #0]
      tickstart = HAL_GetTick();
 800364e:	f7ff f81b 	bl	8002688 <HAL_GetTick>
 8003652:	4607      	mov	r7, r0
      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8003654:	6833      	ldr	r3, [r6, #0]
 8003656:	05da      	lsls	r2, r3, #23
 8003658:	f53f af40 	bmi.w	80034dc <HAL_RCC_OscConfig+0xec>
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 800365c:	f7ff f814 	bl	8002688 <HAL_GetTick>
 8003660:	1bc0      	subs	r0, r0, r7
 8003662:	2802      	cmp	r0, #2
 8003664:	d9f6      	bls.n	8003654 <HAL_RCC_OscConfig+0x264>
            return HAL_TIMEOUT;
 8003666:	2003      	movs	r0, #3
}
 8003668:	b002      	add	sp, #8
 800366a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800366e:	4a06      	ldr	r2, [pc, #24]	; (8003688 <HAL_RCC_OscConfig+0x298>)
 8003670:	6f13      	ldr	r3, [r2, #112]	; 0x70
 8003672:	f043 0301 	orr.w	r3, r3, #1
 8003676:	6713      	str	r3, [r2, #112]	; 0x70
      tickstart = HAL_GetTick();
 8003678:	f7ff f806 	bl	8002688 <HAL_GetTick>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800367c:	4f02      	ldr	r7, [pc, #8]	; (8003688 <HAL_RCC_OscConfig+0x298>)
      tickstart = HAL_GetTick();
 800367e:	4606      	mov	r6, r0
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8003680:	f241 3888 	movw	r8, #5000	; 0x1388
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8003684:	e00b      	b.n	800369e <HAL_RCC_OscConfig+0x2ae>
 8003686:	bf00      	nop
 8003688:	40023800 	.word	0x40023800
 800368c:	42470000 	.word	0x42470000
 8003690:	40007000 	.word	0x40007000
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8003694:	f7fe fff8 	bl	8002688 <HAL_GetTick>
 8003698:	1b80      	subs	r0, r0, r6
 800369a:	4540      	cmp	r0, r8
 800369c:	d8e3      	bhi.n	8003666 <HAL_RCC_OscConfig+0x276>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800369e:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 80036a0:	079b      	lsls	r3, r3, #30
 80036a2:	d5f7      	bpl.n	8003694 <HAL_RCC_OscConfig+0x2a4>
    if(pwrclkchanged == SET)
 80036a4:	2d00      	cmp	r5, #0
 80036a6:	f43f af3e 	beq.w	8003526 <HAL_RCC_OscConfig+0x136>
 80036aa:	e044      	b.n	8003736 <HAL_RCC_OscConfig+0x346>
        __HAL_RCC_HSI_DISABLE();
 80036ac:	4a42      	ldr	r2, [pc, #264]	; (80037b8 <HAL_RCC_OscConfig+0x3c8>)
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 80036ae:	4e43      	ldr	r6, [pc, #268]	; (80037bc <HAL_RCC_OscConfig+0x3cc>)
        __HAL_RCC_HSI_DISABLE();
 80036b0:	6013      	str	r3, [r2, #0]
        tickstart = HAL_GetTick();
 80036b2:	f7fe ffe9 	bl	8002688 <HAL_GetTick>
 80036b6:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 80036b8:	e004      	b.n	80036c4 <HAL_RCC_OscConfig+0x2d4>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 80036ba:	f7fe ffe5 	bl	8002688 <HAL_GetTick>
 80036be:	1b40      	subs	r0, r0, r5
 80036c0:	2802      	cmp	r0, #2
 80036c2:	d8d0      	bhi.n	8003666 <HAL_RCC_OscConfig+0x276>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 80036c4:	6833      	ldr	r3, [r6, #0]
 80036c6:	0799      	lsls	r1, r3, #30
 80036c8:	d4f7      	bmi.n	80036ba <HAL_RCC_OscConfig+0x2ca>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 80036ca:	6823      	ldr	r3, [r4, #0]
 80036cc:	e6f7      	b.n	80034be <HAL_RCC_OscConfig+0xce>
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF)
 80036ce:	2801      	cmp	r0, #1
 80036d0:	f43f af46 	beq.w	8003560 <HAL_RCC_OscConfig+0x170>
        pll_config = RCC->PLLCFGR;
 80036d4:	686b      	ldr	r3, [r5, #4]
        if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 80036d6:	69e2      	ldr	r2, [r4, #28]
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 80036d8:	f403 0180 	and.w	r1, r3, #4194304	; 0x400000
        if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 80036dc:	4291      	cmp	r1, r2
 80036de:	f47f af62 	bne.w	80035a6 <HAL_RCC_OscConfig+0x1b6>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 80036e2:	6a22      	ldr	r2, [r4, #32]
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLM) != (RCC_OscInitStruct->PLL.PLLM) << RCC_PLLCFGR_PLLM_Pos) ||
 80036e4:	f003 013f 	and.w	r1, r3, #63	; 0x3f
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 80036e8:	4291      	cmp	r1, r2
 80036ea:	f47f af5c 	bne.w	80035a6 <HAL_RCC_OscConfig+0x1b6>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != (RCC_OscInitStruct->PLL.PLLN) << RCC_PLLCFGR_PLLN_Pos) ||
 80036ee:	6a61      	ldr	r1, [r4, #36]	; 0x24
 80036f0:	f647 72c0 	movw	r2, #32704	; 0x7fc0
 80036f4:	401a      	ands	r2, r3
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLM) != (RCC_OscInitStruct->PLL.PLLM) << RCC_PLLCFGR_PLLM_Pos) ||
 80036f6:	ebb2 1f81 	cmp.w	r2, r1, lsl #6
 80036fa:	f47f af54 	bne.w	80035a6 <HAL_RCC_OscConfig+0x1b6>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != (((RCC_OscInitStruct->PLL.PLLP >> 1U) - 1U)) << RCC_PLLCFGR_PLLP_Pos) ||
 80036fe:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8003700:	0852      	lsrs	r2, r2, #1
 8003702:	f403 3140 	and.w	r1, r3, #196608	; 0x30000
 8003706:	3a01      	subs	r2, #1
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != (RCC_OscInitStruct->PLL.PLLN) << RCC_PLLCFGR_PLLN_Pos) ||
 8003708:	ebb1 4f02 	cmp.w	r1, r2, lsl #16
 800370c:	f47f af4b 	bne.w	80035a6 <HAL_RCC_OscConfig+0x1b6>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ) != (RCC_OscInitStruct->PLL.PLLQ << RCC_PLLCFGR_PLLQ_Pos)))
 8003710:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8003712:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != (((RCC_OscInitStruct->PLL.PLLP >> 1U) - 1U)) << RCC_PLLCFGR_PLLP_Pos) ||
 8003716:	ebb3 6f02 	cmp.w	r3, r2, lsl #24
            return HAL_TIMEOUT;
 800371a:	bf14      	ite	ne
 800371c:	2001      	movne	r0, #1
 800371e:	2000      	moveq	r0, #0
 8003720:	e71e      	b.n	8003560 <HAL_RCC_OscConfig+0x170>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8003722:	4b26      	ldr	r3, [pc, #152]	; (80037bc <HAL_RCC_OscConfig+0x3cc>)
 8003724:	681a      	ldr	r2, [r3, #0]
 8003726:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 800372a:	601a      	str	r2, [r3, #0]
 800372c:	681a      	ldr	r2, [r3, #0]
 800372e:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8003732:	601a      	str	r2, [r3, #0]
      if((RCC_OscInitStruct->HSEState) != RCC_HSE_OFF)
 8003734:	e76b      	b.n	800360e <HAL_RCC_OscConfig+0x21e>
      __HAL_RCC_PWR_CLK_DISABLE();
 8003736:	4a21      	ldr	r2, [pc, #132]	; (80037bc <HAL_RCC_OscConfig+0x3cc>)
 8003738:	6c13      	ldr	r3, [r2, #64]	; 0x40
 800373a:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 800373e:	6413      	str	r3, [r2, #64]	; 0x40
 8003740:	e6f1      	b.n	8003526 <HAL_RCC_OscConfig+0x136>
    return HAL_ERROR;
 8003742:	2001      	movs	r0, #1
}
 8003744:	4770      	bx	lr
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8003746:	4b1d      	ldr	r3, [pc, #116]	; (80037bc <HAL_RCC_OscConfig+0x3cc>)
 8003748:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 800374a:	f042 0204 	orr.w	r2, r2, #4
 800374e:	671a      	str	r2, [r3, #112]	; 0x70
 8003750:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 8003752:	f042 0201 	orr.w	r2, r2, #1
 8003756:	671a      	str	r2, [r3, #112]	; 0x70
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
 8003758:	e78e      	b.n	8003678 <HAL_RCC_OscConfig+0x288>
        tickstart = HAL_GetTick();
 800375a:	f7fe ff95 	bl	8002688 <HAL_GetTick>
 800375e:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8003760:	e005      	b.n	800376e <HAL_RCC_OscConfig+0x37e>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8003762:	f7fe ff91 	bl	8002688 <HAL_GetTick>
 8003766:	1b80      	subs	r0, r0, r6
 8003768:	2802      	cmp	r0, #2
 800376a:	f63f af7c 	bhi.w	8003666 <HAL_RCC_OscConfig+0x276>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 800376e:	682b      	ldr	r3, [r5, #0]
 8003770:	0199      	lsls	r1, r3, #6
 8003772:	d4f6      	bmi.n	8003762 <HAL_RCC_OscConfig+0x372>
        WRITE_REG(RCC->PLLCFGR, (RCC_OscInitStruct->PLL.PLLSource                                            | \
 8003774:	e9d4 3107 	ldrd	r3, r1, [r4, #28]
 8003778:	6a62      	ldr	r2, [r4, #36]	; 0x24
 800377a:	430b      	orrs	r3, r1
 800377c:	ea43 1382 	orr.w	r3, r3, r2, lsl #6
 8003780:	e9d4 210a 	ldrd	r2, r1, [r4, #40]	; 0x28
 8003784:	0852      	lsrs	r2, r2, #1
 8003786:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
 800378a:	3a01      	subs	r2, #1
        __HAL_RCC_PLL_ENABLE();
 800378c:	490a      	ldr	r1, [pc, #40]	; (80037b8 <HAL_RCC_OscConfig+0x3c8>)
        WRITE_REG(RCC->PLLCFGR, (RCC_OscInitStruct->PLL.PLLSource                                            | \
 800378e:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
        __HAL_RCC_PLL_ENABLE();
 8003792:	2201      	movs	r2, #1
        WRITE_REG(RCC->PLLCFGR, (RCC_OscInitStruct->PLL.PLLSource                                            | \
 8003794:	606b      	str	r3, [r5, #4]
        __HAL_RCC_PLL_ENABLE();
 8003796:	660a      	str	r2, [r1, #96]	; 0x60
        tickstart = HAL_GetTick();
 8003798:	f7fe ff76 	bl	8002688 <HAL_GetTick>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 800379c:	4d07      	ldr	r5, [pc, #28]	; (80037bc <HAL_RCC_OscConfig+0x3cc>)
        tickstart = HAL_GetTick();
 800379e:	4604      	mov	r4, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 80037a0:	e005      	b.n	80037ae <HAL_RCC_OscConfig+0x3be>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 80037a2:	f7fe ff71 	bl	8002688 <HAL_GetTick>
 80037a6:	1b00      	subs	r0, r0, r4
 80037a8:	2802      	cmp	r0, #2
 80037aa:	f63f af5c 	bhi.w	8003666 <HAL_RCC_OscConfig+0x276>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 80037ae:	682b      	ldr	r3, [r5, #0]
 80037b0:	019a      	lsls	r2, r3, #6
 80037b2:	d5f6      	bpl.n	80037a2 <HAL_RCC_OscConfig+0x3b2>
 80037b4:	e6d3      	b.n	800355e <HAL_RCC_OscConfig+0x16e>
 80037b6:	bf00      	nop
 80037b8:	42470000 	.word	0x42470000
 80037bc:	40023800 	.word	0x40023800

080037c0 <HAL_RCC_GetSysClockFreq>:
{
  uint32_t pllm = 0U, pllvco = 0U, pllp = 0U;
  uint32_t sysclockfreq = 0U;

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 80037c0:	4916      	ldr	r1, [pc, #88]	; (800381c <HAL_RCC_GetSysClockFreq+0x5c>)
{
 80037c2:	b508      	push	{r3, lr}
  switch (RCC->CFGR & RCC_CFGR_SWS)
 80037c4:	688b      	ldr	r3, [r1, #8]
 80037c6:	f003 030c 	and.w	r3, r3, #12
 80037ca:	2b04      	cmp	r3, #4
 80037cc:	d01b      	beq.n	8003806 <HAL_RCC_GetSysClockFreq+0x46>
 80037ce:	2b08      	cmp	r3, #8
 80037d0:	d117      	bne.n	8003802 <HAL_RCC_GetSysClockFreq+0x42>
    }
    case RCC_CFGR_SWS_PLL:  /* PLL used as system clock  source */
    {
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLP */
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 80037d2:	684a      	ldr	r2, [r1, #4]
      if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 80037d4:	684b      	ldr	r3, [r1, #4]
      {
        /* HSE used as PLL clock source */
        pllvco = (uint32_t) ((((uint64_t) HSE_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 80037d6:	6849      	ldr	r1, [r1, #4]
      if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 80037d8:	f413 0380 	ands.w	r3, r3, #4194304	; 0x400000
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 80037dc:	f002 023f 	and.w	r2, r2, #63	; 0x3f
      if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 80037e0:	d113      	bne.n	800380a <HAL_RCC_GetSysClockFreq+0x4a>
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (uint32_t) ((((uint64_t) HSI_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 80037e2:	480f      	ldr	r0, [pc, #60]	; (8003820 <HAL_RCC_GetSysClockFreq+0x60>)
 80037e4:	f3c1 1188 	ubfx	r1, r1, #6, #9
 80037e8:	fba1 0100 	umull	r0, r1, r1, r0
 80037ec:	f7fc fcf4 	bl	80001d8 <__aeabi_uldivmod>
      }
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> RCC_PLLCFGR_PLLP_Pos) + 1U) *2U);
 80037f0:	4b0a      	ldr	r3, [pc, #40]	; (800381c <HAL_RCC_GetSysClockFreq+0x5c>)
 80037f2:	685b      	ldr	r3, [r3, #4]
 80037f4:	f3c3 4301 	ubfx	r3, r3, #16, #2
 80037f8:	3301      	adds	r3, #1
 80037fa:	005b      	lsls	r3, r3, #1

      sysclockfreq = pllvco/pllp;
 80037fc:	fbb0 f0f3 	udiv	r0, r0, r3
      sysclockfreq = HSI_VALUE;
      break;
    }
  }
  return sysclockfreq;
}
 8003800:	bd08      	pop	{r3, pc}
      sysclockfreq = HSI_VALUE;
 8003802:	4807      	ldr	r0, [pc, #28]	; (8003820 <HAL_RCC_GetSysClockFreq+0x60>)
}
 8003804:	bd08      	pop	{r3, pc}
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8003806:	4807      	ldr	r0, [pc, #28]	; (8003824 <HAL_RCC_GetSysClockFreq+0x64>)
}
 8003808:	bd08      	pop	{r3, pc}
        pllvco = (uint32_t) ((((uint64_t) HSE_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 800380a:	4806      	ldr	r0, [pc, #24]	; (8003824 <HAL_RCC_GetSysClockFreq+0x64>)
 800380c:	f3c1 1188 	ubfx	r1, r1, #6, #9
 8003810:	2300      	movs	r3, #0
 8003812:	fba1 0100 	umull	r0, r1, r1, r0
 8003816:	f7fc fcdf 	bl	80001d8 <__aeabi_uldivmod>
 800381a:	e7e9      	b.n	80037f0 <HAL_RCC_GetSysClockFreq+0x30>
 800381c:	40023800 	.word	0x40023800
 8003820:	00f42400 	.word	0x00f42400
 8003824:	007a1200 	.word	0x007a1200

08003828 <HAL_RCC_ClockConfig>:
  if(RCC_ClkInitStruct == NULL)
 8003828:	2800      	cmp	r0, #0
 800382a:	f000 8087 	beq.w	800393c <HAL_RCC_ClockConfig+0x114>
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 800382e:	4a48      	ldr	r2, [pc, #288]	; (8003950 <HAL_RCC_ClockConfig+0x128>)
 8003830:	6813      	ldr	r3, [r2, #0]
 8003832:	f003 0307 	and.w	r3, r3, #7
 8003836:	428b      	cmp	r3, r1
{
 8003838:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800383c:	460d      	mov	r5, r1
 800383e:	4604      	mov	r4, r0
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 8003840:	d209      	bcs.n	8003856 <HAL_RCC_ClockConfig+0x2e>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8003842:	b2cb      	uxtb	r3, r1
 8003844:	7013      	strb	r3, [r2, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 8003846:	6813      	ldr	r3, [r2, #0]
 8003848:	f003 0307 	and.w	r3, r3, #7
 800384c:	428b      	cmp	r3, r1
 800384e:	d002      	beq.n	8003856 <HAL_RCC_ClockConfig+0x2e>
    return HAL_ERROR;
 8003850:	2001      	movs	r0, #1
}
 8003852:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8003856:	6823      	ldr	r3, [r4, #0]
 8003858:	0798      	lsls	r0, r3, #30
 800385a:	d514      	bpl.n	8003886 <HAL_RCC_ClockConfig+0x5e>
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 800385c:	0759      	lsls	r1, r3, #29
 800385e:	d504      	bpl.n	800386a <HAL_RCC_ClockConfig+0x42>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_HCLK_DIV16);
 8003860:	493c      	ldr	r1, [pc, #240]	; (8003954 <HAL_RCC_ClockConfig+0x12c>)
 8003862:	688a      	ldr	r2, [r1, #8]
 8003864:	f442 52e0 	orr.w	r2, r2, #7168	; 0x1c00
 8003868:	608a      	str	r2, [r1, #8]
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 800386a:	071a      	lsls	r2, r3, #28
 800386c:	d504      	bpl.n	8003878 <HAL_RCC_ClockConfig+0x50>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, (RCC_HCLK_DIV16 << 3));
 800386e:	4939      	ldr	r1, [pc, #228]	; (8003954 <HAL_RCC_ClockConfig+0x12c>)
 8003870:	688a      	ldr	r2, [r1, #8]
 8003872:	f442 4260 	orr.w	r2, r2, #57344	; 0xe000
 8003876:	608a      	str	r2, [r1, #8]
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8003878:	4936      	ldr	r1, [pc, #216]	; (8003954 <HAL_RCC_ClockConfig+0x12c>)
 800387a:	68a0      	ldr	r0, [r4, #8]
 800387c:	688a      	ldr	r2, [r1, #8]
 800387e:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 8003882:	4302      	orrs	r2, r0
 8003884:	608a      	str	r2, [r1, #8]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8003886:	07df      	lsls	r7, r3, #31
 8003888:	d521      	bpl.n	80038ce <HAL_RCC_ClockConfig+0xa6>
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800388a:	6862      	ldr	r2, [r4, #4]
 800388c:	2a01      	cmp	r2, #1
 800388e:	d057      	beq.n	8003940 <HAL_RCC_ClockConfig+0x118>
    else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   ||
 8003890:	1e93      	subs	r3, r2, #2
 8003892:	2b01      	cmp	r3, #1
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8003894:	4b2f      	ldr	r3, [pc, #188]	; (8003954 <HAL_RCC_ClockConfig+0x12c>)
 8003896:	681b      	ldr	r3, [r3, #0]
    else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   ||
 8003898:	d94d      	bls.n	8003936 <HAL_RCC_ClockConfig+0x10e>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800389a:	0799      	lsls	r1, r3, #30
 800389c:	d5d8      	bpl.n	8003850 <HAL_RCC_ClockConfig+0x28>
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 800389e:	4e2d      	ldr	r6, [pc, #180]	; (8003954 <HAL_RCC_ClockConfig+0x12c>)
 80038a0:	68b3      	ldr	r3, [r6, #8]
 80038a2:	f023 0303 	bic.w	r3, r3, #3
 80038a6:	4313      	orrs	r3, r2
 80038a8:	60b3      	str	r3, [r6, #8]
    tickstart = HAL_GetTick();
 80038aa:	f7fe feed 	bl	8002688 <HAL_GetTick>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 80038ae:	f241 3888 	movw	r8, #5000	; 0x1388
    tickstart = HAL_GetTick();
 80038b2:	4607      	mov	r7, r0
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 80038b4:	e004      	b.n	80038c0 <HAL_RCC_ClockConfig+0x98>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 80038b6:	f7fe fee7 	bl	8002688 <HAL_GetTick>
 80038ba:	1bc0      	subs	r0, r0, r7
 80038bc:	4540      	cmp	r0, r8
 80038be:	d844      	bhi.n	800394a <HAL_RCC_ClockConfig+0x122>
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 80038c0:	68b3      	ldr	r3, [r6, #8]
 80038c2:	6862      	ldr	r2, [r4, #4]
 80038c4:	f003 030c 	and.w	r3, r3, #12
 80038c8:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
 80038cc:	d1f3      	bne.n	80038b6 <HAL_RCC_ClockConfig+0x8e>
  if(FLatency < __HAL_FLASH_GET_LATENCY())
 80038ce:	4a20      	ldr	r2, [pc, #128]	; (8003950 <HAL_RCC_ClockConfig+0x128>)
 80038d0:	6813      	ldr	r3, [r2, #0]
 80038d2:	f003 0307 	and.w	r3, r3, #7
 80038d6:	42ab      	cmp	r3, r5
 80038d8:	d906      	bls.n	80038e8 <HAL_RCC_ClockConfig+0xc0>
    __HAL_FLASH_SET_LATENCY(FLatency);
 80038da:	b2eb      	uxtb	r3, r5
 80038dc:	7013      	strb	r3, [r2, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 80038de:	6813      	ldr	r3, [r2, #0]
 80038e0:	f003 0307 	and.w	r3, r3, #7
 80038e4:	42ab      	cmp	r3, r5
 80038e6:	d1b3      	bne.n	8003850 <HAL_RCC_ClockConfig+0x28>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 80038e8:	6823      	ldr	r3, [r4, #0]
 80038ea:	075a      	lsls	r2, r3, #29
 80038ec:	d506      	bpl.n	80038fc <HAL_RCC_ClockConfig+0xd4>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 80038ee:	4919      	ldr	r1, [pc, #100]	; (8003954 <HAL_RCC_ClockConfig+0x12c>)
 80038f0:	68e0      	ldr	r0, [r4, #12]
 80038f2:	688a      	ldr	r2, [r1, #8]
 80038f4:	f422 52e0 	bic.w	r2, r2, #7168	; 0x1c00
 80038f8:	4302      	orrs	r2, r0
 80038fa:	608a      	str	r2, [r1, #8]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 80038fc:	071b      	lsls	r3, r3, #28
 80038fe:	d507      	bpl.n	8003910 <HAL_RCC_ClockConfig+0xe8>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
 8003900:	4a14      	ldr	r2, [pc, #80]	; (8003954 <HAL_RCC_ClockConfig+0x12c>)
 8003902:	6921      	ldr	r1, [r4, #16]
 8003904:	6893      	ldr	r3, [r2, #8]
 8003906:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
 800390a:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 800390e:	6093      	str	r3, [r2, #8]
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_Pos];
 8003910:	f7ff ff56 	bl	80037c0 <HAL_RCC_GetSysClockFreq>
 8003914:	4a0f      	ldr	r2, [pc, #60]	; (8003954 <HAL_RCC_ClockConfig+0x12c>)
 8003916:	4c10      	ldr	r4, [pc, #64]	; (8003958 <HAL_RCC_ClockConfig+0x130>)
 8003918:	6892      	ldr	r2, [r2, #8]
 800391a:	4910      	ldr	r1, [pc, #64]	; (800395c <HAL_RCC_ClockConfig+0x134>)
 800391c:	f3c2 1203 	ubfx	r2, r2, #4, #4
 8003920:	4603      	mov	r3, r0
 8003922:	5ca2      	ldrb	r2, [r4, r2]
  HAL_InitTick (uwTickPrio);
 8003924:	480e      	ldr	r0, [pc, #56]	; (8003960 <HAL_RCC_ClockConfig+0x138>)
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_Pos];
 8003926:	40d3      	lsrs	r3, r2
  HAL_InitTick (uwTickPrio);
 8003928:	6800      	ldr	r0, [r0, #0]
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_Pos];
 800392a:	600b      	str	r3, [r1, #0]
  HAL_InitTick (uwTickPrio);
 800392c:	f7fe fe64 	bl	80025f8 <HAL_InitTick>
  return HAL_OK;
 8003930:	2000      	movs	r0, #0
}
 8003932:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8003936:	0198      	lsls	r0, r3, #6
 8003938:	d4b1      	bmi.n	800389e <HAL_RCC_ClockConfig+0x76>
 800393a:	e789      	b.n	8003850 <HAL_RCC_ClockConfig+0x28>
    return HAL_ERROR;
 800393c:	2001      	movs	r0, #1
}
 800393e:	4770      	bx	lr
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8003940:	4b04      	ldr	r3, [pc, #16]	; (8003954 <HAL_RCC_ClockConfig+0x12c>)
 8003942:	681b      	ldr	r3, [r3, #0]
 8003944:	039e      	lsls	r6, r3, #14
 8003946:	d4aa      	bmi.n	800389e <HAL_RCC_ClockConfig+0x76>
 8003948:	e782      	b.n	8003850 <HAL_RCC_ClockConfig+0x28>
        return HAL_TIMEOUT;
 800394a:	2003      	movs	r0, #3
 800394c:	e781      	b.n	8003852 <HAL_RCC_ClockConfig+0x2a>
 800394e:	bf00      	nop
 8003950:	40023c00 	.word	0x40023c00
 8003954:	40023800 	.word	0x40023800
 8003958:	08009c3c 	.word	0x08009c3c
 800395c:	20000078 	.word	0x20000078
 8003960:	20000080 	.word	0x20000080

08003964 <HAL_RCC_GetHCLKFreq>:
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
  return SystemCoreClock;
 8003964:	4b01      	ldr	r3, [pc, #4]	; (800396c <HAL_RCC_GetHCLKFreq+0x8>)
}
 8003966:	6818      	ldr	r0, [r3, #0]
 8003968:	4770      	bx	lr
 800396a:	bf00      	nop
 800396c:	20000078 	.word	0x20000078

08003970 <HAL_RCCEx_PeriphCLKConfig>:
  *        domain (RTC and RCC_BDCR register expect BKPSRAM) will be reset
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 8003970:	b5f0      	push	{r4, r5, r6, r7, lr}

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*---------------------------- I2S configuration ---------------------------*/
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == RCC_PERIPHCLK_I2S) ||
 8003972:	6803      	ldr	r3, [r0, #0]
 8003974:	f013 0f05 	tst.w	r3, #5
{
 8003978:	b083      	sub	sp, #12
 800397a:	4604      	mov	r4, r0
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == RCC_PERIPHCLK_I2S) ||
 800397c:	d10e      	bne.n	800399c <HAL_RCCEx_PeriphCLKConfig+0x2c>
      }
    }
  }

  /*---------------------------- RTC configuration ---------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))
 800397e:	0798      	lsls	r0, r3, #30
 8003980:	d445      	bmi.n	8003a0e <HAL_RCCEx_PeriphCLKConfig+0x9e>
    }
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
  }
#if defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F411xE)
  /*---------------------------- TIM configuration ---------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == (RCC_PERIPHCLK_TIM))
 8003982:	f013 0308 	ands.w	r3, r3, #8
 8003986:	d102      	bne.n	800398e <HAL_RCCEx_PeriphCLKConfig+0x1e>
  {
    __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);
  }
#endif /* STM32F401xC || STM32F401xE || STM32F411xE */
  return HAL_OK;
 8003988:	4618      	mov	r0, r3
}
 800398a:	b003      	add	sp, #12
 800398c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);
 800398e:	4b49      	ldr	r3, [pc, #292]	; (8003ab4 <HAL_RCCEx_PeriphCLKConfig+0x144>)
 8003990:	7c22      	ldrb	r2, [r4, #16]
 8003992:	f8c3 21e0 	str.w	r2, [r3, #480]	; 0x1e0
  return HAL_OK;
 8003996:	2000      	movs	r0, #0
}
 8003998:	b003      	add	sp, #12
 800399a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    __HAL_RCC_PLLI2S_DISABLE();
 800399c:	4b46      	ldr	r3, [pc, #280]	; (8003ab8 <HAL_RCCEx_PeriphCLKConfig+0x148>)
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
 800399e:	4e47      	ldr	r6, [pc, #284]	; (8003abc <HAL_RCCEx_PeriphCLKConfig+0x14c>)
    __HAL_RCC_PLLI2S_DISABLE();
 80039a0:	2200      	movs	r2, #0
 80039a2:	669a      	str	r2, [r3, #104]	; 0x68
    tickstart = HAL_GetTick();
 80039a4:	f7fe fe70 	bl	8002688 <HAL_GetTick>
 80039a8:	4605      	mov	r5, r0
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
 80039aa:	e004      	b.n	80039b6 <HAL_RCCEx_PeriphCLKConfig+0x46>
      if((HAL_GetTick() - tickstart ) > PLLI2S_TIMEOUT_VALUE)
 80039ac:	f7fe fe6c 	bl	8002688 <HAL_GetTick>
 80039b0:	1b43      	subs	r3, r0, r5
 80039b2:	2b02      	cmp	r3, #2
 80039b4:	d828      	bhi.n	8003a08 <HAL_RCCEx_PeriphCLKConfig+0x98>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
 80039b6:	6833      	ldr	r3, [r6, #0]
 80039b8:	011b      	lsls	r3, r3, #4
 80039ba:	d4f7      	bmi.n	80039ac <HAL_RCCEx_PeriphCLKConfig+0x3c>
    __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SR);
 80039bc:	e9d4 1301 	ldrd	r1, r3, [r4, #4]
 80039c0:	071b      	lsls	r3, r3, #28
 80039c2:	ea43 1381 	orr.w	r3, r3, r1, lsl #6
    __HAL_RCC_PLLI2S_ENABLE();
 80039c6:	4a3c      	ldr	r2, [pc, #240]	; (8003ab8 <HAL_RCCEx_PeriphCLKConfig+0x148>)
    __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SR);
 80039c8:	f8c6 3084 	str.w	r3, [r6, #132]	; 0x84
    __HAL_RCC_PLLI2S_ENABLE();
 80039cc:	2301      	movs	r3, #1
 80039ce:	6693      	str	r3, [r2, #104]	; 0x68
    tickstart = HAL_GetTick();
 80039d0:	f7fe fe5a 	bl	8002688 <HAL_GetTick>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
 80039d4:	4e39      	ldr	r6, [pc, #228]	; (8003abc <HAL_RCCEx_PeriphCLKConfig+0x14c>)
    tickstart = HAL_GetTick();
 80039d6:	4605      	mov	r5, r0
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
 80039d8:	e004      	b.n	80039e4 <HAL_RCCEx_PeriphCLKConfig+0x74>
      if((HAL_GetTick() - tickstart ) > PLLI2S_TIMEOUT_VALUE)
 80039da:	f7fe fe55 	bl	8002688 <HAL_GetTick>
 80039de:	1b40      	subs	r0, r0, r5
 80039e0:	2802      	cmp	r0, #2
 80039e2:	d811      	bhi.n	8003a08 <HAL_RCCEx_PeriphCLKConfig+0x98>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
 80039e4:	6833      	ldr	r3, [r6, #0]
 80039e6:	011f      	lsls	r7, r3, #4
 80039e8:	d5f7      	bpl.n	80039da <HAL_RCCEx_PeriphCLKConfig+0x6a>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))
 80039ea:	6823      	ldr	r3, [r4, #0]
 80039ec:	e7c7      	b.n	800397e <HAL_RCCEx_PeriphCLKConfig+0xe>
        tickstart = HAL_GetTick();
 80039ee:	f7fe fe4b 	bl	8002688 <HAL_GetTick>
          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 80039f2:	f241 3788 	movw	r7, #5000	; 0x1388
        tickstart = HAL_GetTick();
 80039f6:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 80039f8:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 80039fa:	079b      	lsls	r3, r3, #30
 80039fc:	d43c      	bmi.n	8003a78 <HAL_RCCEx_PeriphCLKConfig+0x108>
          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 80039fe:	f7fe fe43 	bl	8002688 <HAL_GetTick>
 8003a02:	1b80      	subs	r0, r0, r6
 8003a04:	42b8      	cmp	r0, r7
 8003a06:	d9f7      	bls.n	80039f8 <HAL_RCCEx_PeriphCLKConfig+0x88>
        return HAL_TIMEOUT;
 8003a08:	2003      	movs	r0, #3
}
 8003a0a:	b003      	add	sp, #12
 8003a0c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    __HAL_RCC_PWR_CLK_ENABLE();
 8003a0e:	4b2b      	ldr	r3, [pc, #172]	; (8003abc <HAL_RCCEx_PeriphCLKConfig+0x14c>)
    PWR->CR |= PWR_CR_DBP;
 8003a10:	4d2b      	ldr	r5, [pc, #172]	; (8003ac0 <HAL_RCCEx_PeriphCLKConfig+0x150>)
    __HAL_RCC_PWR_CLK_ENABLE();
 8003a12:	2200      	movs	r2, #0
 8003a14:	9201      	str	r2, [sp, #4]
 8003a16:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8003a18:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8003a1c:	641a      	str	r2, [r3, #64]	; 0x40
 8003a1e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8003a20:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8003a24:	9301      	str	r3, [sp, #4]
 8003a26:	9b01      	ldr	r3, [sp, #4]
    PWR->CR |= PWR_CR_DBP;
 8003a28:	682b      	ldr	r3, [r5, #0]
 8003a2a:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8003a2e:	602b      	str	r3, [r5, #0]
    tickstart = HAL_GetTick();
 8003a30:	f7fe fe2a 	bl	8002688 <HAL_GetTick>
 8003a34:	4606      	mov	r6, r0
    while((PWR->CR & PWR_CR_DBP) == RESET)
 8003a36:	e004      	b.n	8003a42 <HAL_RCCEx_PeriphCLKConfig+0xd2>
      if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
 8003a38:	f7fe fe26 	bl	8002688 <HAL_GetTick>
 8003a3c:	1b83      	subs	r3, r0, r6
 8003a3e:	2b02      	cmp	r3, #2
 8003a40:	d8e2      	bhi.n	8003a08 <HAL_RCCEx_PeriphCLKConfig+0x98>
    while((PWR->CR & PWR_CR_DBP) == RESET)
 8003a42:	682b      	ldr	r3, [r5, #0]
 8003a44:	05d9      	lsls	r1, r3, #23
 8003a46:	d5f7      	bpl.n	8003a38 <HAL_RCCEx_PeriphCLKConfig+0xc8>
    tmpreg1 = (RCC->BDCR & RCC_BDCR_RTCSEL);
 8003a48:	4d1c      	ldr	r5, [pc, #112]	; (8003abc <HAL_RCCEx_PeriphCLKConfig+0x14c>)
    if((tmpreg1 != 0x00000000U) && ((tmpreg1) != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
 8003a4a:	68e3      	ldr	r3, [r4, #12]
    tmpreg1 = (RCC->BDCR & RCC_BDCR_RTCSEL);
 8003a4c:	6f2a      	ldr	r2, [r5, #112]	; 0x70
    if((tmpreg1 != 0x00000000U) && ((tmpreg1) != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
 8003a4e:	f412 7240 	ands.w	r2, r2, #768	; 0x300
 8003a52:	d012      	beq.n	8003a7a <HAL_RCCEx_PeriphCLKConfig+0x10a>
 8003a54:	f403 7140 	and.w	r1, r3, #768	; 0x300
 8003a58:	4291      	cmp	r1, r2
 8003a5a:	d010      	beq.n	8003a7e <HAL_RCCEx_PeriphCLKConfig+0x10e>
      tmpreg1 = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 8003a5c:	6f2b      	ldr	r3, [r5, #112]	; 0x70
      __HAL_RCC_BACKUPRESET_FORCE();
 8003a5e:	4a16      	ldr	r2, [pc, #88]	; (8003ab8 <HAL_RCCEx_PeriphCLKConfig+0x148>)
 8003a60:	2101      	movs	r1, #1
 8003a62:	f8c2 1e40 	str.w	r1, [r2, #3648]	; 0xe40
      tmpreg1 = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 8003a66:	f423 7340 	bic.w	r3, r3, #768	; 0x300
      __HAL_RCC_BACKUPRESET_RELEASE();
 8003a6a:	2100      	movs	r1, #0
 8003a6c:	f8c2 1e40 	str.w	r1, [r2, #3648]	; 0xe40
      RCC->BDCR = tmpreg1;
 8003a70:	672b      	str	r3, [r5, #112]	; 0x70
      if(HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSEON))
 8003a72:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 8003a74:	07da      	lsls	r2, r3, #31
 8003a76:	d4ba      	bmi.n	80039ee <HAL_RCCEx_PeriphCLKConfig+0x7e>
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 8003a78:	68e3      	ldr	r3, [r4, #12]
 8003a7a:	f403 7240 	and.w	r2, r3, #768	; 0x300
 8003a7e:	f5b2 7f40 	cmp.w	r2, #768	; 0x300
 8003a82:	d00c      	beq.n	8003a9e <HAL_RCCEx_PeriphCLKConfig+0x12e>
 8003a84:	490d      	ldr	r1, [pc, #52]	; (8003abc <HAL_RCCEx_PeriphCLKConfig+0x14c>)
 8003a86:	688a      	ldr	r2, [r1, #8]
 8003a88:	f422 12f8 	bic.w	r2, r2, #2031616	; 0x1f0000
 8003a8c:	608a      	str	r2, [r1, #8]
 8003a8e:	4a0b      	ldr	r2, [pc, #44]	; (8003abc <HAL_RCCEx_PeriphCLKConfig+0x14c>)
 8003a90:	6f11      	ldr	r1, [r2, #112]	; 0x70
 8003a92:	f3c3 030b 	ubfx	r3, r3, #0, #12
 8003a96:	430b      	orrs	r3, r1
 8003a98:	6713      	str	r3, [r2, #112]	; 0x70
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == (RCC_PERIPHCLK_TIM))
 8003a9a:	6823      	ldr	r3, [r4, #0]
 8003a9c:	e771      	b.n	8003982 <HAL_RCCEx_PeriphCLKConfig+0x12>
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 8003a9e:	4807      	ldr	r0, [pc, #28]	; (8003abc <HAL_RCCEx_PeriphCLKConfig+0x14c>)
 8003aa0:	6882      	ldr	r2, [r0, #8]
 8003aa2:	f023 4170 	bic.w	r1, r3, #4026531840	; 0xf0000000
 8003aa6:	f421 7140 	bic.w	r1, r1, #768	; 0x300
 8003aaa:	f422 12f8 	bic.w	r2, r2, #2031616	; 0x1f0000
 8003aae:	430a      	orrs	r2, r1
 8003ab0:	6082      	str	r2, [r0, #8]
 8003ab2:	e7ec      	b.n	8003a8e <HAL_RCCEx_PeriphCLKConfig+0x11e>
 8003ab4:	42471000 	.word	0x42471000
 8003ab8:	42470000 	.word	0x42470000
 8003abc:	40023800 	.word	0x40023800
 8003ac0:	40007000 	.word	0x40007000

08003ac4 <HAL_RCCEx_GetPeriphCLKConfig>:

  /* Set all possible values for the extended clock type parameter------------*/
  PeriphClkInit->PeriphClockSelection = RCC_PERIPHCLK_I2S | RCC_PERIPHCLK_RTC;

  /* Get the PLLI2S Clock configuration --------------------------------------*/
  PeriphClkInit->PLLI2S.PLLI2SN = (uint32_t)((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> RCC_PLLI2SCFGR_PLLI2SN_Pos);
 8003ac4:	4b0d      	ldr	r3, [pc, #52]	; (8003afc <HAL_RCCEx_GetPeriphCLKConfig+0x38>)
  PeriphClkInit->PeriphClockSelection = RCC_PERIPHCLK_I2S | RCC_PERIPHCLK_RTC;
 8003ac6:	2203      	movs	r2, #3
 8003ac8:	6002      	str	r2, [r0, #0]
  PeriphClkInit->PLLI2S.PLLI2SN = (uint32_t)((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> RCC_PLLI2SCFGR_PLLI2SN_Pos);
 8003aca:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
 8003ace:	f3c2 1288 	ubfx	r2, r2, #6, #9
 8003ad2:	6042      	str	r2, [r0, #4]
  PeriphClkInit->PLLI2S.PLLI2SR = (uint32_t)((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLI2SCFGR_PLLI2SR_Pos);
 8003ad4:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
 8003ad8:	f3c2 7202 	ubfx	r2, r2, #28, #3
 8003adc:	6082      	str	r2, [r0, #8]
#if defined(STM32F411xE)
  PeriphClkInit->PLLI2S.PLLI2SM = (uint32_t)(RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SM);
#endif /* STM32F411xE */
  /* Get the RTC Clock configuration -----------------------------------------*/
  tempreg = (RCC->CFGR & RCC_CFGR_RTCPRE);
 8003ade:	6899      	ldr	r1, [r3, #8]
  PeriphClkInit->RTCClockSelection = (uint32_t)((tempreg) | (RCC->BDCR & RCC_BDCR_RTCSEL));
 8003ae0:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  tempreg = (RCC->CFGR & RCC_CFGR_RTCPRE);
 8003ae2:	f401 11f8 	and.w	r1, r1, #2031616	; 0x1f0000
  PeriphClkInit->RTCClockSelection = (uint32_t)((tempreg) | (RCC->BDCR & RCC_BDCR_RTCSEL));
 8003ae6:	f402 7240 	and.w	r2, r2, #768	; 0x300
 8003aea:	430a      	orrs	r2, r1
 8003aec:	60c2      	str	r2, [r0, #12]

#if defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F411xE)
  /* Get the TIM Prescaler configuration -------------------------------------*/
  if ((RCC->DCKCFGR & RCC_DCKCFGR_TIMPRE) == RESET)
 8003aee:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8003af2:	f3c3 6300 	ubfx	r3, r3, #24, #1
 8003af6:	7403      	strb	r3, [r0, #16]
  else
  {
    PeriphClkInit->TIMPresSelection = RCC_TIMPRES_ACTIVATED;
  }
#endif /* STM32F401xC || STM32F401xE || STM32F411xE */
}
 8003af8:	4770      	bx	lr
 8003afa:	bf00      	nop
 8003afc:	40023800 	.word	0x40023800

08003b00 <HAL_RCCEx_GetPeriphCLKFreq>:
  /* This variable used to store the VCO Input (value in Hz) */
  uint32_t vcoinput = 0U;
  uint32_t srcclk = 0U;
  /* This variable used to store the VCO Output (value in Hz) */
  uint32_t vcooutput = 0U;
  switch (PeriphClk)
 8003b00:	2801      	cmp	r0, #1
 8003b02:	d001      	beq.n	8003b08 <HAL_RCCEx_GetPeriphCLKFreq+0x8>
 8003b04:	2000      	movs	r0, #0
      }
      break;
    }
  }
  return frequency;
}
 8003b06:	4770      	bx	lr
      srcclk = __HAL_RCC_GET_I2S_SOURCE();
 8003b08:	4b0e      	ldr	r3, [pc, #56]	; (8003b44 <HAL_RCCEx_GetPeriphCLKFreq+0x44>)
 8003b0a:	689a      	ldr	r2, [r3, #8]
      switch (srcclk)
 8003b0c:	0212      	lsls	r2, r2, #8
 8003b0e:	d4f9      	bmi.n	8003b04 <HAL_RCCEx_GetPeriphCLKFreq+0x4>
          if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSE)
 8003b10:	685a      	ldr	r2, [r3, #4]
 8003b12:	f412 0f80 	tst.w	r2, #4194304	; 0x400000
            vcoinput = (uint32_t)(HSE_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));
 8003b16:	685a      	ldr	r2, [r3, #4]
          vcooutput = (uint32_t)(vcoinput * (((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6U) & (RCC_PLLI2SCFGR_PLLI2SN >> 6U)));
 8003b18:	4b0a      	ldr	r3, [pc, #40]	; (8003b44 <HAL_RCCEx_GetPeriphCLKFreq+0x44>)
            vcoinput = (uint32_t)(HSE_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));
 8003b1a:	bf14      	ite	ne
 8003b1c:	480a      	ldrne	r0, [pc, #40]	; (8003b48 <HAL_RCCEx_GetPeriphCLKFreq+0x48>)
            vcoinput = (uint32_t)(HSI_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));
 8003b1e:	480b      	ldreq	r0, [pc, #44]	; (8003b4c <HAL_RCCEx_GetPeriphCLKFreq+0x4c>)
 8003b20:	f002 023f 	and.w	r2, r2, #63	; 0x3f
 8003b24:	fbb0 f2f2 	udiv	r2, r0, r2
          vcooutput = (uint32_t)(vcoinput * (((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6U) & (RCC_PLLI2SCFGR_PLLI2SN >> 6U)));
 8003b28:	f8d3 0084 	ldr.w	r0, [r3, #132]	; 0x84
          frequency = (uint32_t)(vcooutput /(((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> 28U) & (RCC_PLLI2SCFGR_PLLI2SR >> 28U)));
 8003b2c:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
          vcooutput = (uint32_t)(vcoinput * (((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6U) & (RCC_PLLI2SCFGR_PLLI2SN >> 6U)));
 8003b30:	f3c0 1088 	ubfx	r0, r0, #6, #9
 8003b34:	fb02 f000 	mul.w	r0, r2, r0
          frequency = (uint32_t)(vcooutput /(((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> 28U) & (RCC_PLLI2SCFGR_PLLI2SR >> 28U)));
 8003b38:	f3c3 7302 	ubfx	r3, r3, #28, #3
 8003b3c:	fbb0 f0f3 	udiv	r0, r0, r3
          break;
 8003b40:	4770      	bx	lr
 8003b42:	bf00      	nop
 8003b44:	40023800 	.word	0x40023800
 8003b48:	007a1200 	.word	0x007a1200
 8003b4c:	00f42400 	.word	0x00f42400

08003b50 <SPI_WaitFlagStateUntilTimeout.constprop.0>:
  * @param  State flag state to check
  * @param  Timeout Timeout duration
  * @param  Tickstart tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_WaitFlagStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Flag, FlagStatus State,
 8003b50:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8003b54:	b082      	sub	sp, #8
 8003b56:	461d      	mov	r5, r3
 8003b58:	4616      	mov	r6, r2
 8003b5a:	460c      	mov	r4, r1
 8003b5c:	4607      	mov	r7, r0
  __IO uint32_t count;
  uint32_t tmp_timeout;
  uint32_t tmp_tickstart;

  /* Adjust Timeout value  in case of end of transfer */
  tmp_timeout   = Timeout - (HAL_GetTick() - Tickstart);
 8003b5e:	f7fe fd93 	bl	8002688 <HAL_GetTick>
 8003b62:	4435      	add	r5, r6
 8003b64:	1a2d      	subs	r5, r5, r0
  tmp_tickstart = HAL_GetTick();
 8003b66:	f7fe fd8f 	bl	8002688 <HAL_GetTick>

  /* Calculate Timeout based on a software loop to avoid blocking issue if Systick is disabled */
  count = tmp_timeout * ((SystemCoreClock * 32U) >> 20U);
 8003b6a:	4b28      	ldr	r3, [pc, #160]	; (8003c0c <SPI_WaitFlagStateUntilTimeout.constprop.0+0xbc>)
 8003b6c:	681b      	ldr	r3, [r3, #0]
 8003b6e:	f3c3 33cb 	ubfx	r3, r3, #15, #12
 8003b72:	fb05 f303 	mul.w	r3, r5, r3
  tmp_tickstart = HAL_GetTick();
 8003b76:	4680      	mov	r8, r0
  count = tmp_timeout * ((SystemCoreClock * 32U) >> 20U);
 8003b78:	9301      	str	r3, [sp, #4]

  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 8003b7a:	1c73      	adds	r3, r6, #1
 8003b7c:	6839      	ldr	r1, [r7, #0]
 8003b7e:	d107      	bne.n	8003b90 <SPI_WaitFlagStateUntilTimeout.constprop.0+0x40>
 8003b80:	688b      	ldr	r3, [r1, #8]
 8003b82:	ea34 0303 	bics.w	r3, r4, r3
 8003b86:	d0fb      	beq.n	8003b80 <SPI_WaitFlagStateUntilTimeout.constprop.0+0x30>
      }
      count--;
    }
  }

  return HAL_OK;
 8003b88:	2000      	movs	r0, #0
}
 8003b8a:	b002      	add	sp, #8
 8003b8c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 8003b90:	688b      	ldr	r3, [r1, #8]
 8003b92:	ea34 0303 	bics.w	r3, r4, r3
 8003b96:	d1f7      	bne.n	8003b88 <SPI_WaitFlagStateUntilTimeout.constprop.0+0x38>
      if (((HAL_GetTick() - tmp_tickstart) >= tmp_timeout) || (tmp_timeout == 0U))
 8003b98:	f7fe fd76 	bl	8002688 <HAL_GetTick>
 8003b9c:	eba0 0008 	sub.w	r0, r0, r8
 8003ba0:	42a8      	cmp	r0, r5
 8003ba2:	d208      	bcs.n	8003bb6 <SPI_WaitFlagStateUntilTimeout.constprop.0+0x66>
      if (count == 0U)
 8003ba4:	9b01      	ldr	r3, [sp, #4]
        tmp_timeout = 0U;
 8003ba6:	2b00      	cmp	r3, #0
      count--;
 8003ba8:	9b01      	ldr	r3, [sp, #4]
 8003baa:	f103 33ff 	add.w	r3, r3, #4294967295	; 0xffffffff
        tmp_timeout = 0U;
 8003bae:	bf08      	it	eq
 8003bb0:	2500      	moveq	r5, #0
      count--;
 8003bb2:	9301      	str	r3, [sp, #4]
 8003bb4:	e7e1      	b.n	8003b7a <SPI_WaitFlagStateUntilTimeout.constprop.0+0x2a>
        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8003bb6:	e9d7 3100 	ldrd	r3, r1, [r7]
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 8003bba:	685a      	ldr	r2, [r3, #4]
        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8003bbc:	f5b1 7f82 	cmp.w	r1, #260	; 0x104
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 8003bc0:	f022 02e0 	bic.w	r2, r2, #224	; 0xe0
 8003bc4:	605a      	str	r2, [r3, #4]
        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8003bc6:	d014      	beq.n	8003bf2 <SPI_WaitFlagStateUntilTimeout.constprop.0+0xa2>
        if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8003bc8:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8003bca:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
 8003bce:	d007      	beq.n	8003be0 <SPI_WaitFlagStateUntilTimeout.constprop.0+0x90>
        hspi->State = HAL_SPI_STATE_READY;
 8003bd0:	2201      	movs	r2, #1
        __HAL_UNLOCK(hspi);
 8003bd2:	2300      	movs	r3, #0
        hspi->State = HAL_SPI_STATE_READY;
 8003bd4:	f887 2051 	strb.w	r2, [r7, #81]	; 0x51
        __HAL_UNLOCK(hspi);
 8003bd8:	f887 3050 	strb.w	r3, [r7, #80]	; 0x50
 8003bdc:	2003      	movs	r0, #3
 8003bde:	e7d4      	b.n	8003b8a <SPI_WaitFlagStateUntilTimeout.constprop.0+0x3a>
          SPI_RESET_CRC(hspi);
 8003be0:	681a      	ldr	r2, [r3, #0]
 8003be2:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 8003be6:	601a      	str	r2, [r3, #0]
 8003be8:	681a      	ldr	r2, [r3, #0]
 8003bea:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 8003bee:	601a      	str	r2, [r3, #0]
 8003bf0:	e7ee      	b.n	8003bd0 <SPI_WaitFlagStateUntilTimeout.constprop.0+0x80>
        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8003bf2:	68ba      	ldr	r2, [r7, #8]
 8003bf4:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
 8003bf8:	d002      	beq.n	8003c00 <SPI_WaitFlagStateUntilTimeout.constprop.0+0xb0>
                                                     || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 8003bfa:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
 8003bfe:	d1e3      	bne.n	8003bc8 <SPI_WaitFlagStateUntilTimeout.constprop.0+0x78>
          __HAL_SPI_DISABLE(hspi);
 8003c00:	681a      	ldr	r2, [r3, #0]
 8003c02:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8003c06:	601a      	str	r2, [r3, #0]
 8003c08:	e7de      	b.n	8003bc8 <SPI_WaitFlagStateUntilTimeout.constprop.0+0x78>
 8003c0a:	bf00      	nop
 8003c0c:	20000078 	.word	0x20000078

08003c10 <HAL_SPI_MspInit>:
}
 8003c10:	4770      	bx	lr
 8003c12:	bf00      	nop

08003c14 <HAL_SPI_Init>:
  if (hspi == NULL)
 8003c14:	2800      	cmp	r0, #0
 8003c16:	d05c      	beq.n	8003cd2 <HAL_SPI_Init+0xbe>
  if (hspi->Init.TIMode == SPI_TIMODE_DISABLE)
 8003c18:	6a41      	ldr	r1, [r0, #36]	; 0x24
{
 8003c1a:	b570      	push	{r4, r5, r6, lr}
 8003c1c:	4604      	mov	r4, r0
  if (hspi->Init.TIMode == SPI_TIMODE_DISABLE)
 8003c1e:	2900      	cmp	r1, #0
 8003c20:	d047      	beq.n	8003cb2 <HAL_SPI_Init+0x9e>
    hspi->Init.CLKPolarity = SPI_POLARITY_LOW;
 8003c22:	2300      	movs	r3, #0
    hspi->Init.CLKPhase    = SPI_PHASE_1EDGE;
 8003c24:	e9c0 3304 	strd	r3, r3, [r0, #16]
  if (hspi->State == HAL_SPI_STATE_RESET)
 8003c28:	f894 2051 	ldrb.w	r2, [r4, #81]	; 0x51
  hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8003c2c:	2300      	movs	r3, #0
 8003c2e:	62a3      	str	r3, [r4, #40]	; 0x28
  if (hspi->State == HAL_SPI_STATE_RESET)
 8003c30:	f002 00ff 	and.w	r0, r2, #255	; 0xff
 8003c34:	2a00      	cmp	r2, #0
 8003c36:	d042      	beq.n	8003cbe <HAL_SPI_Init+0xaa>
 8003c38:	469c      	mov	ip, r3
  __HAL_SPI_DISABLE(hspi);
 8003c3a:	6825      	ldr	r5, [r4, #0]
  WRITE_REG(hspi->Instance->CR1, ((hspi->Init.Mode & (SPI_CR1_MSTR | SPI_CR1_SSI)) |
 8003c3c:	68a2      	ldr	r2, [r4, #8]
  hspi->State = HAL_SPI_STATE_BUSY;
 8003c3e:	2302      	movs	r3, #2
 8003c40:	f884 3051 	strb.w	r3, [r4, #81]	; 0x51
  __HAL_SPI_DISABLE(hspi);
 8003c44:	682b      	ldr	r3, [r5, #0]
 8003c46:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8003c4a:	602b      	str	r3, [r5, #0]
  WRITE_REG(hspi->Instance->CR1, ((hspi->Init.Mode & (SPI_CR1_MSTR | SPI_CR1_SSI)) |
 8003c4c:	6863      	ldr	r3, [r4, #4]
 8003c4e:	f402 4204 	and.w	r2, r2, #33792	; 0x8400
 8003c52:	f403 7382 	and.w	r3, r3, #260	; 0x104
 8003c56:	4313      	orrs	r3, r2
 8003c58:	68e2      	ldr	r2, [r4, #12]
 8003c5a:	f402 6200 	and.w	r2, r2, #2048	; 0x800
 8003c5e:	4313      	orrs	r3, r2
 8003c60:	6922      	ldr	r2, [r4, #16]
 8003c62:	f002 0202 	and.w	r2, r2, #2
 8003c66:	4313      	orrs	r3, r2
 8003c68:	6962      	ldr	r2, [r4, #20]
 8003c6a:	f002 0201 	and.w	r2, r2, #1
 8003c6e:	431a      	orrs	r2, r3
 8003c70:	69e3      	ldr	r3, [r4, #28]
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | (hspi->Init.TIMode & SPI_CR2_FRF)));
 8003c72:	f001 0010 	and.w	r0, r1, #16
  WRITE_REG(hspi->Instance->CR1, ((hspi->Init.Mode & (SPI_CR1_MSTR | SPI_CR1_SSI)) |
 8003c76:	f003 0638 	and.w	r6, r3, #56	; 0x38
 8003c7a:	69a1      	ldr	r1, [r4, #24]
 8003c7c:	6a23      	ldr	r3, [r4, #32]
 8003c7e:	f003 0e80 	and.w	lr, r3, #128	; 0x80
 8003c82:	f401 7300 	and.w	r3, r1, #512	; 0x200
 8003c86:	4313      	orrs	r3, r2
 8003c88:	4333      	orrs	r3, r6
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | (hspi->Init.TIMode & SPI_CR2_FRF)));
 8003c8a:	0c09      	lsrs	r1, r1, #16
  WRITE_REG(hspi->Instance->CR1, ((hspi->Init.Mode & (SPI_CR1_MSTR | SPI_CR1_SSI)) |
 8003c8c:	ea43 030e 	orr.w	r3, r3, lr
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | (hspi->Init.TIMode & SPI_CR2_FRF)));
 8003c90:	f001 0104 	and.w	r1, r1, #4
  WRITE_REG(hspi->Instance->CR1, ((hspi->Init.Mode & (SPI_CR1_MSTR | SPI_CR1_SSI)) |
 8003c94:	ea43 030c 	orr.w	r3, r3, ip
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | (hspi->Init.TIMode & SPI_CR2_FRF)));
 8003c98:	4301      	orrs	r1, r0
  WRITE_REG(hspi->Instance->CR1, ((hspi->Init.Mode & (SPI_CR1_MSTR | SPI_CR1_SSI)) |
 8003c9a:	602b      	str	r3, [r5, #0]
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | (hspi->Init.TIMode & SPI_CR2_FRF)));
 8003c9c:	6069      	str	r1, [r5, #4]
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
 8003c9e:	69eb      	ldr	r3, [r5, #28]
  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 8003ca0:	2000      	movs	r0, #0
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
 8003ca2:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
  hspi->State     = HAL_SPI_STATE_READY;
 8003ca6:	2201      	movs	r2, #1
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
 8003ca8:	61eb      	str	r3, [r5, #28]
  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 8003caa:	6560      	str	r0, [r4, #84]	; 0x54
  hspi->State     = HAL_SPI_STATE_READY;
 8003cac:	f884 2051 	strb.w	r2, [r4, #81]	; 0x51
}
 8003cb0:	bd70      	pop	{r4, r5, r6, pc}
    if (hspi->Init.Mode == SPI_MODE_MASTER)
 8003cb2:	6843      	ldr	r3, [r0, #4]
 8003cb4:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 8003cb8:	d0b6      	beq.n	8003c28 <HAL_SPI_Init+0x14>
      hspi->Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;
 8003cba:	61c1      	str	r1, [r0, #28]
 8003cbc:	e7b4      	b.n	8003c28 <HAL_SPI_Init+0x14>
    hspi->Lock = HAL_UNLOCKED;
 8003cbe:	f884 0050 	strb.w	r0, [r4, #80]	; 0x50
    HAL_SPI_MspInit(hspi);
 8003cc2:	4620      	mov	r0, r4
 8003cc4:	f7ff ffa4 	bl	8003c10 <HAL_SPI_MspInit>
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | (hspi->Init.TIMode & SPI_CR2_FRF)));
 8003cc8:	e9d4 1309 	ldrd	r1, r3, [r4, #36]	; 0x24
  WRITE_REG(hspi->Instance->CR1, ((hspi->Init.Mode & (SPI_CR1_MSTR | SPI_CR1_SSI)) |
 8003ccc:	f403 5c00 	and.w	ip, r3, #8192	; 0x2000
 8003cd0:	e7b3      	b.n	8003c3a <HAL_SPI_Init+0x26>
    return HAL_ERROR;
 8003cd2:	2001      	movs	r0, #1
}
 8003cd4:	4770      	bx	lr
 8003cd6:	bf00      	nop

08003cd8 <HAL_SPI_TransmitReceive_DMA>:
{
 8003cd8:	b538      	push	{r3, r4, r5, lr}
 8003cda:	4604      	mov	r4, r0
  __HAL_LOCK(hspi);
 8003cdc:	f890 0050 	ldrb.w	r0, [r0, #80]	; 0x50
 8003ce0:	2801      	cmp	r0, #1
 8003ce2:	d06a      	beq.n	8003dba <HAL_SPI_TransmitReceive_DMA+0xe2>
 8003ce4:	2001      	movs	r0, #1
 8003ce6:	f884 0050 	strb.w	r0, [r4, #80]	; 0x50
  tmp_state           = hspi->State;
 8003cea:	f894 0051 	ldrb.w	r0, [r4, #81]	; 0x51
  if (!((tmp_state == HAL_SPI_STATE_READY) ||
 8003cee:	2801      	cmp	r0, #1
  tmp_state           = hspi->State;
 8003cf0:	fa5f fc80 	uxtb.w	ip, r0
  if (!((tmp_state == HAL_SPI_STATE_READY) ||
 8003cf4:	d00e      	beq.n	8003d14 <HAL_SPI_TransmitReceive_DMA+0x3c>
 8003cf6:	6860      	ldr	r0, [r4, #4]
 8003cf8:	f5b0 7f82 	cmp.w	r0, #260	; 0x104
 8003cfc:	d004      	beq.n	8003d08 <HAL_SPI_TransmitReceive_DMA+0x30>
    errorcode = HAL_BUSY;
 8003cfe:	2002      	movs	r0, #2
  __HAL_UNLOCK(hspi);
 8003d00:	2300      	movs	r3, #0
 8003d02:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
}
 8003d06:	bd38      	pop	{r3, r4, r5, pc}
        ((tmp_mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (tmp_state == HAL_SPI_STATE_BUSY_RX))))
 8003d08:	68a0      	ldr	r0, [r4, #8]
 8003d0a:	2800      	cmp	r0, #0
 8003d0c:	d1f7      	bne.n	8003cfe <HAL_SPI_TransmitReceive_DMA+0x26>
 8003d0e:	f1bc 0f04 	cmp.w	ip, #4
 8003d12:	d1f4      	bne.n	8003cfe <HAL_SPI_TransmitReceive_DMA+0x26>
  if ((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
 8003d14:	2900      	cmp	r1, #0
 8003d16:	d04e      	beq.n	8003db6 <HAL_SPI_TransmitReceive_DMA+0xde>
 8003d18:	2a00      	cmp	r2, #0
 8003d1a:	d04c      	beq.n	8003db6 <HAL_SPI_TransmitReceive_DMA+0xde>
 8003d1c:	2b00      	cmp	r3, #0
 8003d1e:	d04a      	beq.n	8003db6 <HAL_SPI_TransmitReceive_DMA+0xde>
  if (hspi->State != HAL_SPI_STATE_BUSY_RX)
 8003d20:	f894 0051 	ldrb.w	r0, [r4, #81]	; 0x51
  hspi->pTxBuffPtr  = (uint8_t *)pTxData;
 8003d24:	6321      	str	r1, [r4, #48]	; 0x30
  if (hspi->State != HAL_SPI_STATE_BUSY_RX)
 8003d26:	2804      	cmp	r0, #4
    hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
 8003d28:	bf1c      	itt	ne
 8003d2a:	2005      	movne	r0, #5
 8003d2c:	f884 0051 	strbne.w	r0, [r4, #81]	; 0x51
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8003d30:	2000      	movs	r0, #0
 8003d32:	6560      	str	r0, [r4, #84]	; 0x54
  hspi->TxXferCount = Size;
 8003d34:	86e3      	strh	r3, [r4, #54]	; 0x36
  hspi->RxXferCount = Size;
 8003d36:	87e3      	strh	r3, [r4, #62]	; 0x3e
  if (hspi->State == HAL_SPI_STATE_BUSY_RX)
 8003d38:	f894 1051 	ldrb.w	r1, [r4, #81]	; 0x51
  hspi->TxXferSize  = Size;
 8003d3c:	86a3      	strh	r3, [r4, #52]	; 0x34
  if (hspi->State == HAL_SPI_STATE_BUSY_RX)
 8003d3e:	2904      	cmp	r1, #4
  hspi->RxXferSize  = Size;
 8003d40:	87a3      	strh	r3, [r4, #60]	; 0x3c
  hspi->TxISR       = NULL;
 8003d42:	e9c4 0010 	strd	r0, r0, [r4, #64]	; 0x40
    hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfReceiveCplt;
 8003d46:	bf08      	it	eq
 8003d48:	4921      	ldreq	r1, [pc, #132]	; (8003dd0 <HAL_SPI_TransmitReceive_DMA+0xf8>)
 8003d4a:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
    hspi->hdmarx->XferCpltCallback     = SPI_DMAReceiveCplt;
 8003d4c:	bf0e      	itee	eq
 8003d4e:	4b21      	ldreq	r3, [pc, #132]	; (8003dd4 <HAL_SPI_TransmitReceive_DMA+0xfc>)
    hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfTransmitReceiveCplt;
 8003d50:	4921      	ldrne	r1, [pc, #132]	; (8003dd8 <HAL_SPI_TransmitReceive_DMA+0x100>)
    hspi->hdmarx->XferCpltCallback     = SPI_DMATransmitReceiveCplt;
 8003d52:	4b22      	ldrne	r3, [pc, #136]	; (8003ddc <HAL_SPI_TransmitReceive_DMA+0x104>)
  hspi->pRxBuffPtr  = (uint8_t *)pRxData;
 8003d54:	63a2      	str	r2, [r4, #56]	; 0x38
  hspi->hdmarx->XferErrorCallback = SPI_DMAError;
 8003d56:	4d22      	ldr	r5, [pc, #136]	; (8003de0 <HAL_SPI_TransmitReceive_DMA+0x108>)
    hspi->hdmarx->XferCpltCallback     = SPI_DMATransmitReceiveCplt;
 8003d58:	e9c0 310f 	strd	r3, r1, [r0, #60]	; 0x3c
                                 hspi->RxXferCount))
 8003d5c:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
  if (HAL_OK != HAL_DMA_Start_IT(hspi->hdmarx, (uint32_t)&hspi->Instance->DR, (uint32_t)hspi->pRxBuffPtr,
 8003d5e:	6821      	ldr	r1, [r4, #0]
  hspi->hdmarx->XferErrorCallback = SPI_DMAError;
 8003d60:	64c5      	str	r5, [r0, #76]	; 0x4c
  hspi->hdmarx->XferAbortCallback = NULL;
 8003d62:	2500      	movs	r5, #0
  if (HAL_OK != HAL_DMA_Start_IT(hspi->hdmarx, (uint32_t)&hspi->Instance->DR, (uint32_t)hspi->pRxBuffPtr,
 8003d64:	b29b      	uxth	r3, r3
 8003d66:	310c      	adds	r1, #12
  hspi->hdmarx->XferAbortCallback = NULL;
 8003d68:	6505      	str	r5, [r0, #80]	; 0x50
  if (HAL_OK != HAL_DMA_Start_IT(hspi->hdmarx, (uint32_t)&hspi->Instance->DR, (uint32_t)hspi->pRxBuffPtr,
 8003d6a:	f7fe fdf7 	bl	800295c <HAL_DMA_Start_IT>
 8003d6e:	bb30      	cbnz	r0, 8003dbe <HAL_SPI_TransmitReceive_DMA+0xe6>
  SET_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
 8003d70:	6822      	ldr	r2, [r4, #0]
  hspi->hdmatx->XferHalfCpltCallback = NULL;
 8003d72:	6ca1      	ldr	r1, [r4, #72]	; 0x48
  SET_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
 8003d74:	6853      	ldr	r3, [r2, #4]
 8003d76:	f043 0301 	orr.w	r3, r3, #1
 8003d7a:	6053      	str	r3, [r2, #4]
                                 hspi->TxXferCount))
 8003d7c:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
  if (HAL_OK != HAL_DMA_Start_IT(hspi->hdmatx, (uint32_t)hspi->pTxBuffPtr, (uint32_t)&hspi->Instance->DR,
 8003d7e:	320c      	adds	r2, #12
  hspi->hdmatx->XferCpltCallback     = NULL;
 8003d80:	e9c1 000f 	strd	r0, r0, [r1, #60]	; 0x3c
  hspi->hdmatx->XferAbortCallback    = NULL;
 8003d84:	e9c1 0013 	strd	r0, r0, [r1, #76]	; 0x4c
  if (HAL_OK != HAL_DMA_Start_IT(hspi->hdmatx, (uint32_t)hspi->pTxBuffPtr, (uint32_t)&hspi->Instance->DR,
 8003d88:	b29b      	uxth	r3, r3
 8003d8a:	4608      	mov	r0, r1
 8003d8c:	6b21      	ldr	r1, [r4, #48]	; 0x30
 8003d8e:	f7fe fde5 	bl	800295c <HAL_DMA_Start_IT>
 8003d92:	b9a0      	cbnz	r0, 8003dbe <HAL_SPI_TransmitReceive_DMA+0xe6>
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 8003d94:	6823      	ldr	r3, [r4, #0]
 8003d96:	681a      	ldr	r2, [r3, #0]
 8003d98:	0652      	lsls	r2, r2, #25
 8003d9a:	d403      	bmi.n	8003da4 <HAL_SPI_TransmitReceive_DMA+0xcc>
    __HAL_SPI_ENABLE(hspi);
 8003d9c:	681a      	ldr	r2, [r3, #0]
 8003d9e:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8003da2:	601a      	str	r2, [r3, #0]
  __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_ERR));
 8003da4:	685a      	ldr	r2, [r3, #4]
 8003da6:	f042 0220 	orr.w	r2, r2, #32
 8003daa:	605a      	str	r2, [r3, #4]
  SET_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
 8003dac:	685a      	ldr	r2, [r3, #4]
 8003dae:	f042 0202 	orr.w	r2, r2, #2
 8003db2:	605a      	str	r2, [r3, #4]
 8003db4:	e7a4      	b.n	8003d00 <HAL_SPI_TransmitReceive_DMA+0x28>
    errorcode = HAL_ERROR;
 8003db6:	2001      	movs	r0, #1
 8003db8:	e7a2      	b.n	8003d00 <HAL_SPI_TransmitReceive_DMA+0x28>
  __HAL_LOCK(hspi);
 8003dba:	2002      	movs	r0, #2
}
 8003dbc:	bd38      	pop	{r3, r4, r5, pc}
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
 8003dbe:	6d63      	ldr	r3, [r4, #84]	; 0x54
    hspi->State = HAL_SPI_STATE_READY;
 8003dc0:	2201      	movs	r2, #1
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
 8003dc2:	f043 0310 	orr.w	r3, r3, #16
 8003dc6:	6563      	str	r3, [r4, #84]	; 0x54
    errorcode = HAL_ERROR;
 8003dc8:	4610      	mov	r0, r2
    hspi->State = HAL_SPI_STATE_READY;
 8003dca:	f884 2051 	strb.w	r2, [r4, #81]	; 0x51
    goto error;
 8003dce:	e797      	b.n	8003d00 <HAL_SPI_TransmitReceive_DMA+0x28>
 8003dd0:	08003ee1 	.word	0x08003ee1
 8003dd4:	08003f25 	.word	0x08003f25
 8003dd8:	08003ef1 	.word	0x08003ef1
 8003ddc:	08004085 	.word	0x08004085
 8003de0:	08003f01 	.word	0x08003f01

08003de4 <HAL_SPI_Receive_DMA>:
{
 8003de4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if ((hspi->Init.Direction == SPI_DIRECTION_2LINES) && (hspi->Init.Mode == SPI_MODE_MASTER))
 8003de8:	6885      	ldr	r5, [r0, #8]
{
 8003dea:	4604      	mov	r4, r0
 8003dec:	460e      	mov	r6, r1
  if ((hspi->Init.Direction == SPI_DIRECTION_2LINES) && (hspi->Init.Mode == SPI_MODE_MASTER))
 8003dee:	b91d      	cbnz	r5, 8003df8 <HAL_SPI_Receive_DMA+0x14>
 8003df0:	6843      	ldr	r3, [r0, #4]
 8003df2:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 8003df6:	d059      	beq.n	8003eac <HAL_SPI_Receive_DMA+0xc8>
  __HAL_LOCK(hspi);
 8003df8:	f894 3050 	ldrb.w	r3, [r4, #80]	; 0x50
 8003dfc:	2b01      	cmp	r3, #1
 8003dfe:	d05e      	beq.n	8003ebe <HAL_SPI_Receive_DMA+0xda>
 8003e00:	2301      	movs	r3, #1
 8003e02:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
  if (hspi->State != HAL_SPI_STATE_READY)
 8003e06:	f894 3051 	ldrb.w	r3, [r4, #81]	; 0x51
 8003e0a:	2b01      	cmp	r3, #1
 8003e0c:	b2df      	uxtb	r7, r3
 8003e0e:	d006      	beq.n	8003e1e <HAL_SPI_Receive_DMA+0x3a>
    errorcode = HAL_BUSY;
 8003e10:	2702      	movs	r7, #2
  __HAL_UNLOCK(hspi);
 8003e12:	2300      	movs	r3, #0
 8003e14:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
}
 8003e18:	4638      	mov	r0, r7
 8003e1a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if ((pData == NULL) || (Size == 0U))
 8003e1e:	2e00      	cmp	r6, #0
 8003e20:	d0f7      	beq.n	8003e12 <HAL_SPI_Receive_DMA+0x2e>
 8003e22:	2a00      	cmp	r2, #0
 8003e24:	d0f5      	beq.n	8003e12 <HAL_SPI_Receive_DMA+0x2e>
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8003e26:	2300      	movs	r3, #0
  hspi->State       = HAL_SPI_STATE_BUSY_RX;
 8003e28:	2104      	movs	r1, #4
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8003e2a:	f5b5 4f00 	cmp.w	r5, #32768	; 0x8000
  hspi->State       = HAL_SPI_STATE_BUSY_RX;
 8003e2e:	f884 1051 	strb.w	r1, [r4, #81]	; 0x51
  hspi->TxISR       = NULL;
 8003e32:	e9c4 3310 	strd	r3, r3, [r4, #64]	; 0x40
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8003e36:	6563      	str	r3, [r4, #84]	; 0x54
    __HAL_SPI_DISABLE(hspi);
 8003e38:	6821      	ldr	r1, [r4, #0]
  hspi->RxXferCount = Size;
 8003e3a:	87e2      	strh	r2, [r4, #62]	; 0x3e
  hspi->pRxBuffPtr  = (uint8_t *)pData;
 8003e3c:	63a6      	str	r6, [r4, #56]	; 0x38
  hspi->RxXferSize  = Size;
 8003e3e:	87a2      	strh	r2, [r4, #60]	; 0x3c
  hspi->TxXferSize  = 0U;
 8003e40:	86a3      	strh	r3, [r4, #52]	; 0x34
  hspi->TxXferCount = 0U;
 8003e42:	86e3      	strh	r3, [r4, #54]	; 0x36
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8003e44:	d029      	beq.n	8003e9a <HAL_SPI_Receive_DMA+0xb6>
  hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfReceiveCplt;
 8003e46:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
 8003e48:	4d1f      	ldr	r5, [pc, #124]	; (8003ec8 <HAL_SPI_Receive_DMA+0xe4>)
                                 hspi->RxXferCount))
 8003e4a:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
  hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfReceiveCplt;
 8003e4c:	6405      	str	r5, [r0, #64]	; 0x40
  hspi->hdmarx->XferCpltCallback = SPI_DMAReceiveCplt;
 8003e4e:	4d1f      	ldr	r5, [pc, #124]	; (8003ecc <HAL_SPI_Receive_DMA+0xe8>)
 8003e50:	63c5      	str	r5, [r0, #60]	; 0x3c
  hspi->hdmarx->XferErrorCallback = SPI_DMAError;
 8003e52:	4d1f      	ldr	r5, [pc, #124]	; (8003ed0 <HAL_SPI_Receive_DMA+0xec>)
 8003e54:	64c5      	str	r5, [r0, #76]	; 0x4c
  hspi->hdmarx->XferAbortCallback = NULL;
 8003e56:	2500      	movs	r5, #0
  if (HAL_OK != HAL_DMA_Start_IT(hspi->hdmarx, (uint32_t)&hspi->Instance->DR, (uint32_t)hspi->pRxBuffPtr,
 8003e58:	4632      	mov	r2, r6
 8003e5a:	310c      	adds	r1, #12
 8003e5c:	b29b      	uxth	r3, r3
  hspi->hdmarx->XferAbortCallback = NULL;
 8003e5e:	6505      	str	r5, [r0, #80]	; 0x50
  if (HAL_OK != HAL_DMA_Start_IT(hspi->hdmarx, (uint32_t)&hspi->Instance->DR, (uint32_t)hspi->pRxBuffPtr,
 8003e60:	f7fe fd7c 	bl	800295c <HAL_DMA_Start_IT>
 8003e64:	b988      	cbnz	r0, 8003e8a <HAL_SPI_Receive_DMA+0xa6>
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 8003e66:	6823      	ldr	r3, [r4, #0]
 8003e68:	681a      	ldr	r2, [r3, #0]
 8003e6a:	0652      	lsls	r2, r2, #25
 8003e6c:	d403      	bmi.n	8003e76 <HAL_SPI_Receive_DMA+0x92>
    __HAL_SPI_ENABLE(hspi);
 8003e6e:	681a      	ldr	r2, [r3, #0]
 8003e70:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8003e74:	601a      	str	r2, [r3, #0]
  __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_ERR));
 8003e76:	685a      	ldr	r2, [r3, #4]
 8003e78:	f042 0220 	orr.w	r2, r2, #32
 8003e7c:	605a      	str	r2, [r3, #4]
  SET_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
 8003e7e:	685a      	ldr	r2, [r3, #4]
 8003e80:	f042 0201 	orr.w	r2, r2, #1
  HAL_StatusTypeDef errorcode = HAL_OK;
 8003e84:	2700      	movs	r7, #0
  SET_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
 8003e86:	605a      	str	r2, [r3, #4]
 8003e88:	e7c3      	b.n	8003e12 <HAL_SPI_Receive_DMA+0x2e>
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
 8003e8a:	6d63      	ldr	r3, [r4, #84]	; 0x54
    hspi->State = HAL_SPI_STATE_READY;
 8003e8c:	2201      	movs	r2, #1
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
 8003e8e:	f043 0310 	orr.w	r3, r3, #16
 8003e92:	6563      	str	r3, [r4, #84]	; 0x54
    hspi->State = HAL_SPI_STATE_READY;
 8003e94:	f884 2051 	strb.w	r2, [r4, #81]	; 0x51
    goto error;
 8003e98:	e7bb      	b.n	8003e12 <HAL_SPI_Receive_DMA+0x2e>
    __HAL_SPI_DISABLE(hspi);
 8003e9a:	680b      	ldr	r3, [r1, #0]
 8003e9c:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8003ea0:	600b      	str	r3, [r1, #0]
    SPI_1LINE_RX(hspi);
 8003ea2:	680b      	ldr	r3, [r1, #0]
 8003ea4:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8003ea8:	600b      	str	r3, [r1, #0]
 8003eaa:	e7cc      	b.n	8003e46 <HAL_SPI_Receive_DMA+0x62>
    hspi->State = HAL_SPI_STATE_BUSY_RX;
 8003eac:	2504      	movs	r5, #4
 8003eae:	f880 5051 	strb.w	r5, [r0, #81]	; 0x51
    return HAL_SPI_TransmitReceive_DMA(hspi, pData, pData, Size);
 8003eb2:	4613      	mov	r3, r2
}
 8003eb4:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    return HAL_SPI_TransmitReceive_DMA(hspi, pData, pData, Size);
 8003eb8:	460a      	mov	r2, r1
 8003eba:	f7ff bf0d 	b.w	8003cd8 <HAL_SPI_TransmitReceive_DMA>
  __HAL_LOCK(hspi);
 8003ebe:	2702      	movs	r7, #2
}
 8003ec0:	4638      	mov	r0, r7
 8003ec2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8003ec6:	bf00      	nop
 8003ec8:	08003ee1 	.word	0x08003ee1
 8003ecc:	08003f25 	.word	0x08003f25
 8003ed0:	08003f01 	.word	0x08003f01

08003ed4 <HAL_SPI_RxCpltCallback>:
 8003ed4:	4770      	bx	lr
 8003ed6:	bf00      	nop

08003ed8 <HAL_SPI_TxRxCpltCallback>:
 8003ed8:	4770      	bx	lr
 8003eda:	bf00      	nop

08003edc <HAL_SPI_RxHalfCpltCallback>:
 8003edc:	4770      	bx	lr
 8003ede:	bf00      	nop

08003ee0 <SPI_DMAHalfReceiveCplt>:
{
 8003ee0:	b508      	push	{r3, lr}
  HAL_SPI_RxHalfCpltCallback(hspi);
 8003ee2:	6b80      	ldr	r0, [r0, #56]	; 0x38
 8003ee4:	f7ff fffa 	bl	8003edc <HAL_SPI_RxHalfCpltCallback>
}
 8003ee8:	bd08      	pop	{r3, pc}
 8003eea:	bf00      	nop

08003eec <HAL_SPI_TxRxHalfCpltCallback>:
 8003eec:	4770      	bx	lr
 8003eee:	bf00      	nop

08003ef0 <SPI_DMAHalfTransmitReceiveCplt>:
{
 8003ef0:	b508      	push	{r3, lr}
  HAL_SPI_TxRxHalfCpltCallback(hspi);
 8003ef2:	6b80      	ldr	r0, [r0, #56]	; 0x38
 8003ef4:	f7ff fffa 	bl	8003eec <HAL_SPI_TxRxHalfCpltCallback>
}
 8003ef8:	bd08      	pop	{r3, pc}
 8003efa:	bf00      	nop

08003efc <HAL_SPI_ErrorCallback>:
 8003efc:	4770      	bx	lr
 8003efe:	bf00      	nop

08003f00 <SPI_DMAError>:
  SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
 8003f00:	6b80      	ldr	r0, [r0, #56]	; 0x38
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 8003f02:	6802      	ldr	r2, [r0, #0]
{
 8003f04:	b508      	push	{r3, lr}
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 8003f06:	6853      	ldr	r3, [r2, #4]
 8003f08:	f023 0303 	bic.w	r3, r3, #3
 8003f0c:	6053      	str	r3, [r2, #4]
  SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
 8003f0e:	6d43      	ldr	r3, [r0, #84]	; 0x54
  hspi->State = HAL_SPI_STATE_READY;
 8003f10:	2101      	movs	r1, #1
  SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
 8003f12:	f043 0310 	orr.w	r3, r3, #16
 8003f16:	6543      	str	r3, [r0, #84]	; 0x54
  hspi->State = HAL_SPI_STATE_READY;
 8003f18:	f880 1051 	strb.w	r1, [r0, #81]	; 0x51
  HAL_SPI_ErrorCallback(hspi);
 8003f1c:	f7ff ffee 	bl	8003efc <HAL_SPI_ErrorCallback>
}
 8003f20:	bd08      	pop	{r3, pc}
 8003f22:	bf00      	nop

08003f24 <SPI_DMAReceiveCplt>:
{
 8003f24:	b570      	push	{r4, r5, r6, lr}
 8003f26:	4606      	mov	r6, r0
 8003f28:	b082      	sub	sp, #8
  SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
 8003f2a:	6b85      	ldr	r5, [r0, #56]	; 0x38
  tickstart = HAL_GetTick();
 8003f2c:	f7fe fbac 	bl	8002688 <HAL_GetTick>
  if ((hdma->Instance->CR & DMA_SxCR_CIRC) != DMA_SxCR_CIRC)
 8003f30:	6832      	ldr	r2, [r6, #0]
 8003f32:	6812      	ldr	r2, [r2, #0]
 8003f34:	05d1      	lsls	r1, r2, #23
 8003f36:	d45b      	bmi.n	8003ff0 <SPI_DMAReceiveCplt+0xcc>
    __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
 8003f38:	682a      	ldr	r2, [r5, #0]
    if ((hspi->Init.Direction == SPI_DIRECTION_2LINES) && (hspi->Init.Mode == SPI_MODE_MASTER))
 8003f3a:	68ab      	ldr	r3, [r5, #8]
    __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
 8003f3c:	6851      	ldr	r1, [r2, #4]
 8003f3e:	f021 0120 	bic.w	r1, r1, #32
 8003f42:	4604      	mov	r4, r0
 8003f44:	6051      	str	r1, [r2, #4]
    if ((hspi->Init.Direction == SPI_DIRECTION_2LINES) && (hspi->Init.Mode == SPI_MODE_MASTER))
 8003f46:	2b00      	cmp	r3, #0
 8003f48:	d057      	beq.n	8003ffa <SPI_DMAReceiveCplt+0xd6>
 8003f4a:	6868      	ldr	r0, [r5, #4]
      CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
 8003f4c:	6851      	ldr	r1, [r2, #4]
  * @param  Tickstart tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_EndRxTransaction(SPI_HandleTypeDef *hspi,  uint32_t Timeout, uint32_t Tickstart)
{
  if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8003f4e:	f5b0 7f82 	cmp.w	r0, #260	; 0x104
      CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
 8003f52:	f021 0101 	bic.w	r1, r1, #1
 8003f56:	6051      	str	r1, [r2, #4]
  if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8003f58:	d05d      	beq.n	8004016 <SPI_DMAReceiveCplt+0xf2>
  tmp_timeout   = Timeout - (HAL_GetTick() - Tickstart);
 8003f5a:	f7fe fb95 	bl	8002688 <HAL_GetTick>
 8003f5e:	3464      	adds	r4, #100	; 0x64
 8003f60:	1a24      	subs	r4, r4, r0
  tmp_tickstart = HAL_GetTick();
 8003f62:	f7fe fb91 	bl	8002688 <HAL_GetTick>
  count = tmp_timeout * ((SystemCoreClock * 32U) >> 20U);
 8003f66:	4b46      	ldr	r3, [pc, #280]	; (8004080 <SPI_DMAReceiveCplt+0x15c>)
  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 8003f68:	682a      	ldr	r2, [r5, #0]
  count = tmp_timeout * ((SystemCoreClock * 32U) >> 20U);
 8003f6a:	681b      	ldr	r3, [r3, #0]
 8003f6c:	f3c3 33cb 	ubfx	r3, r3, #15, #12
 8003f70:	fb04 f303 	mul.w	r3, r4, r3
 8003f74:	9301      	str	r3, [sp, #4]
  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 8003f76:	6893      	ldr	r3, [r2, #8]
 8003f78:	07db      	lsls	r3, r3, #31
  tmp_tickstart = HAL_GetTick();
 8003f7a:	4606      	mov	r6, r0
  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 8003f7c:	d40b      	bmi.n	8003f96 <SPI_DMAReceiveCplt+0x72>
 8003f7e:	e030      	b.n	8003fe2 <SPI_DMAReceiveCplt+0xbe>
      if (count == 0U)
 8003f80:	9a01      	ldr	r2, [sp, #4]
      count--;
 8003f82:	9b01      	ldr	r3, [sp, #4]
  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 8003f84:	6829      	ldr	r1, [r5, #0]
      count--;
 8003f86:	3b01      	subs	r3, #1
 8003f88:	9301      	str	r3, [sp, #4]
  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 8003f8a:	688b      	ldr	r3, [r1, #8]
        tmp_timeout = 0U;
 8003f8c:	2a00      	cmp	r2, #0
 8003f8e:	bf08      	it	eq
 8003f90:	2400      	moveq	r4, #0
  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 8003f92:	07da      	lsls	r2, r3, #31
 8003f94:	d525      	bpl.n	8003fe2 <SPI_DMAReceiveCplt+0xbe>
      if (((HAL_GetTick() - tmp_tickstart) >= tmp_timeout) || (tmp_timeout == 0U))
 8003f96:	f7fe fb77 	bl	8002688 <HAL_GetTick>
 8003f9a:	1b80      	subs	r0, r0, r6
 8003f9c:	4284      	cmp	r4, r0
 8003f9e:	d8ef      	bhi.n	8003f80 <SPI_DMAReceiveCplt+0x5c>
        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8003fa0:	e9d5 3100 	ldrd	r3, r1, [r5]
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 8003fa4:	685a      	ldr	r2, [r3, #4]
        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8003fa6:	f5b1 7f82 	cmp.w	r1, #260	; 0x104
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 8003faa:	f022 02e0 	bic.w	r2, r2, #224	; 0xe0
 8003fae:	605a      	str	r2, [r3, #4]
        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8003fb0:	d049      	beq.n	8004046 <SPI_DMAReceiveCplt+0x122>
        if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8003fb2:	6aaa      	ldr	r2, [r5, #40]	; 0x28
 8003fb4:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
 8003fb8:	d107      	bne.n	8003fca <SPI_DMAReceiveCplt+0xa6>
          SPI_RESET_CRC(hspi);
 8003fba:	681a      	ldr	r2, [r3, #0]
 8003fbc:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 8003fc0:	601a      	str	r2, [r3, #0]
 8003fc2:	681a      	ldr	r2, [r3, #0]
 8003fc4:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 8003fc8:	601a      	str	r2, [r3, #0]
        hspi->State = HAL_SPI_STATE_READY;
 8003fca:	2301      	movs	r3, #1
 8003fcc:	f885 3051 	strb.w	r3, [r5, #81]	; 0x51
  else
  {
    /* Wait the RXNE reset */
    if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout, Tickstart) != HAL_OK)
    {
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 8003fd0:	6d6b      	ldr	r3, [r5, #84]	; 0x54
        __HAL_UNLOCK(hspi);
 8003fd2:	2200      	movs	r2, #0
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 8003fd4:	f043 0320 	orr.w	r3, r3, #32
        __HAL_UNLOCK(hspi);
 8003fd8:	f885 2050 	strb.w	r2, [r5, #80]	; 0x50
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 8003fdc:	656b      	str	r3, [r5, #84]	; 0x54
      hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
 8003fde:	2320      	movs	r3, #32
 8003fe0:	656b      	str	r3, [r5, #84]	; 0x54
    hspi->State = HAL_SPI_STATE_READY;
 8003fe2:	2301      	movs	r3, #1
    hspi->RxXferCount = 0U;
 8003fe4:	2200      	movs	r2, #0
 8003fe6:	87ea      	strh	r2, [r5, #62]	; 0x3e
    hspi->State = HAL_SPI_STATE_READY;
 8003fe8:	f885 3051 	strb.w	r3, [r5, #81]	; 0x51
    if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 8003fec:	6d6b      	ldr	r3, [r5, #84]	; 0x54
 8003fee:	b96b      	cbnz	r3, 800400c <SPI_DMAReceiveCplt+0xe8>
  HAL_SPI_RxCpltCallback(hspi);
 8003ff0:	4628      	mov	r0, r5
 8003ff2:	f7ff ff6f 	bl	8003ed4 <HAL_SPI_RxCpltCallback>
}
 8003ff6:	b002      	add	sp, #8
 8003ff8:	bd70      	pop	{r4, r5, r6, pc}
    if ((hspi->Init.Direction == SPI_DIRECTION_2LINES) && (hspi->Init.Mode == SPI_MODE_MASTER))
 8003ffa:	686b      	ldr	r3, [r5, #4]
 8003ffc:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
      CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 8004000:	6853      	ldr	r3, [r2, #4]
    if ((hspi->Init.Direction == SPI_DIRECTION_2LINES) && (hspi->Init.Mode == SPI_MODE_MASTER))
 8004002:	d01c      	beq.n	800403e <SPI_DMAReceiveCplt+0x11a>
      CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
 8004004:	f023 0301 	bic.w	r3, r3, #1
 8004008:	6053      	str	r3, [r2, #4]
  if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 800400a:	e7a6      	b.n	8003f5a <SPI_DMAReceiveCplt+0x36>
      HAL_SPI_ErrorCallback(hspi);
 800400c:	4628      	mov	r0, r5
 800400e:	f7ff ff75 	bl	8003efc <HAL_SPI_ErrorCallback>
}
 8004012:	b002      	add	sp, #8
 8004014:	bd70      	pop	{r4, r5, r6, pc}
  if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8004016:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 800401a:	d120      	bne.n	800405e <SPI_DMAReceiveCplt+0x13a>
    __HAL_SPI_DISABLE(hspi);
 800401c:	6813      	ldr	r3, [r2, #0]
 800401e:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8004022:	6013      	str	r3, [r2, #0]
      if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
 8004024:	4623      	mov	r3, r4
 8004026:	2264      	movs	r2, #100	; 0x64
 8004028:	2180      	movs	r1, #128	; 0x80
 800402a:	4628      	mov	r0, r5
 800402c:	f7ff fd90 	bl	8003b50 <SPI_WaitFlagStateUntilTimeout.constprop.0>
 8004030:	2800      	cmp	r0, #0
 8004032:	d0d6      	beq.n	8003fe2 <SPI_DMAReceiveCplt+0xbe>
        SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 8004034:	6d6b      	ldr	r3, [r5, #84]	; 0x54
 8004036:	f043 0320 	orr.w	r3, r3, #32
 800403a:	656b      	str	r3, [r5, #84]	; 0x54
        return HAL_TIMEOUT;
 800403c:	e7cf      	b.n	8003fde <SPI_DMAReceiveCplt+0xba>
      CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 800403e:	f023 0303 	bic.w	r3, r3, #3
 8004042:	6053      	str	r3, [r2, #4]
  if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8004044:	e7ee      	b.n	8004024 <SPI_DMAReceiveCplt+0x100>
        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8004046:	68aa      	ldr	r2, [r5, #8]
 8004048:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
 800404c:	d002      	beq.n	8004054 <SPI_DMAReceiveCplt+0x130>
                                                     || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 800404e:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
 8004052:	d1ae      	bne.n	8003fb2 <SPI_DMAReceiveCplt+0x8e>
          __HAL_SPI_DISABLE(hspi);
 8004054:	681a      	ldr	r2, [r3, #0]
 8004056:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 800405a:	601a      	str	r2, [r3, #0]
 800405c:	e7a9      	b.n	8003fb2 <SPI_DMAReceiveCplt+0x8e>
                                               || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 800405e:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8004062:	d1df      	bne.n	8004024 <SPI_DMAReceiveCplt+0x100>
    __HAL_SPI_DISABLE(hspi);
 8004064:	6811      	ldr	r1, [r2, #0]
 8004066:	f021 0140 	bic.w	r1, r1, #64	; 0x40
 800406a:	6011      	str	r1, [r2, #0]
      if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout, Tickstart) != HAL_OK)
 800406c:	4623      	mov	r3, r4
 800406e:	2264      	movs	r2, #100	; 0x64
 8004070:	2101      	movs	r1, #1
 8004072:	4628      	mov	r0, r5
 8004074:	f7ff fd6c 	bl	8003b50 <SPI_WaitFlagStateUntilTimeout.constprop.0>
 8004078:	2800      	cmp	r0, #0
 800407a:	d0b2      	beq.n	8003fe2 <SPI_DMAReceiveCplt+0xbe>
 800407c:	e7da      	b.n	8004034 <SPI_DMAReceiveCplt+0x110>
 800407e:	bf00      	nop
 8004080:	20000078 	.word	0x20000078

08004084 <SPI_DMATransmitReceiveCplt>:
{
 8004084:	b530      	push	{r4, r5, lr}
 8004086:	4605      	mov	r5, r0
 8004088:	b083      	sub	sp, #12
  SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
 800408a:	6b84      	ldr	r4, [r0, #56]	; 0x38
  tickstart = HAL_GetTick();
 800408c:	f7fe fafc 	bl	8002688 <HAL_GetTick>
  if ((hdma->Instance->CR & DMA_SxCR_CIRC) != DMA_SxCR_CIRC)
 8004090:	682a      	ldr	r2, [r5, #0]
 8004092:	6812      	ldr	r2, [r2, #0]
 8004094:	05d2      	lsls	r2, r2, #23
 8004096:	d427      	bmi.n	80040e8 <SPI_DMATransmitReceiveCplt+0x64>
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_EndRxTxTransaction(SPI_HandleTypeDef *hspi, uint32_t Timeout, uint32_t Tickstart)
{
  /* Timeout in s */
  __IO uint32_t count = SPI_BSY_FLAG_WORKAROUND_TIMEOUT * (SystemCoreClock / 24U / 1000000U);
 8004098:	4b22      	ldr	r3, [pc, #136]	; (8004124 <SPI_DMATransmitReceiveCplt+0xa0>)
    __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
 800409a:	6822      	ldr	r2, [r4, #0]
  __IO uint32_t count = SPI_BSY_FLAG_WORKAROUND_TIMEOUT * (SystemCoreClock / 24U / 1000000U);
 800409c:	6819      	ldr	r1, [r3, #0]
 800409e:	4b22      	ldr	r3, [pc, #136]	; (8004128 <SPI_DMATransmitReceiveCplt+0xa4>)
    __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
 80040a0:	6855      	ldr	r5, [r2, #4]
  __IO uint32_t count = SPI_BSY_FLAG_WORKAROUND_TIMEOUT * (SystemCoreClock / 24U / 1000000U);
 80040a2:	fba3 3101 	umull	r3, r1, r3, r1
 80040a6:	0d49      	lsrs	r1, r1, #21
 80040a8:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80040ac:	fb03 f101 	mul.w	r1, r3, r1
  /* Erratasheet: BSY bit may stay high at the end of a data transfer in Slave mode */
  if (hspi->Init.Mode == SPI_MODE_MASTER)
 80040b0:	6863      	ldr	r3, [r4, #4]
    __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
 80040b2:	f025 0520 	bic.w	r5, r5, #32
  if (hspi->Init.Mode == SPI_MODE_MASTER)
 80040b6:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
    __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
 80040ba:	6055      	str	r5, [r2, #4]
  __IO uint32_t count = SPI_BSY_FLAG_WORKAROUND_TIMEOUT * (SystemCoreClock / 24U / 1000000U);
 80040bc:	9101      	str	r1, [sp, #4]
  if (hspi->Init.Mode == SPI_MODE_MASTER)
 80040be:	d11e      	bne.n	80040fe <SPI_DMATransmitReceiveCplt+0x7a>
  {
    /* Control the BSY flag */
    if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
 80040c0:	4603      	mov	r3, r0
 80040c2:	2264      	movs	r2, #100	; 0x64
 80040c4:	2180      	movs	r1, #128	; 0x80
 80040c6:	4620      	mov	r0, r4
 80040c8:	f7ff fd42 	bl	8003b50 <SPI_WaitFlagStateUntilTimeout.constprop.0>
 80040cc:	bb00      	cbnz	r0, 8004110 <SPI_DMATransmitReceiveCplt+0x8c>
    CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 80040ce:	6822      	ldr	r2, [r4, #0]
 80040d0:	6853      	ldr	r3, [r2, #4]
    hspi->TxXferCount = 0U;
 80040d2:	2100      	movs	r1, #0
    CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 80040d4:	f023 0303 	bic.w	r3, r3, #3
    hspi->State = HAL_SPI_STATE_READY;
 80040d8:	2001      	movs	r0, #1
    CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 80040da:	6053      	str	r3, [r2, #4]
    hspi->TxXferCount = 0U;
 80040dc:	86e1      	strh	r1, [r4, #54]	; 0x36
    hspi->RxXferCount = 0U;
 80040de:	87e1      	strh	r1, [r4, #62]	; 0x3e
    hspi->State = HAL_SPI_STATE_READY;
 80040e0:	f884 0051 	strb.w	r0, [r4, #81]	; 0x51
    if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 80040e4:	6d63      	ldr	r3, [r4, #84]	; 0x54
 80040e6:	b973      	cbnz	r3, 8004106 <SPI_DMATransmitReceiveCplt+0x82>
  HAL_SPI_TxRxCpltCallback(hspi);
 80040e8:	4620      	mov	r0, r4
 80040ea:	f7ff fef5 	bl	8003ed8 <HAL_SPI_TxRxCpltCallback>
}
 80040ee:	b003      	add	sp, #12
 80040f0:	bd30      	pop	{r4, r5, pc}
    {
      if (count == 0U)
      {
        break;
      }
      count--;
 80040f2:	9b01      	ldr	r3, [sp, #4]
 80040f4:	3b01      	subs	r3, #1
 80040f6:	9301      	str	r3, [sp, #4]
    } while (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_BSY) != RESET);
 80040f8:	6893      	ldr	r3, [r2, #8]
 80040fa:	061b      	lsls	r3, r3, #24
 80040fc:	d5e8      	bpl.n	80040d0 <SPI_DMATransmitReceiveCplt+0x4c>
      if (count == 0U)
 80040fe:	9b01      	ldr	r3, [sp, #4]
 8004100:	2b00      	cmp	r3, #0
 8004102:	d1f6      	bne.n	80040f2 <SPI_DMATransmitReceiveCplt+0x6e>
 8004104:	e7e4      	b.n	80040d0 <SPI_DMATransmitReceiveCplt+0x4c>
      HAL_SPI_ErrorCallback(hspi);
 8004106:	4620      	mov	r0, r4
 8004108:	f7ff fef8 	bl	8003efc <HAL_SPI_ErrorCallback>
}
 800410c:	b003      	add	sp, #12
 800410e:	bd30      	pop	{r4, r5, pc}
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 8004110:	6d63      	ldr	r3, [r4, #84]	; 0x54
    CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 8004112:	6822      	ldr	r2, [r4, #0]
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 8004114:	f043 0320 	orr.w	r3, r3, #32
 8004118:	6563      	str	r3, [r4, #84]	; 0x54
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 800411a:	6d63      	ldr	r3, [r4, #84]	; 0x54
 800411c:	f043 0320 	orr.w	r3, r3, #32
 8004120:	6563      	str	r3, [r4, #84]	; 0x54
 8004122:	e7d5      	b.n	80040d0 <SPI_DMATransmitReceiveCplt+0x4c>
 8004124:	20000078 	.word	0x20000078
 8004128:	165e9f81 	.word	0x165e9f81

0800412c <HAL_TIM_OC_Start>:

  /* Check the parameters */
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));

  /* Check the TIM channel state */
  if (TIM_CHANNEL_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)
 800412c:	bb99      	cbnz	r1, 8004196 <HAL_TIM_OC_Start+0x6a>
 800412e:	f890 303e 	ldrb.w	r3, [r0, #62]	; 0x3e
 8004132:	2b01      	cmp	r3, #1
 8004134:	d137      	bne.n	80041a6 <HAL_TIM_OC_Start+0x7a>
  {
    return HAL_ERROR;
  }

  /* Set the TIM channel state */
  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
 8004136:	2302      	movs	r3, #2
 8004138:	f880 303e 	strb.w	r3, [r0, #62]	; 0x3e

  /* Enable the Output compare channel */
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
 800413c:	6803      	ldr	r3, [r0, #0]

  /* Check the parameters */
  assert_param(IS_TIM_CC1_INSTANCE(TIMx));
  assert_param(IS_TIM_CHANNELS(Channel));

  tmp = TIM_CCER_CC1E << (Channel & 0x1FU); /* 0x1FU = 31 bits max shift */
 800413e:	2201      	movs	r2, #1

  /* Reset the CCxE Bit */
  TIMx->CCER &= ~tmp;
 8004140:	6a18      	ldr	r0, [r3, #32]
  tmp = TIM_CCER_CC1E << (Channel & 0x1FU); /* 0x1FU = 31 bits max shift */
 8004142:	f001 011f 	and.w	r1, r1, #31
 8004146:	fa02 f101 	lsl.w	r1, r2, r1
  TIMx->CCER &= ~tmp;
 800414a:	ea20 0001 	bic.w	r0, r0, r1
 800414e:	6218      	str	r0, [r3, #32]

  /* Set or reset the CCxE Bit */
  TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
 8004150:	6a18      	ldr	r0, [r3, #32]
  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
 8004152:	4a27      	ldr	r2, [pc, #156]	; (80041f0 <HAL_TIM_OC_Start+0xc4>)
  TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
 8004154:	4301      	orrs	r1, r0
  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
 8004156:	4293      	cmp	r3, r2
  TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
 8004158:	6219      	str	r1, [r3, #32]
  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
 800415a:	d036      	beq.n	80041ca <HAL_TIM_OC_Start+0x9e>
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 800415c:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8004160:	d00e      	beq.n	8004180 <HAL_TIM_OC_Start+0x54>
 8004162:	4a24      	ldr	r2, [pc, #144]	; (80041f4 <HAL_TIM_OC_Start+0xc8>)
 8004164:	4293      	cmp	r3, r2
 8004166:	d00b      	beq.n	8004180 <HAL_TIM_OC_Start+0x54>
 8004168:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800416c:	4293      	cmp	r3, r2
 800416e:	d007      	beq.n	8004180 <HAL_TIM_OC_Start+0x54>
 8004170:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8004174:	4293      	cmp	r3, r2
 8004176:	d003      	beq.n	8004180 <HAL_TIM_OC_Start+0x54>
 8004178:	f502 329a 	add.w	r2, r2, #78848	; 0x13400
 800417c:	4293      	cmp	r3, r2
 800417e:	d104      	bne.n	800418a <HAL_TIM_OC_Start+0x5e>
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 8004180:	689a      	ldr	r2, [r3, #8]
 8004182:	f002 0207 	and.w	r2, r2, #7
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 8004186:	2a06      	cmp	r2, #6
 8004188:	d028      	beq.n	80041dc <HAL_TIM_OC_Start+0xb0>
    __HAL_TIM_ENABLE(htim);
 800418a:	681a      	ldr	r2, [r3, #0]
 800418c:	f042 0201 	orr.w	r2, r2, #1
  return HAL_OK;
 8004190:	2000      	movs	r0, #0
    __HAL_TIM_ENABLE(htim);
 8004192:	601a      	str	r2, [r3, #0]
 8004194:	4770      	bx	lr
  if (TIM_CHANNEL_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)
 8004196:	2904      	cmp	r1, #4
 8004198:	d022      	beq.n	80041e0 <HAL_TIM_OC_Start+0xb4>
 800419a:	2908      	cmp	r1, #8
 800419c:	d00d      	beq.n	80041ba <HAL_TIM_OC_Start+0x8e>
 800419e:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
 80041a2:	2b01      	cmp	r3, #1
 80041a4:	d001      	beq.n	80041aa <HAL_TIM_OC_Start+0x7e>
    return HAL_ERROR;
 80041a6:	2001      	movs	r0, #1
 80041a8:	4770      	bx	lr
  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
 80041aa:	2904      	cmp	r1, #4
 80041ac:	d01c      	beq.n	80041e8 <HAL_TIM_OC_Start+0xbc>
 80041ae:	2908      	cmp	r1, #8
 80041b0:	d007      	beq.n	80041c2 <HAL_TIM_OC_Start+0x96>
 80041b2:	2302      	movs	r3, #2
 80041b4:	f880 3041 	strb.w	r3, [r0, #65]	; 0x41
 80041b8:	e7c0      	b.n	800413c <HAL_TIM_OC_Start+0x10>
  if (TIM_CHANNEL_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)
 80041ba:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
 80041be:	2b01      	cmp	r3, #1
 80041c0:	d1f1      	bne.n	80041a6 <HAL_TIM_OC_Start+0x7a>
  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
 80041c2:	2302      	movs	r3, #2
 80041c4:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
 80041c8:	e7b8      	b.n	800413c <HAL_TIM_OC_Start+0x10>
    __HAL_TIM_MOE_ENABLE(htim);
 80041ca:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 80041cc:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 80041d0:	645a      	str	r2, [r3, #68]	; 0x44
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 80041d2:	689a      	ldr	r2, [r3, #8]
 80041d4:	f002 0207 	and.w	r2, r2, #7
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 80041d8:	2a06      	cmp	r2, #6
 80041da:	d1d6      	bne.n	800418a <HAL_TIM_OC_Start+0x5e>
  return HAL_OK;
 80041dc:	2000      	movs	r0, #0
}
 80041de:	4770      	bx	lr
  if (TIM_CHANNEL_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)
 80041e0:	f890 303f 	ldrb.w	r3, [r0, #63]	; 0x3f
 80041e4:	2b01      	cmp	r3, #1
 80041e6:	d1de      	bne.n	80041a6 <HAL_TIM_OC_Start+0x7a>
  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
 80041e8:	2302      	movs	r3, #2
 80041ea:	f880 303f 	strb.w	r3, [r0, #63]	; 0x3f
 80041ee:	e7a5      	b.n	800413c <HAL_TIM_OC_Start+0x10>
 80041f0:	40010000 	.word	0x40010000
 80041f4:	40000400 	.word	0x40000400

080041f8 <HAL_TIM_PWM_MspInit>:
 80041f8:	4770      	bx	lr
 80041fa:	bf00      	nop

080041fc <HAL_TIM_PWM_Init>:
  if (htim == NULL)
 80041fc:	2800      	cmp	r0, #0
 80041fe:	d076      	beq.n	80042ee <HAL_TIM_PWM_Init+0xf2>
{
 8004200:	b510      	push	{r4, lr}
  if (htim->State == HAL_TIM_STATE_RESET)
 8004202:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 8004206:	4604      	mov	r4, r0
 8004208:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 800420c:	2b00      	cmp	r3, #0
 800420e:	d055      	beq.n	80042bc <HAL_TIM_PWM_Init+0xc0>
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 8004210:	6822      	ldr	r2, [r4, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8004212:	4938      	ldr	r1, [pc, #224]	; (80042f4 <HAL_TIM_PWM_Init+0xf8>)
  htim->State = HAL_TIM_STATE_BUSY;
 8004214:	2302      	movs	r3, #2
 8004216:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 800421a:	428a      	cmp	r2, r1
  tmpcr1 = TIMx->CR1;
 800421c:	6813      	ldr	r3, [r2, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 800421e:	d052      	beq.n	80042c6 <HAL_TIM_PWM_Init+0xca>
 8004220:	f1b2 4f80 	cmp.w	r2, #1073741824	; 0x40000000
 8004224:	d021      	beq.n	800426a <HAL_TIM_PWM_Init+0x6e>
 8004226:	f5a1 417c 	sub.w	r1, r1, #64512	; 0xfc00
 800422a:	428a      	cmp	r2, r1
 800422c:	d01d      	beq.n	800426a <HAL_TIM_PWM_Init+0x6e>
 800422e:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 8004232:	428a      	cmp	r2, r1
 8004234:	d019      	beq.n	800426a <HAL_TIM_PWM_Init+0x6e>
 8004236:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 800423a:	428a      	cmp	r2, r1
 800423c:	d015      	beq.n	800426a <HAL_TIM_PWM_Init+0x6e>
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 800423e:	f501 319a 	add.w	r1, r1, #78848	; 0x13400
 8004242:	428a      	cmp	r2, r1
 8004244:	d015      	beq.n	8004272 <HAL_TIM_PWM_Init+0x76>
 8004246:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 800424a:	428a      	cmp	r2, r1
 800424c:	d011      	beq.n	8004272 <HAL_TIM_PWM_Init+0x76>
 800424e:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 8004252:	428a      	cmp	r2, r1
 8004254:	d00d      	beq.n	8004272 <HAL_TIM_PWM_Init+0x76>
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8004256:	69a0      	ldr	r0, [r4, #24]
  TIMx->ARR = (uint32_t)Structure->Period ;
 8004258:	68e1      	ldr	r1, [r4, #12]
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 800425a:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800425e:	4303      	orrs	r3, r0
  TIMx->CR1 = tmpcr1;
 8004260:	6013      	str	r3, [r2, #0]
  TIMx->PSC = Structure->Prescaler;
 8004262:	6863      	ldr	r3, [r4, #4]
  TIMx->ARR = (uint32_t)Structure->Period ;
 8004264:	62d1      	str	r1, [r2, #44]	; 0x2c
  TIMx->PSC = Structure->Prescaler;
 8004266:	6293      	str	r3, [r2, #40]	; 0x28
  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 8004268:	e010      	b.n	800428c <HAL_TIM_PWM_Init+0x90>
    tmpcr1 |= Structure->CounterMode;
 800426a:	68a1      	ldr	r1, [r4, #8]
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 800426c:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 8004270:	430b      	orrs	r3, r1
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8004272:	6920      	ldr	r0, [r4, #16]
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8004274:	69a1      	ldr	r1, [r4, #24]
    tmpcr1 &= ~TIM_CR1_CKD;
 8004276:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 800427a:	4303      	orrs	r3, r0
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 800427c:	f023 0380 	bic.w	r3, r3, #128	; 0x80
  TIMx->ARR = (uint32_t)Structure->Period ;
 8004280:	68e0      	ldr	r0, [r4, #12]
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8004282:	430b      	orrs	r3, r1
  TIMx->PSC = Structure->Prescaler;
 8004284:	6861      	ldr	r1, [r4, #4]
  TIMx->CR1 = tmpcr1;
 8004286:	6013      	str	r3, [r2, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 8004288:	62d0      	str	r0, [r2, #44]	; 0x2c
  TIMx->PSC = Structure->Prescaler;
 800428a:	6291      	str	r1, [r2, #40]	; 0x28
  TIMx->EGR = TIM_EGR_UG;
 800428c:	2301      	movs	r3, #1
 800428e:	6153      	str	r3, [r2, #20]
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 8004290:	f884 3046 	strb.w	r3, [r4, #70]	; 0x46
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 8004294:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
 8004298:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
 800429c:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
 80042a0:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 80042a4:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 80042a8:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 80042ac:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
 80042b0:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
  htim->State = HAL_TIM_STATE_READY;
 80042b4:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  return HAL_OK;
 80042b8:	2000      	movs	r0, #0
}
 80042ba:	bd10      	pop	{r4, pc}
    htim->Lock = HAL_UNLOCKED;
 80042bc:	f880 203c 	strb.w	r2, [r0, #60]	; 0x3c
    HAL_TIM_PWM_MspInit(htim);
 80042c0:	f7ff ff9a 	bl	80041f8 <HAL_TIM_PWM_MspInit>
 80042c4:	e7a4      	b.n	8004210 <HAL_TIM_PWM_Init+0x14>
    tmpcr1 |= Structure->CounterMode;
 80042c6:	68a0      	ldr	r0, [r4, #8]
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 80042c8:	6921      	ldr	r1, [r4, #16]
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 80042ca:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 80042ce:	4303      	orrs	r3, r0
    tmpcr1 &= ~TIM_CR1_CKD;
 80042d0:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 80042d4:	430b      	orrs	r3, r1
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 80042d6:	69a1      	ldr	r1, [r4, #24]
 80042d8:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 80042dc:	430b      	orrs	r3, r1
  TIMx->CR1 = tmpcr1;
 80042de:	6013      	str	r3, [r2, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 80042e0:	68e3      	ldr	r3, [r4, #12]
 80042e2:	62d3      	str	r3, [r2, #44]	; 0x2c
  TIMx->PSC = Structure->Prescaler;
 80042e4:	6863      	ldr	r3, [r4, #4]
 80042e6:	6293      	str	r3, [r2, #40]	; 0x28
    TIMx->RCR = Structure->RepetitionCounter;
 80042e8:	6963      	ldr	r3, [r4, #20]
 80042ea:	6313      	str	r3, [r2, #48]	; 0x30
 80042ec:	e7ce      	b.n	800428c <HAL_TIM_PWM_Init+0x90>
    return HAL_ERROR;
 80042ee:	2001      	movs	r0, #1
}
 80042f0:	4770      	bx	lr
 80042f2:	bf00      	nop
 80042f4:	40010000 	.word	0x40010000

080042f8 <HAL_TIM_IC_Start>:
{
 80042f8:	4684      	mov	ip, r0
  HAL_TIM_ChannelStateTypeDef channel_state = TIM_CHANNEL_STATE_GET(htim, Channel);
 80042fa:	b961      	cbnz	r1, 8004316 <HAL_TIM_IC_Start+0x1e>
 80042fc:	f890 303e 	ldrb.w	r3, [r0, #62]	; 0x3e
  HAL_TIM_ChannelStateTypeDef complementary_channel_state = TIM_CHANNEL_N_STATE_GET(htim, Channel);
 8004300:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
  HAL_TIM_ChannelStateTypeDef channel_state = TIM_CHANNEL_STATE_GET(htim, Channel);
 8004304:	b2d8      	uxtb	r0, r3
  HAL_TIM_ChannelStateTypeDef complementary_channel_state = TIM_CHANNEL_N_STATE_GET(htim, Channel);
 8004306:	b2d3      	uxtb	r3, r2
  if ((channel_state != HAL_TIM_CHANNEL_STATE_READY)
 8004308:	2801      	cmp	r0, #1
 800430a:	d102      	bne.n	8004312 <HAL_TIM_IC_Start+0x1a>
      || (complementary_channel_state != HAL_TIM_CHANNEL_STATE_READY))
 800430c:	2b01      	cmp	r3, #1
 800430e:	d011      	beq.n	8004334 <HAL_TIM_IC_Start+0x3c>
}
 8004310:	4770      	bx	lr
    return HAL_ERROR;
 8004312:	2001      	movs	r0, #1
 8004314:	4770      	bx	lr
  HAL_TIM_ChannelStateTypeDef channel_state = TIM_CHANNEL_STATE_GET(htim, Channel);
 8004316:	2904      	cmp	r1, #4
 8004318:	d04a      	beq.n	80043b0 <HAL_TIM_IC_Start+0xb8>
 800431a:	2908      	cmp	r1, #8
 800431c:	bf0b      	itete	eq
 800431e:	f890 3040 	ldrbeq.w	r3, [r0, #64]	; 0x40
 8004322:	f890 3041 	ldrbne.w	r3, [r0, #65]	; 0x41
  HAL_TIM_ChannelStateTypeDef complementary_channel_state = TIM_CHANNEL_N_STATE_GET(htim, Channel);
 8004326:	f890 2044 	ldrbeq.w	r2, [r0, #68]	; 0x44
 800432a:	f890 2045 	ldrbne.w	r2, [r0, #69]	; 0x45
  HAL_TIM_ChannelStateTypeDef channel_state = TIM_CHANNEL_STATE_GET(htim, Channel);
 800432e:	b2d8      	uxtb	r0, r3
  HAL_TIM_ChannelStateTypeDef complementary_channel_state = TIM_CHANNEL_N_STATE_GET(htim, Channel);
 8004330:	b2d3      	uxtb	r3, r2
 8004332:	e7e9      	b.n	8004308 <HAL_TIM_IC_Start+0x10>
  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
 8004334:	2302      	movs	r3, #2
 8004336:	2900      	cmp	r1, #0
 8004338:	d041      	beq.n	80043be <HAL_TIM_IC_Start+0xc6>
 800433a:	2904      	cmp	r1, #4
 800433c:	d046      	beq.n	80043cc <HAL_TIM_IC_Start+0xd4>
 800433e:	2908      	cmp	r1, #8
 8004340:	bf0b      	itete	eq
 8004342:	f88c 3040 	strbeq.w	r3, [ip, #64]	; 0x40
 8004346:	f88c 3041 	strbne.w	r3, [ip, #65]	; 0x41
  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
 800434a:	f88c 3044 	strbeq.w	r3, [ip, #68]	; 0x44
 800434e:	f88c 3045 	strbne.w	r3, [ip, #69]	; 0x45
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
 8004352:	f8dc 3000 	ldr.w	r3, [ip]
  tmp = TIM_CCER_CC1E << (Channel & 0x1FU); /* 0x1FU = 31 bits max shift */
 8004356:	2201      	movs	r2, #1
  TIMx->CCER &= ~tmp;
 8004358:	6a18      	ldr	r0, [r3, #32]
  tmp = TIM_CCER_CC1E << (Channel & 0x1FU); /* 0x1FU = 31 bits max shift */
 800435a:	f001 011f 	and.w	r1, r1, #31
 800435e:	fa02 f101 	lsl.w	r1, r2, r1
  TIMx->CCER &= ~tmp;
 8004362:	ea20 0001 	bic.w	r0, r0, r1
 8004366:	6218      	str	r0, [r3, #32]
  TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
 8004368:	6a18      	ldr	r0, [r3, #32]
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 800436a:	4a1b      	ldr	r2, [pc, #108]	; (80043d8 <HAL_TIM_IC_Start+0xe0>)
  TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
 800436c:	4301      	orrs	r1, r0
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 800436e:	4293      	cmp	r3, r2
  TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
 8004370:	6219      	str	r1, [r3, #32]
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8004372:	d012      	beq.n	800439a <HAL_TIM_IC_Start+0xa2>
 8004374:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8004378:	d00f      	beq.n	800439a <HAL_TIM_IC_Start+0xa2>
 800437a:	f5a2 427c 	sub.w	r2, r2, #64512	; 0xfc00
 800437e:	4293      	cmp	r3, r2
 8004380:	d00b      	beq.n	800439a <HAL_TIM_IC_Start+0xa2>
 8004382:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8004386:	4293      	cmp	r3, r2
 8004388:	d007      	beq.n	800439a <HAL_TIM_IC_Start+0xa2>
 800438a:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800438e:	4293      	cmp	r3, r2
 8004390:	d003      	beq.n	800439a <HAL_TIM_IC_Start+0xa2>
 8004392:	f502 329a 	add.w	r2, r2, #78848	; 0x13400
 8004396:	4293      	cmp	r3, r2
 8004398:	d104      	bne.n	80043a4 <HAL_TIM_IC_Start+0xac>
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 800439a:	689a      	ldr	r2, [r3, #8]
 800439c:	f002 0207 	and.w	r2, r2, #7
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 80043a0:	2a06      	cmp	r2, #6
 80043a2:	d011      	beq.n	80043c8 <HAL_TIM_IC_Start+0xd0>
    __HAL_TIM_ENABLE(htim);
 80043a4:	681a      	ldr	r2, [r3, #0]
 80043a6:	f042 0201 	orr.w	r2, r2, #1
  return HAL_OK;
 80043aa:	2000      	movs	r0, #0
    __HAL_TIM_ENABLE(htim);
 80043ac:	601a      	str	r2, [r3, #0]
 80043ae:	4770      	bx	lr
  HAL_TIM_ChannelStateTypeDef channel_state = TIM_CHANNEL_STATE_GET(htim, Channel);
 80043b0:	f890 303f 	ldrb.w	r3, [r0, #63]	; 0x3f
  HAL_TIM_ChannelStateTypeDef complementary_channel_state = TIM_CHANNEL_N_STATE_GET(htim, Channel);
 80043b4:	f890 2043 	ldrb.w	r2, [r0, #67]	; 0x43
  HAL_TIM_ChannelStateTypeDef channel_state = TIM_CHANNEL_STATE_GET(htim, Channel);
 80043b8:	b2d8      	uxtb	r0, r3
  HAL_TIM_ChannelStateTypeDef complementary_channel_state = TIM_CHANNEL_N_STATE_GET(htim, Channel);
 80043ba:	b2d3      	uxtb	r3, r2
 80043bc:	e7a4      	b.n	8004308 <HAL_TIM_IC_Start+0x10>
  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
 80043be:	f88c 303e 	strb.w	r3, [ip, #62]	; 0x3e
  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
 80043c2:	f88c 3042 	strb.w	r3, [ip, #66]	; 0x42
 80043c6:	e7c4      	b.n	8004352 <HAL_TIM_IC_Start+0x5a>
  return HAL_OK;
 80043c8:	2000      	movs	r0, #0
 80043ca:	e7a1      	b.n	8004310 <HAL_TIM_IC_Start+0x18>
  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
 80043cc:	f88c 303f 	strb.w	r3, [ip, #63]	; 0x3f
  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
 80043d0:	f88c 3043 	strb.w	r3, [ip, #67]	; 0x43
 80043d4:	e7bd      	b.n	8004352 <HAL_TIM_IC_Start+0x5a>
 80043d6:	bf00      	nop
 80043d8:	40010000 	.word	0x40010000

080043dc <HAL_TIM_IC_ConfigChannel>:
{
 80043dc:	4603      	mov	r3, r0
  __HAL_LOCK(htim);
 80043de:	f890 003c 	ldrb.w	r0, [r0, #60]	; 0x3c
 80043e2:	2801      	cmp	r0, #1
 80043e4:	f000 80cc 	beq.w	8004580 <HAL_TIM_IC_ConfigChannel+0x1a4>
 80043e8:	2001      	movs	r0, #1
{
 80043ea:	b4f0      	push	{r4, r5, r6, r7}
  __HAL_LOCK(htim);
 80043ec:	f883 003c 	strb.w	r0, [r3, #60]	; 0x3c
  if (Channel == TIM_CHANNEL_1)
 80043f0:	b15a      	cbz	r2, 800440a <HAL_TIM_IC_ConfigChannel+0x2e>
  else if (Channel == TIM_CHANNEL_2)
 80043f2:	2a04      	cmp	r2, #4
 80043f4:	d04c      	beq.n	8004490 <HAL_TIM_IC_ConfigChannel+0xb4>
  else if (Channel == TIM_CHANNEL_3)
 80043f6:	2a08      	cmp	r2, #8
 80043f8:	f000 809a 	beq.w	8004530 <HAL_TIM_IC_ConfigChannel+0x154>
  else if (Channel == TIM_CHANNEL_4)
 80043fc:	2a0c      	cmp	r2, #12
 80043fe:	d071      	beq.n	80044e4 <HAL_TIM_IC_ConfigChannel+0x108>
  __HAL_UNLOCK(htim);
 8004400:	2200      	movs	r2, #0
 8004402:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
}
 8004406:	bcf0      	pop	{r4, r5, r6, r7}
 8004408:	4770      	bx	lr
    TIM_TI1_SetConfig(htim->Instance,
 800440a:	681a      	ldr	r2, [r3, #0]
  if (IS_TIM_CC2_INSTANCE(TIMx) != RESET)
 800440c:	f8df c174 	ldr.w	ip, [pc, #372]	; 8004584 <HAL_TIM_IC_ConfigChannel+0x1a8>
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8004410:	6a16      	ldr	r6, [r2, #32]
    TIM_TI1_SetConfig(htim->Instance,
 8004412:	68c8      	ldr	r0, [r1, #12]
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8004414:	f026 0601 	bic.w	r6, r6, #1
    TIM_TI1_SetConfig(htim->Instance,
 8004418:	e9d1 4500 	ldrd	r4, r5, [r1]
  if (IS_TIM_CC2_INSTANCE(TIMx) != RESET)
 800441c:	4562      	cmp	r2, ip
  TIMx->CCER &= ~TIM_CCER_CC1E;
 800441e:	6216      	str	r6, [r2, #32]
  tmpccmr1 = TIMx->CCMR1;
 8004420:	6997      	ldr	r7, [r2, #24]
  tmpccer = TIMx->CCER;
 8004422:	6a16      	ldr	r6, [r2, #32]
  if (IS_TIM_CC2_INSTANCE(TIMx) != RESET)
 8004424:	d015      	beq.n	8004452 <HAL_TIM_IC_ConfigChannel+0x76>
 8004426:	f1b2 4f80 	cmp.w	r2, #1073741824	; 0x40000000
 800442a:	d012      	beq.n	8004452 <HAL_TIM_IC_ConfigChannel+0x76>
 800442c:	f5ac 4c7c 	sub.w	ip, ip, #64512	; 0xfc00
 8004430:	4562      	cmp	r2, ip
 8004432:	d00e      	beq.n	8004452 <HAL_TIM_IC_ConfigChannel+0x76>
 8004434:	f50c 6c80 	add.w	ip, ip, #1024	; 0x400
 8004438:	4562      	cmp	r2, ip
 800443a:	d00a      	beq.n	8004452 <HAL_TIM_IC_ConfigChannel+0x76>
 800443c:	f50c 6c80 	add.w	ip, ip, #1024	; 0x400
 8004440:	4562      	cmp	r2, ip
 8004442:	d006      	beq.n	8004452 <HAL_TIM_IC_ConfigChannel+0x76>
 8004444:	f50c 3c9a 	add.w	ip, ip, #78848	; 0x13400
 8004448:	4562      	cmp	r2, ip
 800444a:	d002      	beq.n	8004452 <HAL_TIM_IC_ConfigChannel+0x76>
    tmpccmr1 |= TIM_CCMR1_CC1S_0;
 800444c:	f047 0c01 	orr.w	ip, r7, #1
 8004450:	e003      	b.n	800445a <HAL_TIM_IC_ConfigChannel+0x7e>
    tmpccmr1 &= ~TIM_CCMR1_CC1S;
 8004452:	f027 0c03 	bic.w	ip, r7, #3
    tmpccmr1 |= TIM_ICSelection;
 8004456:	ea45 0c0c 	orr.w	ip, r5, ip
  tmpccmr1 |= ((TIM_ICFilter << 4U) & TIM_CCMR1_IC1F);
 800445a:	0100      	lsls	r0, r0, #4
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
 800445c:	f02c 0cf0 	bic.w	ip, ip, #240	; 0xf0
  tmpccmr1 |= ((TIM_ICFilter << 4U) & TIM_CCMR1_IC1F);
 8004460:	b2c0      	uxtb	r0, r0
 8004462:	ea40 000c 	orr.w	r0, r0, ip
  TIMx->CCMR1 = tmpccmr1;
 8004466:	6190      	str	r0, [r2, #24]
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 8004468:	f026 050a 	bic.w	r5, r6, #10
  tmpccer |= (TIM_ICPolarity & (TIM_CCER_CC1P | TIM_CCER_CC1NP));
 800446c:	f004 000a 	and.w	r0, r4, #10
 8004470:	4328      	orrs	r0, r5
  TIMx->CCER = tmpccer;
 8004472:	6210      	str	r0, [r2, #32]
    htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
 8004474:	6990      	ldr	r0, [r2, #24]
    htim->Instance->CCMR1 |= sConfig->ICPrescaler;
 8004476:	688c      	ldr	r4, [r1, #8]
    htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
 8004478:	f020 000c 	bic.w	r0, r0, #12
 800447c:	6190      	str	r0, [r2, #24]
    htim->Instance->CCMR1 |= sConfig->ICPrescaler;
 800447e:	6991      	ldr	r1, [r2, #24]
 8004480:	4321      	orrs	r1, r4
 8004482:	6191      	str	r1, [r2, #24]
  __HAL_UNLOCK(htim);
 8004484:	2200      	movs	r2, #0
 8004486:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
  HAL_StatusTypeDef status = HAL_OK;
 800448a:	2000      	movs	r0, #0
}
 800448c:	bcf0      	pop	{r4, r5, r6, r7}
 800448e:	4770      	bx	lr
    TIM_TI2_SetConfig(htim->Instance,
 8004490:	681a      	ldr	r2, [r3, #0]
 8004492:	e9d1 0600 	ldrd	r0, r6, [r1]
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8004496:	6a15      	ldr	r5, [r2, #32]
  tmpccer |= ((TIM_ICPolarity << 4U) & (TIM_CCER_CC2P | TIM_CCER_CC2NP));
 8004498:	0100      	lsls	r0, r0, #4
  TIMx->CCER &= ~TIM_CCER_CC2E;
 800449a:	f025 0510 	bic.w	r5, r5, #16
  tmpccer |= ((TIM_ICPolarity << 4U) & (TIM_CCER_CC2P | TIM_CCER_CC2NP));
 800449e:	f000 04a0 	and.w	r4, r0, #160	; 0xa0
    TIM_TI2_SetConfig(htim->Instance,
 80044a2:	68c8      	ldr	r0, [r1, #12]
  TIMx->CCER &= ~TIM_CCER_CC2E;
 80044a4:	6215      	str	r5, [r2, #32]
    htim->Instance->CCMR1 |= (sConfig->ICPrescaler << 8U);
 80044a6:	688d      	ldr	r5, [r1, #8]
  tmpccmr1 = TIMx->CCMR1;
 80044a8:	6991      	ldr	r1, [r2, #24]
  tmpccmr1 &= ~TIM_CCMR1_CC2S;
 80044aa:	f421 7140 	bic.w	r1, r1, #768	; 0x300
  tmpccmr1 |= (TIM_ICSelection << 8U);
 80044ae:	ea41 2106 	orr.w	r1, r1, r6, lsl #8
  tmpccmr1 |= ((TIM_ICFilter << 12U) & TIM_CCMR1_IC2F);
 80044b2:	0300      	lsls	r0, r0, #12
 80044b4:	b280      	uxth	r0, r0
  tmpccmr1 &= ~TIM_CCMR1_IC2F;
 80044b6:	f421 4170 	bic.w	r1, r1, #61440	; 0xf000
  tmpccmr1 |= ((TIM_ICFilter << 12U) & TIM_CCMR1_IC2F);
 80044ba:	4301      	orrs	r1, r0
  tmpccer = TIMx->CCER;
 80044bc:	6a10      	ldr	r0, [r2, #32]
  TIMx->CCMR1 = tmpccmr1 ;
 80044be:	6191      	str	r1, [r2, #24]
  tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
 80044c0:	f020 00a0 	bic.w	r0, r0, #160	; 0xa0
  tmpccer |= ((TIM_ICPolarity << 4U) & (TIM_CCER_CC2P | TIM_CCER_CC2NP));
 80044c4:	4320      	orrs	r0, r4
  TIMx->CCER = tmpccer;
 80044c6:	6210      	str	r0, [r2, #32]
    htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
 80044c8:	6994      	ldr	r4, [r2, #24]
 80044ca:	f424 6440 	bic.w	r4, r4, #3072	; 0xc00
 80044ce:	6194      	str	r4, [r2, #24]
    htim->Instance->CCMR1 |= (sConfig->ICPrescaler << 8U);
 80044d0:	6991      	ldr	r1, [r2, #24]
 80044d2:	ea41 2105 	orr.w	r1, r1, r5, lsl #8
 80044d6:	6191      	str	r1, [r2, #24]
  __HAL_UNLOCK(htim);
 80044d8:	2200      	movs	r2, #0
 80044da:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
  HAL_StatusTypeDef status = HAL_OK;
 80044de:	2000      	movs	r0, #0
}
 80044e0:	bcf0      	pop	{r4, r5, r6, r7}
 80044e2:	4770      	bx	lr
    TIM_TI4_SetConfig(htim->Instance,
 80044e4:	681a      	ldr	r2, [r3, #0]
 80044e6:	e9d1 0600 	ldrd	r0, r6, [r1]
  TIMx->CCER &= ~TIM_CCER_CC4E;
 80044ea:	6a15      	ldr	r5, [r2, #32]
  tmpccer |= ((TIM_ICPolarity << 12U) & (TIM_CCER_CC4P | TIM_CCER_CC4NP));
 80044ec:	0300      	lsls	r0, r0, #12
  TIMx->CCER &= ~TIM_CCER_CC4E;
 80044ee:	f425 5580 	bic.w	r5, r5, #4096	; 0x1000
  tmpccer |= ((TIM_ICPolarity << 12U) & (TIM_CCER_CC4P | TIM_CCER_CC4NP));
 80044f2:	f400 4420 	and.w	r4, r0, #40960	; 0xa000
    TIM_TI4_SetConfig(htim->Instance,
 80044f6:	68c8      	ldr	r0, [r1, #12]
  TIMx->CCER &= ~TIM_CCER_CC4E;
 80044f8:	6215      	str	r5, [r2, #32]
    htim->Instance->CCMR2 |= (sConfig->ICPrescaler << 8U);
 80044fa:	688d      	ldr	r5, [r1, #8]
  tmpccmr2 = TIMx->CCMR2;
 80044fc:	69d1      	ldr	r1, [r2, #28]
  tmpccmr2 &= ~TIM_CCMR2_CC4S;
 80044fe:	f421 7140 	bic.w	r1, r1, #768	; 0x300
  tmpccmr2 |= ((TIM_ICFilter << 12U) & TIM_CCMR2_IC4F);
 8004502:	0300      	lsls	r0, r0, #12
  tmpccmr2 |= (TIM_ICSelection << 8U);
 8004504:	ea41 2106 	orr.w	r1, r1, r6, lsl #8
  tmpccmr2 |= ((TIM_ICFilter << 12U) & TIM_CCMR2_IC4F);
 8004508:	b280      	uxth	r0, r0
  tmpccmr2 &= ~TIM_CCMR2_IC4F;
 800450a:	f421 4170 	bic.w	r1, r1, #61440	; 0xf000
  tmpccmr2 |= ((TIM_ICFilter << 12U) & TIM_CCMR2_IC4F);
 800450e:	4301      	orrs	r1, r0
  tmpccer = TIMx->CCER;
 8004510:	6a10      	ldr	r0, [r2, #32]
  TIMx->CCMR2 = tmpccmr2;
 8004512:	61d1      	str	r1, [r2, #28]
  tmpccer &= ~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
 8004514:	f420 4020 	bic.w	r0, r0, #40960	; 0xa000
  tmpccer |= ((TIM_ICPolarity << 12U) & (TIM_CCER_CC4P | TIM_CCER_CC4NP));
 8004518:	4320      	orrs	r0, r4
  TIMx->CCER = tmpccer ;
 800451a:	6210      	str	r0, [r2, #32]
    htim->Instance->CCMR2 &= ~TIM_CCMR2_IC4PSC;
 800451c:	69d4      	ldr	r4, [r2, #28]
 800451e:	f424 6440 	bic.w	r4, r4, #3072	; 0xc00
 8004522:	61d4      	str	r4, [r2, #28]
    htim->Instance->CCMR2 |= (sConfig->ICPrescaler << 8U);
 8004524:	69d1      	ldr	r1, [r2, #28]
 8004526:	ea41 2105 	orr.w	r1, r1, r5, lsl #8
  HAL_StatusTypeDef status = HAL_OK;
 800452a:	2000      	movs	r0, #0
    htim->Instance->CCMR2 |= (sConfig->ICPrescaler << 8U);
 800452c:	61d1      	str	r1, [r2, #28]
 800452e:	e767      	b.n	8004400 <HAL_TIM_IC_ConfigChannel+0x24>
    TIM_TI3_SetConfig(htim->Instance,
 8004530:	681a      	ldr	r2, [r3, #0]
 8004532:	e9d1 0400 	ldrd	r0, r4, [r1]
  TIMx->CCER &= ~TIM_CCER_CC3E;
 8004536:	6a16      	ldr	r6, [r2, #32]
  tmpccer |= ((TIM_ICPolarity << 8U) & (TIM_CCER_CC3P | TIM_CCER_CC3NP));
 8004538:	0200      	lsls	r0, r0, #8
  TIMx->CCER &= ~TIM_CCER_CC3E;
 800453a:	f426 7680 	bic.w	r6, r6, #256	; 0x100
  tmpccer |= ((TIM_ICPolarity << 8U) & (TIM_CCER_CC3P | TIM_CCER_CC3NP));
 800453e:	f400 6520 	and.w	r5, r0, #2560	; 0xa00
    TIM_TI3_SetConfig(htim->Instance,
 8004542:	68c8      	ldr	r0, [r1, #12]
  TIMx->CCER &= ~TIM_CCER_CC3E;
 8004544:	6216      	str	r6, [r2, #32]
    htim->Instance->CCMR2 |= sConfig->ICPrescaler;
 8004546:	688e      	ldr	r6, [r1, #8]
  tmpccmr2 = TIMx->CCMR2;
 8004548:	69d1      	ldr	r1, [r2, #28]
  tmpccmr2 &= ~TIM_CCMR2_CC3S;
 800454a:	f021 0103 	bic.w	r1, r1, #3
  tmpccmr2 |= TIM_ICSelection;
 800454e:	4321      	orrs	r1, r4
  tmpccmr2 |= ((TIM_ICFilter << 4U) & TIM_CCMR2_IC3F);
 8004550:	0100      	lsls	r0, r0, #4
 8004552:	b2c0      	uxtb	r0, r0
  tmpccmr2 &= ~TIM_CCMR2_IC3F;
 8004554:	f021 01f0 	bic.w	r1, r1, #240	; 0xf0
  tmpccmr2 |= ((TIM_ICFilter << 4U) & TIM_CCMR2_IC3F);
 8004558:	4301      	orrs	r1, r0
  tmpccer = TIMx->CCER;
 800455a:	6a10      	ldr	r0, [r2, #32]
  TIMx->CCMR2 = tmpccmr2;
 800455c:	61d1      	str	r1, [r2, #28]
  tmpccer &= ~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
 800455e:	f420 6020 	bic.w	r0, r0, #2560	; 0xa00
  tmpccer |= ((TIM_ICPolarity << 8U) & (TIM_CCER_CC3P | TIM_CCER_CC3NP));
 8004562:	4328      	orrs	r0, r5
  TIMx->CCER = tmpccer;
 8004564:	6210      	str	r0, [r2, #32]
    htim->Instance->CCMR2 &= ~TIM_CCMR2_IC3PSC;
 8004566:	69d4      	ldr	r4, [r2, #28]
 8004568:	f024 040c 	bic.w	r4, r4, #12
 800456c:	61d4      	str	r4, [r2, #28]
    htim->Instance->CCMR2 |= sConfig->ICPrescaler;
 800456e:	69d1      	ldr	r1, [r2, #28]
 8004570:	4331      	orrs	r1, r6
 8004572:	61d1      	str	r1, [r2, #28]
  __HAL_UNLOCK(htim);
 8004574:	2200      	movs	r2, #0
 8004576:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
  HAL_StatusTypeDef status = HAL_OK;
 800457a:	2000      	movs	r0, #0
}
 800457c:	bcf0      	pop	{r4, r5, r6, r7}
 800457e:	4770      	bx	lr
  __HAL_LOCK(htim);
 8004580:	2002      	movs	r0, #2
}
 8004582:	4770      	bx	lr
 8004584:	40010000 	.word	0x40010000

08004588 <HAL_TIM_PWM_ConfigChannel>:
  __HAL_LOCK(htim);
 8004588:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 800458c:	2b01      	cmp	r3, #1
 800458e:	f000 80ca 	beq.w	8004726 <HAL_TIM_PWM_ConfigChannel+0x19e>
 8004592:	2301      	movs	r3, #1
{
 8004594:	b4f0      	push	{r4, r5, r6, r7}
  __HAL_LOCK(htim);
 8004596:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
  switch (Channel)
 800459a:	2a0c      	cmp	r2, #12
 800459c:	d808      	bhi.n	80045b0 <HAL_TIM_PWM_ConfigChannel+0x28>
 800459e:	e8df f002 	tbb	[pc, r2]
 80045a2:	073d      	.short	0x073d
 80045a4:	07680707 	.word	0x07680707
 80045a8:	07960707 	.word	0x07960707
 80045ac:	0707      	.short	0x0707
 80045ae:	0e          	.byte	0x0e
 80045af:	00          	.byte	0x00
  __HAL_UNLOCK(htim);
 80045b0:	2300      	movs	r3, #0
 80045b2:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
  switch (Channel)
 80045b6:	2201      	movs	r2, #1
}
 80045b8:	4610      	mov	r0, r2
 80045ba:	bcf0      	pop	{r4, r5, r6, r7}
 80045bc:	4770      	bx	lr
      TIM_OC4_SetConfig(htim->Instance, sConfig);
 80045be:	6803      	ldr	r3, [r0, #0]
  tmpccmrx |= (OC_Config->OCMode << 8U);
 80045c0:	680e      	ldr	r6, [r1, #0]
  TIMx->CCER &= ~TIM_CCER_CC4E;
 80045c2:	6a1a      	ldr	r2, [r3, #32]
 80045c4:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 80045c8:	621a      	str	r2, [r3, #32]
  tmpccer = TIMx->CCER;
 80045ca:	6a1a      	ldr	r2, [r3, #32]
  tmpcr2 =  TIMx->CR2;
 80045cc:	685d      	ldr	r5, [r3, #4]
  tmpccmrx = TIMx->CCMR2;
 80045ce:	69dc      	ldr	r4, [r3, #28]
  tmpccmrx &= ~TIM_CCMR2_CC4S;
 80045d0:	f424 44e6 	bic.w	r4, r4, #29440	; 0x7300
  tmpccmrx |= (OC_Config->OCMode << 8U);
 80045d4:	ea44 2406 	orr.w	r4, r4, r6, lsl #8
  tmpccer |= (OC_Config->OCPolarity << 12U);
 80045d8:	688e      	ldr	r6, [r1, #8]
  tmpccer &= ~TIM_CCER_CC4P;
 80045da:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
  tmpccer |= (OC_Config->OCPolarity << 12U);
 80045de:	ea42 3206 	orr.w	r2, r2, r6, lsl #12
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 80045e2:	4e6b      	ldr	r6, [pc, #428]	; (8004790 <HAL_TIM_PWM_ConfigChannel+0x208>)
 80045e4:	42b3      	cmp	r3, r6
 80045e6:	f000 80bd 	beq.w	8004764 <HAL_TIM_PWM_ConfigChannel+0x1dc>
  TIMx->CR2 = tmpcr2;
 80045ea:	605d      	str	r5, [r3, #4]
  TIMx->CCMR2 = tmpccmrx;
 80045ec:	61dc      	str	r4, [r3, #28]
  TIMx->CCR4 = OC_Config->Pulse;
 80045ee:	684c      	ldr	r4, [r1, #4]
 80045f0:	641c      	str	r4, [r3, #64]	; 0x40
  TIMx->CCER = tmpccer;
 80045f2:	621a      	str	r2, [r3, #32]
      htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
 80045f4:	69da      	ldr	r2, [r3, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode << 8U;
 80045f6:	690d      	ldr	r5, [r1, #16]
      htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
 80045f8:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 80045fc:	61da      	str	r2, [r3, #28]
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
 80045fe:	69dc      	ldr	r4, [r3, #28]
 8004600:	f424 6480 	bic.w	r4, r4, #1024	; 0x400
 8004604:	61dc      	str	r4, [r3, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode << 8U;
 8004606:	69d9      	ldr	r1, [r3, #28]
 8004608:	ea41 2105 	orr.w	r1, r1, r5, lsl #8
 800460c:	61d9      	str	r1, [r3, #28]
  __HAL_UNLOCK(htim);
 800460e:	2300      	movs	r3, #0
 8004610:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
  HAL_StatusTypeDef status = HAL_OK;
 8004614:	2200      	movs	r2, #0
}
 8004616:	4610      	mov	r0, r2
 8004618:	bcf0      	pop	{r4, r5, r6, r7}
 800461a:	4770      	bx	lr
      TIM_OC1_SetConfig(htim->Instance, sConfig);
 800461c:	6803      	ldr	r3, [r0, #0]
  tmpccmrx |= OC_Config->OCMode;
 800461e:	680e      	ldr	r6, [r1, #0]
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8004620:	6a1a      	ldr	r2, [r3, #32]
 8004622:	f022 0201 	bic.w	r2, r2, #1
 8004626:	621a      	str	r2, [r3, #32]
  tmpccer = TIMx->CCER;
 8004628:	6a1a      	ldr	r2, [r3, #32]
  tmpcr2 =  TIMx->CR2;
 800462a:	685d      	ldr	r5, [r3, #4]
  tmpccmrx = TIMx->CCMR1;
 800462c:	699c      	ldr	r4, [r3, #24]
  tmpccmrx &= ~TIM_CCMR1_CC1S;
 800462e:	f024 0473 	bic.w	r4, r4, #115	; 0x73
  tmpccmrx |= OC_Config->OCMode;
 8004632:	4334      	orrs	r4, r6
  tmpccer |= OC_Config->OCPolarity;
 8004634:	688e      	ldr	r6, [r1, #8]
  tmpccer &= ~TIM_CCER_CC1P;
 8004636:	f022 0202 	bic.w	r2, r2, #2
  tmpccer |= OC_Config->OCPolarity;
 800463a:	4332      	orrs	r2, r6
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
 800463c:	4e54      	ldr	r6, [pc, #336]	; (8004790 <HAL_TIM_PWM_ConfigChannel+0x208>)
 800463e:	42b3      	cmp	r3, r6
 8004640:	d074      	beq.n	800472c <HAL_TIM_PWM_ConfigChannel+0x1a4>
  TIMx->CR2 = tmpcr2;
 8004642:	605d      	str	r5, [r3, #4]
  TIMx->CCMR1 = tmpccmrx;
 8004644:	619c      	str	r4, [r3, #24]
  TIMx->CCR1 = OC_Config->Pulse;
 8004646:	684c      	ldr	r4, [r1, #4]
 8004648:	635c      	str	r4, [r3, #52]	; 0x34
  TIMx->CCER = tmpccer;
 800464a:	621a      	str	r2, [r3, #32]
      htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
 800464c:	699a      	ldr	r2, [r3, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode;
 800464e:	690d      	ldr	r5, [r1, #16]
      htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
 8004650:	f042 0208 	orr.w	r2, r2, #8
 8004654:	619a      	str	r2, [r3, #24]
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
 8004656:	699c      	ldr	r4, [r3, #24]
 8004658:	f024 0404 	bic.w	r4, r4, #4
 800465c:	619c      	str	r4, [r3, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode;
 800465e:	6999      	ldr	r1, [r3, #24]
 8004660:	4329      	orrs	r1, r5
 8004662:	6199      	str	r1, [r3, #24]
  __HAL_UNLOCK(htim);
 8004664:	2300      	movs	r3, #0
 8004666:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
  HAL_StatusTypeDef status = HAL_OK;
 800466a:	2200      	movs	r2, #0
}
 800466c:	4610      	mov	r0, r2
 800466e:	bcf0      	pop	{r4, r5, r6, r7}
 8004670:	4770      	bx	lr
      TIM_OC2_SetConfig(htim->Instance, sConfig);
 8004672:	6803      	ldr	r3, [r0, #0]
  tmpccmrx |= (OC_Config->OCMode << 8U);
 8004674:	680e      	ldr	r6, [r1, #0]
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8004676:	6a1a      	ldr	r2, [r3, #32]
 8004678:	f022 0210 	bic.w	r2, r2, #16
 800467c:	621a      	str	r2, [r3, #32]
  tmpccer = TIMx->CCER;
 800467e:	6a1a      	ldr	r2, [r3, #32]
  tmpcr2 =  TIMx->CR2;
 8004680:	685d      	ldr	r5, [r3, #4]
  tmpccmrx = TIMx->CCMR1;
 8004682:	699c      	ldr	r4, [r3, #24]
  tmpccmrx &= ~TIM_CCMR1_CC2S;
 8004684:	f424 44e6 	bic.w	r4, r4, #29440	; 0x7300
  tmpccmrx |= (OC_Config->OCMode << 8U);
 8004688:	ea44 2406 	orr.w	r4, r4, r6, lsl #8
  tmpccer |= (OC_Config->OCPolarity << 4U);
 800468c:	688e      	ldr	r6, [r1, #8]
  tmpccer &= ~TIM_CCER_CC2P;
 800468e:	f022 0220 	bic.w	r2, r2, #32
  tmpccer |= (OC_Config->OCPolarity << 4U);
 8004692:	ea42 1206 	orr.w	r2, r2, r6, lsl #4
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
 8004696:	4e3e      	ldr	r6, [pc, #248]	; (8004790 <HAL_TIM_PWM_ConfigChannel+0x208>)
 8004698:	42b3      	cmp	r3, r6
 800469a:	d054      	beq.n	8004746 <HAL_TIM_PWM_ConfigChannel+0x1be>
  TIMx->CR2 = tmpcr2;
 800469c:	605d      	str	r5, [r3, #4]
  TIMx->CCMR1 = tmpccmrx;
 800469e:	619c      	str	r4, [r3, #24]
  TIMx->CCR2 = OC_Config->Pulse;
 80046a0:	684c      	ldr	r4, [r1, #4]
 80046a2:	639c      	str	r4, [r3, #56]	; 0x38
  TIMx->CCER = tmpccer;
 80046a4:	621a      	str	r2, [r3, #32]
      htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
 80046a6:	699a      	ldr	r2, [r3, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode << 8U;
 80046a8:	690d      	ldr	r5, [r1, #16]
      htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
 80046aa:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 80046ae:	619a      	str	r2, [r3, #24]
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
 80046b0:	699c      	ldr	r4, [r3, #24]
 80046b2:	f424 6480 	bic.w	r4, r4, #1024	; 0x400
 80046b6:	619c      	str	r4, [r3, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode << 8U;
 80046b8:	6999      	ldr	r1, [r3, #24]
 80046ba:	ea41 2105 	orr.w	r1, r1, r5, lsl #8
 80046be:	6199      	str	r1, [r3, #24]
  __HAL_UNLOCK(htim);
 80046c0:	2300      	movs	r3, #0
 80046c2:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
  HAL_StatusTypeDef status = HAL_OK;
 80046c6:	2200      	movs	r2, #0
}
 80046c8:	4610      	mov	r0, r2
 80046ca:	bcf0      	pop	{r4, r5, r6, r7}
 80046cc:	4770      	bx	lr
      TIM_OC3_SetConfig(htim->Instance, sConfig);
 80046ce:	6803      	ldr	r3, [r0, #0]
  tmpccmrx |= OC_Config->OCMode;
 80046d0:	680e      	ldr	r6, [r1, #0]
  TIMx->CCER &= ~TIM_CCER_CC3E;
 80046d2:	6a1a      	ldr	r2, [r3, #32]
 80046d4:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 80046d8:	621a      	str	r2, [r3, #32]
  tmpccer = TIMx->CCER;
 80046da:	6a1a      	ldr	r2, [r3, #32]
  tmpcr2 =  TIMx->CR2;
 80046dc:	685d      	ldr	r5, [r3, #4]
  tmpccmrx = TIMx->CCMR2;
 80046de:	69dc      	ldr	r4, [r3, #28]
  tmpccmrx &= ~TIM_CCMR2_CC3S;
 80046e0:	f024 0473 	bic.w	r4, r4, #115	; 0x73
  tmpccmrx |= OC_Config->OCMode;
 80046e4:	4334      	orrs	r4, r6
  tmpccer |= (OC_Config->OCPolarity << 8U);
 80046e6:	688e      	ldr	r6, [r1, #8]
  tmpccer &= ~TIM_CCER_CC3P;
 80046e8:	f422 7200 	bic.w	r2, r2, #512	; 0x200
  tmpccer |= (OC_Config->OCPolarity << 8U);
 80046ec:	ea42 2206 	orr.w	r2, r2, r6, lsl #8
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
 80046f0:	4e27      	ldr	r6, [pc, #156]	; (8004790 <HAL_TIM_PWM_ConfigChannel+0x208>)
 80046f2:	42b3      	cmp	r3, r6
 80046f4:	d03c      	beq.n	8004770 <HAL_TIM_PWM_ConfigChannel+0x1e8>
  TIMx->CR2 = tmpcr2;
 80046f6:	605d      	str	r5, [r3, #4]
  TIMx->CCMR2 = tmpccmrx;
 80046f8:	61dc      	str	r4, [r3, #28]
  TIMx->CCR3 = OC_Config->Pulse;
 80046fa:	684c      	ldr	r4, [r1, #4]
 80046fc:	63dc      	str	r4, [r3, #60]	; 0x3c
  TIMx->CCER = tmpccer;
 80046fe:	621a      	str	r2, [r3, #32]
      htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
 8004700:	69da      	ldr	r2, [r3, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode;
 8004702:	690d      	ldr	r5, [r1, #16]
      htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
 8004704:	f042 0208 	orr.w	r2, r2, #8
 8004708:	61da      	str	r2, [r3, #28]
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
 800470a:	69dc      	ldr	r4, [r3, #28]
 800470c:	f024 0404 	bic.w	r4, r4, #4
 8004710:	61dc      	str	r4, [r3, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode;
 8004712:	69d9      	ldr	r1, [r3, #28]
 8004714:	4329      	orrs	r1, r5
 8004716:	61d9      	str	r1, [r3, #28]
  __HAL_UNLOCK(htim);
 8004718:	2300      	movs	r3, #0
 800471a:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
  HAL_StatusTypeDef status = HAL_OK;
 800471e:	2200      	movs	r2, #0
}
 8004720:	4610      	mov	r0, r2
 8004722:	bcf0      	pop	{r4, r5, r6, r7}
 8004724:	4770      	bx	lr
  __HAL_LOCK(htim);
 8004726:	2202      	movs	r2, #2
}
 8004728:	4610      	mov	r0, r2
 800472a:	4770      	bx	lr
    tmpccer |= OC_Config->OCNPolarity;
 800472c:	68ce      	ldr	r6, [r1, #12]
    tmpccer &= ~TIM_CCER_CC1NP;
 800472e:	f022 0208 	bic.w	r2, r2, #8
    tmpccer |= OC_Config->OCNPolarity;
 8004732:	4332      	orrs	r2, r6
    tmpcr2 |= OC_Config->OCNIdleState;
 8004734:	e9d1 6705 	ldrd	r6, r7, [r1, #20]
    tmpcr2 &= ~TIM_CR2_OIS1N;
 8004738:	f425 7540 	bic.w	r5, r5, #768	; 0x300
    tmpcr2 |= OC_Config->OCNIdleState;
 800473c:	433e      	orrs	r6, r7
    tmpccer &= ~TIM_CCER_CC1NE;
 800473e:	f022 0204 	bic.w	r2, r2, #4
    tmpcr2 |= OC_Config->OCNIdleState;
 8004742:	4335      	orrs	r5, r6
 8004744:	e77d      	b.n	8004642 <HAL_TIM_PWM_ConfigChannel+0xba>
    tmpccer |= (OC_Config->OCNPolarity << 4U);
 8004746:	68ce      	ldr	r6, [r1, #12]
    tmpccer &= ~TIM_CCER_CC2NP;
 8004748:	f022 0280 	bic.w	r2, r2, #128	; 0x80
    tmpccer |= (OC_Config->OCNPolarity << 4U);
 800474c:	ea42 1206 	orr.w	r2, r2, r6, lsl #4
    tmpcr2 |= (OC_Config->OCNIdleState << 2U);
 8004750:	e9d1 6705 	ldrd	r6, r7, [r1, #20]
    tmpcr2 &= ~TIM_CR2_OIS2N;
 8004754:	f425 6540 	bic.w	r5, r5, #3072	; 0xc00
    tmpcr2 |= (OC_Config->OCNIdleState << 2U);
 8004758:	433e      	orrs	r6, r7
    tmpccer &= ~TIM_CCER_CC2NE;
 800475a:	f022 0240 	bic.w	r2, r2, #64	; 0x40
    tmpcr2 |= (OC_Config->OCNIdleState << 2U);
 800475e:	ea45 0586 	orr.w	r5, r5, r6, lsl #2
 8004762:	e79b      	b.n	800469c <HAL_TIM_PWM_ConfigChannel+0x114>
    tmpcr2 |= (OC_Config->OCIdleState << 6U);
 8004764:	694e      	ldr	r6, [r1, #20]
    tmpcr2 &= ~TIM_CR2_OIS4;
 8004766:	f425 4580 	bic.w	r5, r5, #16384	; 0x4000
    tmpcr2 |= (OC_Config->OCIdleState << 6U);
 800476a:	ea45 1586 	orr.w	r5, r5, r6, lsl #6
 800476e:	e73c      	b.n	80045ea <HAL_TIM_PWM_ConfigChannel+0x62>
    tmpccer |= (OC_Config->OCNPolarity << 8U);
 8004770:	68ce      	ldr	r6, [r1, #12]
    tmpccer &= ~TIM_CCER_CC3NP;
 8004772:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
    tmpccer |= (OC_Config->OCNPolarity << 8U);
 8004776:	ea42 2206 	orr.w	r2, r2, r6, lsl #8
    tmpcr2 |= (OC_Config->OCNIdleState << 4U);
 800477a:	e9d1 6705 	ldrd	r6, r7, [r1, #20]
    tmpcr2 &= ~TIM_CR2_OIS3N;
 800477e:	f425 5540 	bic.w	r5, r5, #12288	; 0x3000
    tmpcr2 |= (OC_Config->OCNIdleState << 4U);
 8004782:	433e      	orrs	r6, r7
    tmpccer &= ~TIM_CCER_CC3NE;
 8004784:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
    tmpcr2 |= (OC_Config->OCNIdleState << 4U);
 8004788:	ea45 1506 	orr.w	r5, r5, r6, lsl #4
 800478c:	e7b3      	b.n	80046f6 <HAL_TIM_PWM_ConfigChannel+0x16e>
 800478e:	bf00      	nop
 8004790:	40010000 	.word	0x40010000

08004794 <HAL_TIM_SlaveConfigSynchro>:
  __HAL_LOCK(htim);
 8004794:	f890 203c 	ldrb.w	r2, [r0, #60]	; 0x3c
 8004798:	2a01      	cmp	r2, #1
 800479a:	d050      	beq.n	800483e <HAL_TIM_SlaveConfigSynchro+0xaa>
 800479c:	4603      	mov	r3, r0
{
 800479e:	b470      	push	{r4, r5, r6}
  htim->State = HAL_TIM_STATE_BUSY;
 80047a0:	2202      	movs	r2, #2
  tmpsmcr = htim->Instance->SMCR;
 80047a2:	6804      	ldr	r4, [r0, #0]
  htim->State = HAL_TIM_STATE_BUSY;
 80047a4:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
  __HAL_LOCK(htim);
 80047a8:	2001      	movs	r0, #1
 80047aa:	f883 003c 	strb.w	r0, [r3, #60]	; 0x3c
  tmpsmcr = htim->Instance->SMCR;
 80047ae:	68a2      	ldr	r2, [r4, #8]
  tmpsmcr |= sSlaveConfig->InputTrigger;
 80047b0:	6848      	ldr	r0, [r1, #4]
  tmpsmcr |= sSlaveConfig->SlaveMode;
 80047b2:	680d      	ldr	r5, [r1, #0]
  tmpsmcr &= ~TIM_SMCR_TS;
 80047b4:	f022 0270 	bic.w	r2, r2, #112	; 0x70
  tmpsmcr |= sSlaveConfig->InputTrigger;
 80047b8:	4302      	orrs	r2, r0
  tmpsmcr &= ~TIM_SMCR_SMS;
 80047ba:	f022 0207 	bic.w	r2, r2, #7
  tmpsmcr |= sSlaveConfig->SlaveMode;
 80047be:	432a      	orrs	r2, r5
  switch (sSlaveConfig->InputTrigger)
 80047c0:	2850      	cmp	r0, #80	; 0x50
  htim->Instance->SMCR = tmpsmcr;
 80047c2:	60a2      	str	r2, [r4, #8]
  switch (sSlaveConfig->InputTrigger)
 80047c4:	d060      	beq.n	8004888 <HAL_TIM_SlaveConfigSynchro+0xf4>
 80047c6:	d90f      	bls.n	80047e8 <HAL_TIM_SlaveConfigSynchro+0x54>
 80047c8:	2860      	cmp	r0, #96	; 0x60
 80047ca:	d03a      	beq.n	8004842 <HAL_TIM_SlaveConfigSynchro+0xae>
 80047cc:	2870      	cmp	r0, #112	; 0x70
 80047ce:	d10e      	bne.n	80047ee <HAL_TIM_SlaveConfigSynchro+0x5a>
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 80047d0:	e9d1 5202 	ldrd	r5, r2, [r1, #8]
  tmpsmcr = TIMx->SMCR;
 80047d4:	68a0      	ldr	r0, [r4, #8]
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 80047d6:	432a      	orrs	r2, r5
 80047d8:	690d      	ldr	r5, [r1, #16]
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 80047da:	f420 417f 	bic.w	r1, r0, #65280	; 0xff00
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 80047de:	ea42 2205 	orr.w	r2, r2, r5, lsl #8
 80047e2:	430a      	orrs	r2, r1
  TIMx->SMCR = tmpsmcr;
 80047e4:	60a2      	str	r2, [r4, #8]
 80047e6:	e00f      	b.n	8004808 <HAL_TIM_SlaveConfigSynchro+0x74>
  switch (sSlaveConfig->InputTrigger)
 80047e8:	2840      	cmp	r0, #64	; 0x40
 80047ea:	d03d      	beq.n	8004868 <HAL_TIM_SlaveConfigSynchro+0xd4>
 80047ec:	d907      	bls.n	80047fe <HAL_TIM_SlaveConfigSynchro+0x6a>
    htim->State = HAL_TIM_STATE_READY;
 80047ee:	2001      	movs	r0, #1
    __HAL_UNLOCK(htim);
 80047f0:	2200      	movs	r2, #0
    htim->State = HAL_TIM_STATE_READY;
 80047f2:	f883 003d 	strb.w	r0, [r3, #61]	; 0x3d
    __HAL_UNLOCK(htim);
 80047f6:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
}
 80047fa:	bc70      	pop	{r4, r5, r6}
 80047fc:	4770      	bx	lr
  switch (sSlaveConfig->InputTrigger)
 80047fe:	2820      	cmp	r0, #32
 8004800:	d002      	beq.n	8004808 <HAL_TIM_SlaveConfigSynchro+0x74>
 8004802:	d912      	bls.n	800482a <HAL_TIM_SlaveConfigSynchro+0x96>
 8004804:	2830      	cmp	r0, #48	; 0x30
 8004806:	d1f2      	bne.n	80047ee <HAL_TIM_SlaveConfigSynchro+0x5a>
  __HAL_TIM_DISABLE_IT(htim, TIM_IT_TRIGGER);
 8004808:	68e2      	ldr	r2, [r4, #12]
 800480a:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 800480e:	60e2      	str	r2, [r4, #12]
  __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);
 8004810:	68e2      	ldr	r2, [r4, #12]
  __HAL_UNLOCK(htim);
 8004812:	2100      	movs	r1, #0
  htim->State = HAL_TIM_STATE_READY;
 8004814:	2501      	movs	r5, #1
  __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);
 8004816:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 800481a:	60e2      	str	r2, [r4, #12]
  htim->State = HAL_TIM_STATE_READY;
 800481c:	f883 503d 	strb.w	r5, [r3, #61]	; 0x3d
  __HAL_UNLOCK(htim);
 8004820:	f883 103c 	strb.w	r1, [r3, #60]	; 0x3c
  return HAL_OK;
 8004824:	4608      	mov	r0, r1
}
 8004826:	bc70      	pop	{r4, r5, r6}
 8004828:	4770      	bx	lr
  switch (sSlaveConfig->InputTrigger)
 800482a:	f030 0210 	bics.w	r2, r0, #16
 800482e:	d0eb      	beq.n	8004808 <HAL_TIM_SlaveConfigSynchro+0x74>
    htim->State = HAL_TIM_STATE_READY;
 8004830:	2001      	movs	r0, #1
    __HAL_UNLOCK(htim);
 8004832:	2200      	movs	r2, #0
    htim->State = HAL_TIM_STATE_READY;
 8004834:	f883 003d 	strb.w	r0, [r3, #61]	; 0x3d
    __HAL_UNLOCK(htim);
 8004838:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    return HAL_ERROR;
 800483c:	e7dd      	b.n	80047fa <HAL_TIM_SlaveConfigSynchro+0x66>
  __HAL_LOCK(htim);
 800483e:	2002      	movs	r0, #2
}
 8004840:	4770      	bx	lr
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8004842:	6a20      	ldr	r0, [r4, #32]
      TIM_TI2_ConfigInputStage(htim->Instance,
 8004844:	690a      	ldr	r2, [r1, #16]
 8004846:	688d      	ldr	r5, [r1, #8]
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8004848:	f020 0010 	bic.w	r0, r0, #16
 800484c:	6220      	str	r0, [r4, #32]
  tmpccmr1 = TIMx->CCMR1;
 800484e:	69a1      	ldr	r1, [r4, #24]
  tmpccmr1 &= ~TIM_CCMR1_IC2F;
 8004850:	f421 4170 	bic.w	r1, r1, #61440	; 0xf000
  tmpccmr1 |= (TIM_ICFilter << 12U);
 8004854:	ea41 3102 	orr.w	r1, r1, r2, lsl #12
  tmpccer = TIMx->CCER;
 8004858:	6a22      	ldr	r2, [r4, #32]
  TIMx->CCMR1 = tmpccmr1 ;
 800485a:	61a1      	str	r1, [r4, #24]
  tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
 800485c:	f022 02a0 	bic.w	r2, r2, #160	; 0xa0
  tmpccer |= (TIM_ICPolarity << 4U);
 8004860:	ea42 1205 	orr.w	r2, r2, r5, lsl #4
  TIMx->CCER = tmpccer;
 8004864:	6222      	str	r2, [r4, #32]
 8004866:	e7cf      	b.n	8004808 <HAL_TIM_SlaveConfigSynchro+0x74>
      if (sSlaveConfig->SlaveMode == TIM_SLAVEMODE_GATED)
 8004868:	2d05      	cmp	r5, #5
 800486a:	d0c0      	beq.n	80047ee <HAL_TIM_SlaveConfigSynchro+0x5a>
      tmpccer = htim->Instance->CCER;
 800486c:	6a25      	ldr	r5, [r4, #32]
      htim->Instance->CCER &= ~TIM_CCER_CC1E;
 800486e:	6a20      	ldr	r0, [r4, #32]
      tmpccmr1 |= ((sSlaveConfig->TriggerFilter) << 4U);
 8004870:	690e      	ldr	r6, [r1, #16]
      htim->Instance->CCER &= ~TIM_CCER_CC1E;
 8004872:	f020 0001 	bic.w	r0, r0, #1
 8004876:	6220      	str	r0, [r4, #32]
      tmpccmr1 = htim->Instance->CCMR1;
 8004878:	69a2      	ldr	r2, [r4, #24]
      tmpccmr1 &= ~TIM_CCMR1_IC1F;
 800487a:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
      tmpccmr1 |= ((sSlaveConfig->TriggerFilter) << 4U);
 800487e:	ea42 1206 	orr.w	r2, r2, r6, lsl #4
      htim->Instance->CCMR1 = tmpccmr1;
 8004882:	61a2      	str	r2, [r4, #24]
      htim->Instance->CCER = tmpccer;
 8004884:	6225      	str	r5, [r4, #32]
      break;
 8004886:	e7bf      	b.n	8004808 <HAL_TIM_SlaveConfigSynchro+0x74>
      TIM_TI1_ConfigInputStage(htim->Instance,
 8004888:	6888      	ldr	r0, [r1, #8]
 800488a:	690d      	ldr	r5, [r1, #16]
  tmpccer = TIMx->CCER;
 800488c:	6a21      	ldr	r1, [r4, #32]
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 800488e:	f021 010a 	bic.w	r1, r1, #10
  tmpccer |= TIM_ICPolarity;
 8004892:	4301      	orrs	r1, r0
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8004894:	6a20      	ldr	r0, [r4, #32]
 8004896:	f020 0001 	bic.w	r0, r0, #1
 800489a:	6220      	str	r0, [r4, #32]
  tmpccmr1 = TIMx->CCMR1;
 800489c:	69a2      	ldr	r2, [r4, #24]
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
 800489e:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
  tmpccmr1 |= (TIM_ICFilter << 4U);
 80048a2:	ea42 1205 	orr.w	r2, r2, r5, lsl #4
  TIMx->CCMR1 = tmpccmr1;
 80048a6:	61a2      	str	r2, [r4, #24]
  TIMx->CCER = tmpccer;
 80048a8:	6221      	str	r1, [r4, #32]
 80048aa:	e7ad      	b.n	8004808 <HAL_TIM_SlaveConfigSynchro+0x74>

080048ac <USB_CoreInit>:
  * @param  cfg pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
 80048ac:	b084      	sub	sp, #16
 80048ae:	b082      	sub	sp, #8
 80048b0:	f10d 0c0c 	add.w	ip, sp, #12
 80048b4:	e88c 000e 	stmia.w	ip, {r1, r2, r3}
  HAL_StatusTypeDef ret;
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
 80048b8:	9a08      	ldr	r2, [sp, #32]
 80048ba:	2a01      	cmp	r2, #1
{
 80048bc:	4603      	mov	r3, r0
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
 80048be:	d12c      	bne.n	800491a <USB_CoreInit+0x6e>
  {
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
 80048c0:	6b82      	ldr	r2, [r0, #56]	; 0x38
    /* Init The ULPI Interface */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);

    /* Select vbus source */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
    if (cfg.use_external_vbus == 1U)
 80048c2:	990f      	ldr	r1, [sp, #60]	; 0x3c
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
 80048c4:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 80048c8:	6382      	str	r2, [r0, #56]	; 0x38
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
 80048ca:	68c2      	ldr	r2, [r0, #12]
 80048cc:	f422 0284 	bic.w	r2, r2, #4325376	; 0x420000
 80048d0:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 80048d4:	60c2      	str	r2, [r0, #12]
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
 80048d6:	68c2      	ldr	r2, [r0, #12]
    if (cfg.use_external_vbus == 1U)
 80048d8:	2901      	cmp	r1, #1
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
 80048da:	f422 1240 	bic.w	r2, r2, #3145728	; 0x300000
 80048de:	60c2      	str	r2, [r0, #12]
    if (cfg.use_external_vbus == 1U)
 80048e0:	d05f      	beq.n	80049a2 <USB_CoreInit+0xf6>
  * @param  USBx  Selected device
  * @retval HAL status
  */
static HAL_StatusTypeDef USB_CoreReset(USB_OTG_GlobalTypeDef *USBx)
{
  __IO uint32_t count = 0U;
 80048e2:	2200      	movs	r2, #0
  /* Wait for AHB master IDLE state. */
  do
  {
    count++;

    if (count > 200000U)
 80048e4:	4931      	ldr	r1, [pc, #196]	; (80049ac <USB_CoreInit+0x100>)
  __IO uint32_t count = 0U;
 80048e6:	9200      	str	r2, [sp, #0]
 80048e8:	e002      	b.n	80048f0 <USB_CoreInit+0x44>
    {
      return HAL_TIMEOUT;
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 80048ea:	691a      	ldr	r2, [r3, #16]
 80048ec:	2a00      	cmp	r2, #0
 80048ee:	db2d      	blt.n	800494c <USB_CoreInit+0xa0>
    count++;
 80048f0:	9a00      	ldr	r2, [sp, #0]
 80048f2:	3201      	adds	r2, #1
 80048f4:	9200      	str	r2, [sp, #0]
    if (count > 200000U)
 80048f6:	9a00      	ldr	r2, [sp, #0]
 80048f8:	428a      	cmp	r2, r1
 80048fa:	d9f6      	bls.n	80048ea <USB_CoreInit+0x3e>
      return HAL_TIMEOUT;
 80048fc:	2003      	movs	r0, #3
  if (cfg.dma_enable == 1U)
 80048fe:	9a06      	ldr	r2, [sp, #24]
 8004900:	2a01      	cmp	r2, #1
 8004902:	d107      	bne.n	8004914 <USB_CoreInit+0x68>
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_HBSTLEN_2;
 8004904:	689a      	ldr	r2, [r3, #8]
 8004906:	f042 0206 	orr.w	r2, r2, #6
 800490a:	609a      	str	r2, [r3, #8]
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_DMAEN;
 800490c:	689a      	ldr	r2, [r3, #8]
 800490e:	f042 0220 	orr.w	r2, r2, #32
 8004912:	609a      	str	r2, [r3, #8]
}
 8004914:	b002      	add	sp, #8
 8004916:	b004      	add	sp, #16
 8004918:	4770      	bx	lr
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_PHYSEL;
 800491a:	68c2      	ldr	r2, [r0, #12]
    if (count > 200000U)
 800491c:	4923      	ldr	r1, [pc, #140]	; (80049ac <USB_CoreInit+0x100>)
  __IO uint32_t count = 0U;
 800491e:	2000      	movs	r0, #0
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_PHYSEL;
 8004920:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8004924:	60da      	str	r2, [r3, #12]
  __IO uint32_t count = 0U;
 8004926:	9001      	str	r0, [sp, #4]
 8004928:	e002      	b.n	8004930 <USB_CoreInit+0x84>
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 800492a:	691a      	ldr	r2, [r3, #16]
 800492c:	2a00      	cmp	r2, #0
 800492e:	db25      	blt.n	800497c <USB_CoreInit+0xd0>
    count++;
 8004930:	9a01      	ldr	r2, [sp, #4]
 8004932:	3201      	adds	r2, #1
 8004934:	9201      	str	r2, [sp, #4]
    if (count > 200000U)
 8004936:	9a01      	ldr	r2, [sp, #4]
 8004938:	428a      	cmp	r2, r1
 800493a:	d9f6      	bls.n	800492a <USB_CoreInit+0x7e>
      return HAL_TIMEOUT;
 800493c:	2003      	movs	r0, #3
    if (cfg.battery_charging_enable == 0U)
 800493e:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8004940:	b9ba      	cbnz	r2, 8004972 <USB_CoreInit+0xc6>
      USBx->GCCFG |= USB_OTG_GCCFG_PWRDWN;
 8004942:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8004944:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8004948:	639a      	str	r2, [r3, #56]	; 0x38
 800494a:	e7d8      	b.n	80048fe <USB_CoreInit+0x52>

  /* Core Soft Reset */
  count = 0U;
 800494c:	2200      	movs	r2, #0
 800494e:	9200      	str	r2, [sp, #0]
  USBx->GRSTCTL |= USB_OTG_GRSTCTL_CSRST;
 8004950:	691a      	ldr	r2, [r3, #16]

  do
  {
    count++;

    if (count > 200000U)
 8004952:	4916      	ldr	r1, [pc, #88]	; (80049ac <USB_CoreInit+0x100>)
  USBx->GRSTCTL |= USB_OTG_GRSTCTL_CSRST;
 8004954:	f042 0201 	orr.w	r2, r2, #1
 8004958:	611a      	str	r2, [r3, #16]
 800495a:	e003      	b.n	8004964 <USB_CoreInit+0xb8>
    {
      return HAL_TIMEOUT;
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_CSRST) == USB_OTG_GRSTCTL_CSRST);
 800495c:	6918      	ldr	r0, [r3, #16]
 800495e:	f010 0001 	ands.w	r0, r0, #1
 8004962:	d0cc      	beq.n	80048fe <USB_CoreInit+0x52>
    count++;
 8004964:	9a00      	ldr	r2, [sp, #0]
 8004966:	3201      	adds	r2, #1
 8004968:	9200      	str	r2, [sp, #0]
    if (count > 200000U)
 800496a:	9a00      	ldr	r2, [sp, #0]
 800496c:	428a      	cmp	r2, r1
 800496e:	d9f5      	bls.n	800495c <USB_CoreInit+0xb0>
 8004970:	e7c4      	b.n	80048fc <USB_CoreInit+0x50>
      USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
 8004972:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8004974:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8004978:	639a      	str	r2, [r3, #56]	; 0x38
 800497a:	e7c0      	b.n	80048fe <USB_CoreInit+0x52>
  count = 0U;
 800497c:	2200      	movs	r2, #0
 800497e:	9201      	str	r2, [sp, #4]
  USBx->GRSTCTL |= USB_OTG_GRSTCTL_CSRST;
 8004980:	691a      	ldr	r2, [r3, #16]
    if (count > 200000U)
 8004982:	490a      	ldr	r1, [pc, #40]	; (80049ac <USB_CoreInit+0x100>)
  USBx->GRSTCTL |= USB_OTG_GRSTCTL_CSRST;
 8004984:	f042 0201 	orr.w	r2, r2, #1
 8004988:	611a      	str	r2, [r3, #16]
 800498a:	e003      	b.n	8004994 <USB_CoreInit+0xe8>
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_CSRST) == USB_OTG_GRSTCTL_CSRST);
 800498c:	6918      	ldr	r0, [r3, #16]
 800498e:	f010 0001 	ands.w	r0, r0, #1
 8004992:	d0d4      	beq.n	800493e <USB_CoreInit+0x92>
    count++;
 8004994:	9a01      	ldr	r2, [sp, #4]
 8004996:	3201      	adds	r2, #1
 8004998:	9201      	str	r2, [sp, #4]
    if (count > 200000U)
 800499a:	9a01      	ldr	r2, [sp, #4]
 800499c:	428a      	cmp	r2, r1
 800499e:	d9f5      	bls.n	800498c <USB_CoreInit+0xe0>
 80049a0:	e7cc      	b.n	800493c <USB_CoreInit+0x90>
      USBx->GUSBCFG |= USB_OTG_GUSBCFG_ULPIEVBUSD;
 80049a2:	68c2      	ldr	r2, [r0, #12]
 80049a4:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
 80049a8:	60c2      	str	r2, [r0, #12]
 80049aa:	e79a      	b.n	80048e2 <USB_CoreInit+0x36>
 80049ac:	00030d40 	.word	0x00030d40

080049b0 <USB_SetTurnaroundTime>:
  if (speed == USBD_FS_SPEED)
 80049b0:	2a02      	cmp	r2, #2
{
 80049b2:	4603      	mov	r3, r0
  if (speed == USBD_FS_SPEED)
 80049b4:	d00b      	beq.n	80049ce <USB_SetTurnaroundTime+0x1e>
 80049b6:	f44f 5c10 	mov.w	ip, #9216	; 0x2400
  USBx->GUSBCFG &= ~USB_OTG_GUSBCFG_TRDT;
 80049ba:	68d9      	ldr	r1, [r3, #12]
 80049bc:	f421 5170 	bic.w	r1, r1, #15360	; 0x3c00
 80049c0:	60d9      	str	r1, [r3, #12]
  USBx->GUSBCFG |= (uint32_t)((UsbTrd << 10) & USB_OTG_GUSBCFG_TRDT);
 80049c2:	68da      	ldr	r2, [r3, #12]
 80049c4:	ea42 020c 	orr.w	r2, r2, ip
}
 80049c8:	2000      	movs	r0, #0
  USBx->GUSBCFG |= (uint32_t)((UsbTrd << 10) & USB_OTG_GUSBCFG_TRDT);
 80049ca:	60da      	str	r2, [r3, #12]
}
 80049cc:	4770      	bx	lr
    if ((hclk >= 14200000U) && (hclk < 15000000U))
 80049ce:	4a26      	ldr	r2, [pc, #152]	; (8004a68 <USB_SetTurnaroundTime+0xb8>)
 80049d0:	4826      	ldr	r0, [pc, #152]	; (8004a6c <USB_SetTurnaroundTime+0xbc>)
 80049d2:	440a      	add	r2, r1
 80049d4:	4282      	cmp	r2, r0
 80049d6:	d932      	bls.n	8004a3e <USB_SetTurnaroundTime+0x8e>
    else if ((hclk >= 15000000U) && (hclk < 16000000U))
 80049d8:	4a25      	ldr	r2, [pc, #148]	; (8004a70 <USB_SetTurnaroundTime+0xc0>)
 80049da:	4826      	ldr	r0, [pc, #152]	; (8004a74 <USB_SetTurnaroundTime+0xc4>)
 80049dc:	440a      	add	r2, r1
 80049de:	4282      	cmp	r2, r0
 80049e0:	d930      	bls.n	8004a44 <USB_SetTurnaroundTime+0x94>
    else if ((hclk >= 16000000U) && (hclk < 17200000U))
 80049e2:	4825      	ldr	r0, [pc, #148]	; (8004a78 <USB_SetTurnaroundTime+0xc8>)
 80049e4:	f5a1 0274 	sub.w	r2, r1, #15990784	; 0xf40000
 80049e8:	f5a2 5210 	sub.w	r2, r2, #9216	; 0x2400
 80049ec:	4282      	cmp	r2, r0
 80049ee:	d92c      	bls.n	8004a4a <USB_SetTurnaroundTime+0x9a>
    else if ((hclk >= 17200000U) && (hclk < 18500000U))
 80049f0:	4822      	ldr	r0, [pc, #136]	; (8004a7c <USB_SetTurnaroundTime+0xcc>)
 80049f2:	f1a1 7283 	sub.w	r2, r1, #17170432	; 0x1060000
 80049f6:	f5a2 42e7 	sub.w	r2, r2, #29568	; 0x7380
 80049fa:	4282      	cmp	r2, r0
 80049fc:	d328      	bcc.n	8004a50 <USB_SetTurnaroundTime+0xa0>
    else if ((hclk >= 18500000U) && (hclk < 20000000U))
 80049fe:	4a20      	ldr	r2, [pc, #128]	; (8004a80 <USB_SetTurnaroundTime+0xd0>)
 8004a00:	4820      	ldr	r0, [pc, #128]	; (8004a84 <USB_SetTurnaroundTime+0xd4>)
 8004a02:	440a      	add	r2, r1
 8004a04:	4282      	cmp	r2, r0
 8004a06:	d926      	bls.n	8004a56 <USB_SetTurnaroundTime+0xa6>
    else if ((hclk >= 20000000U) && (hclk < 21800000U))
 8004a08:	4a1f      	ldr	r2, [pc, #124]	; (8004a88 <USB_SetTurnaroundTime+0xd8>)
 8004a0a:	4820      	ldr	r0, [pc, #128]	; (8004a8c <USB_SetTurnaroundTime+0xdc>)
 8004a0c:	440a      	add	r2, r1
 8004a0e:	4282      	cmp	r2, r0
 8004a10:	d324      	bcc.n	8004a5c <USB_SetTurnaroundTime+0xac>
    else if ((hclk >= 21800000U) && (hclk < 24000000U))
 8004a12:	4a1f      	ldr	r2, [pc, #124]	; (8004a90 <USB_SetTurnaroundTime+0xe0>)
 8004a14:	481f      	ldr	r0, [pc, #124]	; (8004a94 <USB_SetTurnaroundTime+0xe4>)
 8004a16:	440a      	add	r2, r1
 8004a18:	4282      	cmp	r2, r0
 8004a1a:	d3cc      	bcc.n	80049b6 <USB_SetTurnaroundTime+0x6>
    else if ((hclk >= 24000000U) && (hclk < 27700000U))
 8004a1c:	481e      	ldr	r0, [pc, #120]	; (8004a98 <USB_SetTurnaroundTime+0xe8>)
 8004a1e:	f1a1 72b7 	sub.w	r2, r1, #23986176	; 0x16e0000
 8004a22:	f5a2 5258 	sub.w	r2, r2, #13824	; 0x3600
 8004a26:	4282      	cmp	r2, r0
 8004a28:	d31b      	bcc.n	8004a62 <USB_SetTurnaroundTime+0xb2>
    else if ((hclk >= 27700000U) && (hclk < 32000000U))
 8004a2a:	4a1c      	ldr	r2, [pc, #112]	; (8004a9c <USB_SetTurnaroundTime+0xec>)
 8004a2c:	481c      	ldr	r0, [pc, #112]	; (8004aa0 <USB_SetTurnaroundTime+0xf0>)
 8004a2e:	440a      	add	r2, r1
 8004a30:	4282      	cmp	r2, r0
 8004a32:	bf34      	ite	cc
 8004a34:	f44f 5ce0 	movcc.w	ip, #7168	; 0x1c00
 8004a38:	f44f 5cc0 	movcs.w	ip, #6144	; 0x1800
 8004a3c:	e7bd      	b.n	80049ba <USB_SetTurnaroundTime+0xa>
 8004a3e:	f44f 5c70 	mov.w	ip, #15360	; 0x3c00
 8004a42:	e7ba      	b.n	80049ba <USB_SetTurnaroundTime+0xa>
 8004a44:	f44f 5c60 	mov.w	ip, #14336	; 0x3800
 8004a48:	e7b7      	b.n	80049ba <USB_SetTurnaroundTime+0xa>
 8004a4a:	f44f 5c50 	mov.w	ip, #13312	; 0x3400
 8004a4e:	e7b4      	b.n	80049ba <USB_SetTurnaroundTime+0xa>
 8004a50:	f44f 5c40 	mov.w	ip, #12288	; 0x3000
 8004a54:	e7b1      	b.n	80049ba <USB_SetTurnaroundTime+0xa>
 8004a56:	f44f 5c30 	mov.w	ip, #11264	; 0x2c00
 8004a5a:	e7ae      	b.n	80049ba <USB_SetTurnaroundTime+0xa>
 8004a5c:	f44f 5c20 	mov.w	ip, #10240	; 0x2800
 8004a60:	e7ab      	b.n	80049ba <USB_SetTurnaroundTime+0xa>
 8004a62:	f44f 5c00 	mov.w	ip, #8192	; 0x2000
 8004a66:	e7a8      	b.n	80049ba <USB_SetTurnaroundTime+0xa>
 8004a68:	ff275340 	.word	0xff275340
 8004a6c:	000c34ff 	.word	0x000c34ff
 8004a70:	ff1b1e40 	.word	0xff1b1e40
 8004a74:	000f423f 	.word	0x000f423f
 8004a78:	00124f7f 	.word	0x00124f7f
 8004a7c:	0013d620 	.word	0x0013d620
 8004a80:	fee5b660 	.word	0xfee5b660
 8004a84:	0016e35f 	.word	0x0016e35f
 8004a88:	feced300 	.word	0xfeced300
 8004a8c:	001b7740 	.word	0x001b7740
 8004a90:	feb35bc0 	.word	0xfeb35bc0
 8004a94:	002191c0 	.word	0x002191c0
 8004a98:	00387520 	.word	0x00387520
 8004a9c:	fe5954e0 	.word	0xfe5954e0
 8004aa0:	00419ce0 	.word	0x00419ce0

08004aa4 <USB_EnableGlobalInt>:
{
 8004aa4:	4603      	mov	r3, r0
}
 8004aa6:	2000      	movs	r0, #0
  USBx->GAHBCFG |= USB_OTG_GAHBCFG_GINT;
 8004aa8:	689a      	ldr	r2, [r3, #8]
 8004aaa:	f042 0201 	orr.w	r2, r2, #1
 8004aae:	609a      	str	r2, [r3, #8]
}
 8004ab0:	4770      	bx	lr
 8004ab2:	bf00      	nop

08004ab4 <USB_DisableGlobalInt>:
{
 8004ab4:	4603      	mov	r3, r0
}
 8004ab6:	2000      	movs	r0, #0
  USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
 8004ab8:	689a      	ldr	r2, [r3, #8]
 8004aba:	f022 0201 	bic.w	r2, r2, #1
 8004abe:	609a      	str	r2, [r3, #8]
}
 8004ac0:	4770      	bx	lr
 8004ac2:	bf00      	nop

08004ac4 <USB_SetCurrentMode>:
{
 8004ac4:	b538      	push	{r3, r4, r5, lr}
  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD);
 8004ac6:	68c3      	ldr	r3, [r0, #12]
  if (mode == USB_HOST_MODE)
 8004ac8:	2901      	cmp	r1, #1
  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD);
 8004aca:	f023 43c0 	bic.w	r3, r3, #1610612736	; 0x60000000
{
 8004ace:	4605      	mov	r5, r0
  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD);
 8004ad0:	60c3      	str	r3, [r0, #12]
  if (mode == USB_HOST_MODE)
 8004ad2:	d018      	beq.n	8004b06 <USB_SetCurrentMode+0x42>
  else if (mode == USB_DEVICE_MODE)
 8004ad4:	b9a9      	cbnz	r1, 8004b02 <USB_SetCurrentMode+0x3e>
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FDMOD;
 8004ad6:	68c3      	ldr	r3, [r0, #12]
 8004ad8:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
  uint32_t ms = 0U;
 8004adc:	460c      	mov	r4, r1
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FDMOD;
 8004ade:	60c3      	str	r3, [r0, #12]
 8004ae0:	e001      	b.n	8004ae6 <USB_SetCurrentMode+0x22>
    } while ((USB_GetMode(USBx) != (uint32_t)USB_DEVICE_MODE) && (ms < 50U));
 8004ae2:	2c32      	cmp	r4, #50	; 0x32
 8004ae4:	d00d      	beq.n	8004b02 <USB_SetCurrentMode+0x3e>
      HAL_Delay(1U);
 8004ae6:	2001      	movs	r0, #1
 8004ae8:	f7fd fdd4 	bl	8002694 <HAL_Delay>
  return ((USBx->GINTSTS) & 0x1U);
 8004aec:	696b      	ldr	r3, [r5, #20]
    } while ((USB_GetMode(USBx) != (uint32_t)USB_DEVICE_MODE) && (ms < 50U));
 8004aee:	07db      	lsls	r3, r3, #31
      ms++;
 8004af0:	f104 0401 	add.w	r4, r4, #1
    } while ((USB_GetMode(USBx) != (uint32_t)USB_DEVICE_MODE) && (ms < 50U));
 8004af4:	d4f5      	bmi.n	8004ae2 <USB_SetCurrentMode+0x1e>
    return HAL_ERROR;
 8004af6:	f1a4 0032 	sub.w	r0, r4, #50	; 0x32
 8004afa:	fab0 f080 	clz	r0, r0
 8004afe:	0940      	lsrs	r0, r0, #5
}
 8004b00:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_ERROR;
 8004b02:	2001      	movs	r0, #1
}
 8004b04:	bd38      	pop	{r3, r4, r5, pc}
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FHMOD;
 8004b06:	68c3      	ldr	r3, [r0, #12]
 8004b08:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
  uint32_t ms = 0U;
 8004b0c:	2400      	movs	r4, #0
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FHMOD;
 8004b0e:	60c3      	str	r3, [r0, #12]
 8004b10:	e001      	b.n	8004b16 <USB_SetCurrentMode+0x52>
    } while ((USB_GetMode(USBx) != (uint32_t)USB_HOST_MODE) && (ms < 50U));
 8004b12:	2c32      	cmp	r4, #50	; 0x32
 8004b14:	d0f5      	beq.n	8004b02 <USB_SetCurrentMode+0x3e>
      HAL_Delay(1U);
 8004b16:	2001      	movs	r0, #1
 8004b18:	f7fd fdbc 	bl	8002694 <HAL_Delay>
  return ((USBx->GINTSTS) & 0x1U);
 8004b1c:	696b      	ldr	r3, [r5, #20]
    } while ((USB_GetMode(USBx) != (uint32_t)USB_HOST_MODE) && (ms < 50U));
 8004b1e:	07da      	lsls	r2, r3, #31
      ms++;
 8004b20:	f104 0401 	add.w	r4, r4, #1
    } while ((USB_GetMode(USBx) != (uint32_t)USB_HOST_MODE) && (ms < 50U));
 8004b24:	d5f5      	bpl.n	8004b12 <USB_SetCurrentMode+0x4e>
    return HAL_ERROR;
 8004b26:	f1a4 0032 	sub.w	r0, r4, #50	; 0x32
 8004b2a:	fab0 f080 	clz	r0, r0
 8004b2e:	0940      	lsrs	r0, r0, #5
 8004b30:	e7e6      	b.n	8004b00 <USB_SetCurrentMode+0x3c>
 8004b32:	bf00      	nop

08004b34 <USB_DevInit>:
{
 8004b34:	b084      	sub	sp, #16
 8004b36:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8004b3a:	b083      	sub	sp, #12
 8004b3c:	ac0b      	add	r4, sp, #44	; 0x2c
 8004b3e:	9d15      	ldr	r5, [sp, #84]	; 0x54
 8004b40:	e884 000e 	stmia.w	r4, {r1, r2, r3}
    USBx->DIEPTXF[i] = 0U;
 8004b44:	2300      	movs	r3, #0
 8004b46:	f8c0 3104 	str.w	r3, [r0, #260]	; 0x104
 8004b4a:	460c      	mov	r4, r1
 8004b4c:	f8c0 3108 	str.w	r3, [r0, #264]	; 0x108
 8004b50:	f8c0 310c 	str.w	r3, [r0, #268]	; 0x10c
 8004b54:	f8c0 3110 	str.w	r3, [r0, #272]	; 0x110
 8004b58:	f8c0 3114 	str.w	r3, [r0, #276]	; 0x114
 8004b5c:	f8c0 3118 	str.w	r3, [r0, #280]	; 0x118
 8004b60:	f8c0 311c 	str.w	r3, [r0, #284]	; 0x11c
 8004b64:	f8c0 3120 	str.w	r3, [r0, #288]	; 0x120
 8004b68:	f8c0 3124 	str.w	r3, [r0, #292]	; 0x124
 8004b6c:	f8c0 3128 	str.w	r3, [r0, #296]	; 0x128
 8004b70:	f8c0 312c 	str.w	r3, [r0, #300]	; 0x12c
 8004b74:	f8c0 3130 	str.w	r3, [r0, #304]	; 0x130
 8004b78:	f8c0 3134 	str.w	r3, [r0, #308]	; 0x134
 8004b7c:	f8c0 3138 	str.w	r3, [r0, #312]	; 0x138
 8004b80:	f8c0 313c 	str.w	r3, [r0, #316]	; 0x13c
  if (cfg.vbus_sensing_enable == 0U)
 8004b84:	2d00      	cmp	r5, #0
 8004b86:	f040 80ae 	bne.w	8004ce6 <USB_DevInit+0x1b2>
    USBx_DEVICE->DCTL |= USB_OTG_DCTL_SDIS;
 8004b8a:	f8d0 3804 	ldr.w	r3, [r0, #2052]	; 0x804
 8004b8e:	f500 6c00 	add.w	ip, r0, #2048	; 0x800
 8004b92:	f043 0302 	orr.w	r3, r3, #2
 8004b96:	f8cc 3004 	str.w	r3, [ip, #4]
    USBx->GCCFG |= USB_OTG_GCCFG_NOVBUSSENS;
 8004b9a:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8004b9c:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8004ba0:	6383      	str	r3, [r0, #56]	; 0x38
    USBx->GCCFG &= ~USB_OTG_GCCFG_VBUSBSEN;
 8004ba2:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8004ba4:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
 8004ba8:	6383      	str	r3, [r0, #56]	; 0x38
    USBx->GCCFG &= ~USB_OTG_GCCFG_VBUSASEN;
 8004baa:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8004bac:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8004bb0:	6383      	str	r3, [r0, #56]	; 0x38
  USBx_PCGCCTL = 0U;
 8004bb2:	2300      	movs	r3, #0
 8004bb4:	f8c0 3e00 	str.w	r3, [r0, #3584]	; 0xe00
  USBx_DEVICE->DCFG |= DCFG_FRAME_INTERVAL_80;
 8004bb8:	f8dc 3000 	ldr.w	r3, [ip]
 8004bbc:	f8cc 3000 	str.w	r3, [ip]
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
 8004bc0:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8004bc2:	2b01      	cmp	r3, #1
 8004bc4:	f000 80be 	beq.w	8004d44 <USB_DevInit+0x210>
  USBx_DEVICE->DCFG |= speed;
 8004bc8:	f8dc 3000 	ldr.w	r3, [ip]
 8004bcc:	f043 0303 	orr.w	r3, r3, #3
 8004bd0:	f8cc 3000 	str.w	r3, [ip]
  __IO uint32_t count = 0U;
 8004bd4:	2300      	movs	r3, #0
    if (count > 200000U)
 8004bd6:	4a62      	ldr	r2, [pc, #392]	; (8004d60 <USB_DevInit+0x22c>)
  __IO uint32_t count = 0U;
 8004bd8:	9300      	str	r3, [sp, #0]
 8004bda:	e003      	b.n	8004be4 <USB_DevInit+0xb0>
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 8004bdc:	6903      	ldr	r3, [r0, #16]
 8004bde:	2b00      	cmp	r3, #0
 8004be0:	f2c0 809d 	blt.w	8004d1e <USB_DevInit+0x1ea>
    count++;
 8004be4:	9b00      	ldr	r3, [sp, #0]
 8004be6:	3301      	adds	r3, #1
 8004be8:	9300      	str	r3, [sp, #0]
    if (count > 200000U)
 8004bea:	9b00      	ldr	r3, [sp, #0]
 8004bec:	4293      	cmp	r3, r2
 8004bee:	d9f5      	bls.n	8004bdc <USB_DevInit+0xa8>
    ret = HAL_ERROR;
 8004bf0:	2101      	movs	r1, #1
  __IO uint32_t count = 0U;
 8004bf2:	2300      	movs	r3, #0
    if (count > 200000U)
 8004bf4:	4a5a      	ldr	r2, [pc, #360]	; (8004d60 <USB_DevInit+0x22c>)
  __IO uint32_t count = 0U;
 8004bf6:	9301      	str	r3, [sp, #4]
 8004bf8:	e002      	b.n	8004c00 <USB_DevInit+0xcc>
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 8004bfa:	6903      	ldr	r3, [r0, #16]
 8004bfc:	2b00      	cmp	r3, #0
 8004bfe:	db7d      	blt.n	8004cfc <USB_DevInit+0x1c8>
    count++;
 8004c00:	9b01      	ldr	r3, [sp, #4]
 8004c02:	3301      	adds	r3, #1
 8004c04:	9301      	str	r3, [sp, #4]
    if (count > 200000U)
 8004c06:	9b01      	ldr	r3, [sp, #4]
 8004c08:	4293      	cmp	r3, r2
 8004c0a:	d9f6      	bls.n	8004bfa <USB_DevInit+0xc6>
    ret = HAL_ERROR;
 8004c0c:	2101      	movs	r1, #1
  USBx_DEVICE->DIEPMSK = 0U;
 8004c0e:	2200      	movs	r2, #0
 8004c10:	f8cc 2010 	str.w	r2, [ip, #16]
  USBx_DEVICE->DOEPMSK = 0U;
 8004c14:	f8cc 2014 	str.w	r2, [ip, #20]
  USBx_DEVICE->DAINTMSK = 0U;
 8004c18:	f8cc 201c 	str.w	r2, [ip, #28]
  for (i = 0U; i < cfg.dev_endpoints; i++)
 8004c1c:	b1e4      	cbz	r4, 8004c58 <USB_DevInit+0x124>
 8004c1e:	f500 6310 	add.w	r3, r0, #2304	; 0x900
      USBx_INEP(i)->DIEPCTL = 0U;
 8004c22:	4617      	mov	r7, r2
        USBx_INEP(i)->DIEPCTL = USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_SNAK;
 8004c24:	f04f 4890 	mov.w	r8, #1207959552	; 0x48000000
        USBx_INEP(i)->DIEPCTL = USB_OTG_DIEPCTL_SNAK;
 8004c28:	f04f 6900 	mov.w	r9, #134217728	; 0x8000000
    USBx_INEP(i)->DIEPINT  = 0xFB7FU;
 8004c2c:	f64f 3e7f 	movw	lr, #64383	; 0xfb7f
 8004c30:	e008      	b.n	8004c44 <USB_DevInit+0x110>
      USBx_INEP(i)->DIEPCTL = 0U;
 8004c32:	601f      	str	r7, [r3, #0]
  for (i = 0U; i < cfg.dev_endpoints; i++)
 8004c34:	3201      	adds	r2, #1
 8004c36:	4294      	cmp	r4, r2
    USBx_INEP(i)->DIEPTSIZ = 0U;
 8004c38:	611f      	str	r7, [r3, #16]
    USBx_INEP(i)->DIEPINT  = 0xFB7FU;
 8004c3a:	f8c3 e008 	str.w	lr, [r3, #8]
  for (i = 0U; i < cfg.dev_endpoints; i++)
 8004c3e:	f103 0320 	add.w	r3, r3, #32
 8004c42:	d032      	beq.n	8004caa <USB_DevInit+0x176>
    if ((USBx_INEP(i)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
 8004c44:	681e      	ldr	r6, [r3, #0]
 8004c46:	2e00      	cmp	r6, #0
 8004c48:	daf3      	bge.n	8004c32 <USB_DevInit+0xfe>
      if (i == 0U)
 8004c4a:	b112      	cbz	r2, 8004c52 <USB_DevInit+0x11e>
        USBx_INEP(i)->DIEPCTL = USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_SNAK;
 8004c4c:	f8c3 8000 	str.w	r8, [r3]
 8004c50:	e7f0      	b.n	8004c34 <USB_DevInit+0x100>
        USBx_INEP(i)->DIEPCTL = USB_OTG_DIEPCTL_SNAK;
 8004c52:	f8c3 9000 	str.w	r9, [r3]
 8004c56:	e7ed      	b.n	8004c34 <USB_DevInit+0x100>
  USBx_DEVICE->DIEPMSK &= ~(USB_OTG_DIEPMSK_TXFURM);
 8004c58:	f8dc 3010 	ldr.w	r3, [ip, #16]
 8004c5c:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8004c60:	f8cc 3010 	str.w	r3, [ip, #16]
  USBx->GINTMSK = 0U;
 8004c64:	2200      	movs	r2, #0
  if (cfg.dma_enable == 0U)
 8004c66:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  USBx->GINTMSK = 0U;
 8004c68:	6182      	str	r2, [r0, #24]
  USBx->GINTSTS = 0xBFFFFFFFU;
 8004c6a:	f06f 4280 	mvn.w	r2, #1073741824	; 0x40000000
 8004c6e:	6142      	str	r2, [r0, #20]
  if (cfg.dma_enable == 0U)
 8004c70:	b91b      	cbnz	r3, 8004c7a <USB_DevInit+0x146>
    USBx->GINTMSK |= USB_OTG_GINTMSK_RXFLVLM;
 8004c72:	6983      	ldr	r3, [r0, #24]
 8004c74:	f043 0310 	orr.w	r3, r3, #16
 8004c78:	6183      	str	r3, [r0, #24]
  USBx->GINTMSK |= USB_OTG_GINTMSK_USBSUSPM | USB_OTG_GINTMSK_USBRST |
 8004c7a:	6982      	ldr	r2, [r0, #24]
 8004c7c:	4b39      	ldr	r3, [pc, #228]	; (8004d64 <USB_DevInit+0x230>)
 8004c7e:	4313      	orrs	r3, r2
  if (cfg.Sof_enable != 0U)
 8004c80:	9a11      	ldr	r2, [sp, #68]	; 0x44
  USBx->GINTMSK |= USB_OTG_GINTMSK_USBSUSPM | USB_OTG_GINTMSK_USBRST |
 8004c82:	6183      	str	r3, [r0, #24]
  if (cfg.Sof_enable != 0U)
 8004c84:	b11a      	cbz	r2, 8004c8e <USB_DevInit+0x15a>
    USBx->GINTMSK |= USB_OTG_GINTMSK_SOFM;
 8004c86:	6983      	ldr	r3, [r0, #24]
 8004c88:	f043 0308 	orr.w	r3, r3, #8
 8004c8c:	6183      	str	r3, [r0, #24]
  if (cfg.vbus_sensing_enable == 1U)
 8004c8e:	2d01      	cmp	r5, #1
 8004c90:	d105      	bne.n	8004c9e <USB_DevInit+0x16a>
    USBx->GINTMSK |= (USB_OTG_GINTMSK_SRQIM | USB_OTG_GINTMSK_OTGINT);
 8004c92:	6983      	ldr	r3, [r0, #24]
 8004c94:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 8004c98:	f043 0304 	orr.w	r3, r3, #4
 8004c9c:	6183      	str	r3, [r0, #24]
}
 8004c9e:	4608      	mov	r0, r1
 8004ca0:	b003      	add	sp, #12
 8004ca2:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8004ca6:	b004      	add	sp, #16
 8004ca8:	4770      	bx	lr
  for (i = 0U; i < cfg.dev_endpoints; i++)
 8004caa:	2200      	movs	r2, #0
 8004cac:	f500 6330 	add.w	r3, r0, #2816	; 0xb00
      USBx_OUTEP(i)->DOEPCTL = 0U;
 8004cb0:	4617      	mov	r7, r2
        USBx_OUTEP(i)->DOEPCTL = USB_OTG_DOEPCTL_EPDIS | USB_OTG_DOEPCTL_SNAK;
 8004cb2:	f04f 4890 	mov.w	r8, #1207959552	; 0x48000000
        USBx_OUTEP(i)->DOEPCTL = USB_OTG_DOEPCTL_SNAK;
 8004cb6:	f04f 6900 	mov.w	r9, #134217728	; 0x8000000
    USBx_OUTEP(i)->DOEPINT  = 0xFB7FU;
 8004cba:	f64f 3e7f 	movw	lr, #64383	; 0xfb7f
 8004cbe:	e008      	b.n	8004cd2 <USB_DevInit+0x19e>
      USBx_OUTEP(i)->DOEPCTL = 0U;
 8004cc0:	601f      	str	r7, [r3, #0]
  for (i = 0U; i < cfg.dev_endpoints; i++)
 8004cc2:	3201      	adds	r2, #1
 8004cc4:	4294      	cmp	r4, r2
    USBx_OUTEP(i)->DOEPTSIZ = 0U;
 8004cc6:	611f      	str	r7, [r3, #16]
    USBx_OUTEP(i)->DOEPINT  = 0xFB7FU;
 8004cc8:	f8c3 e008 	str.w	lr, [r3, #8]
  for (i = 0U; i < cfg.dev_endpoints; i++)
 8004ccc:	f103 0320 	add.w	r3, r3, #32
 8004cd0:	d0c2      	beq.n	8004c58 <USB_DevInit+0x124>
    if ((USBx_OUTEP(i)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 8004cd2:	681e      	ldr	r6, [r3, #0]
 8004cd4:	2e00      	cmp	r6, #0
 8004cd6:	daf3      	bge.n	8004cc0 <USB_DevInit+0x18c>
      if (i == 0U)
 8004cd8:	b112      	cbz	r2, 8004ce0 <USB_DevInit+0x1ac>
        USBx_OUTEP(i)->DOEPCTL = USB_OTG_DOEPCTL_EPDIS | USB_OTG_DOEPCTL_SNAK;
 8004cda:	f8c3 8000 	str.w	r8, [r3]
 8004cde:	e7f0      	b.n	8004cc2 <USB_DevInit+0x18e>
        USBx_OUTEP(i)->DOEPCTL = USB_OTG_DOEPCTL_SNAK;
 8004ce0:	f8c3 9000 	str.w	r9, [r3]
 8004ce4:	e7ed      	b.n	8004cc2 <USB_DevInit+0x18e>
    USBx->GCCFG &= ~USB_OTG_GCCFG_NOVBUSSENS;
 8004ce6:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8004ce8:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 8004cec:	6383      	str	r3, [r0, #56]	; 0x38
    USBx->GCCFG |= USB_OTG_GCCFG_VBUSBSEN;
 8004cee:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8004cf0:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
    USBx_DEVICE->DCTL |= USB_OTG_DCTL_SDIS;
 8004cf4:	f500 6c00 	add.w	ip, r0, #2048	; 0x800
    USBx->GCCFG |= USB_OTG_GCCFG_VBUSBSEN;
 8004cf8:	6383      	str	r3, [r0, #56]	; 0x38
 8004cfa:	e75a      	b.n	8004bb2 <USB_DevInit+0x7e>
  count = 0U;
 8004cfc:	2300      	movs	r3, #0
 8004cfe:	9301      	str	r3, [sp, #4]
  USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
 8004d00:	2310      	movs	r3, #16
    if (count > 200000U)
 8004d02:	4a17      	ldr	r2, [pc, #92]	; (8004d60 <USB_DevInit+0x22c>)
  USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
 8004d04:	6103      	str	r3, [r0, #16]
 8004d06:	e003      	b.n	8004d10 <USB_DevInit+0x1dc>
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_RXFFLSH) == USB_OTG_GRSTCTL_RXFFLSH);
 8004d08:	6903      	ldr	r3, [r0, #16]
 8004d0a:	06db      	lsls	r3, r3, #27
 8004d0c:	f57f af7f 	bpl.w	8004c0e <USB_DevInit+0xda>
    count++;
 8004d10:	9b01      	ldr	r3, [sp, #4]
 8004d12:	3301      	adds	r3, #1
 8004d14:	9301      	str	r3, [sp, #4]
    if (count > 200000U)
 8004d16:	9b01      	ldr	r3, [sp, #4]
 8004d18:	4293      	cmp	r3, r2
 8004d1a:	d9f5      	bls.n	8004d08 <USB_DevInit+0x1d4>
 8004d1c:	e776      	b.n	8004c0c <USB_DevInit+0xd8>
  count = 0U;
 8004d1e:	2300      	movs	r3, #0
 8004d20:	9300      	str	r3, [sp, #0]
  USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
 8004d22:	f44f 6384 	mov.w	r3, #1056	; 0x420
    if (count > 200000U)
 8004d26:	4a0e      	ldr	r2, [pc, #56]	; (8004d60 <USB_DevInit+0x22c>)
  USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
 8004d28:	6103      	str	r3, [r0, #16]
 8004d2a:	e004      	b.n	8004d36 <USB_DevInit+0x202>
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
 8004d2c:	6901      	ldr	r1, [r0, #16]
 8004d2e:	f011 0120 	ands.w	r1, r1, #32
 8004d32:	f43f af5e 	beq.w	8004bf2 <USB_DevInit+0xbe>
    count++;
 8004d36:	9b00      	ldr	r3, [sp, #0]
 8004d38:	3301      	adds	r3, #1
 8004d3a:	9300      	str	r3, [sp, #0]
    if (count > 200000U)
 8004d3c:	9b00      	ldr	r3, [sp, #0]
 8004d3e:	4293      	cmp	r3, r2
 8004d40:	d9f4      	bls.n	8004d2c <USB_DevInit+0x1f8>
 8004d42:	e755      	b.n	8004bf0 <USB_DevInit+0xbc>
    if (cfg.speed == USBD_HS_SPEED)
 8004d44:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8004d46:	b923      	cbnz	r3, 8004d52 <USB_DevInit+0x21e>
  USBx_DEVICE->DCFG |= speed;
 8004d48:	f8dc 3000 	ldr.w	r3, [ip]
 8004d4c:	f8cc 3000 	str.w	r3, [ip]
  return HAL_OK;
 8004d50:	e740      	b.n	8004bd4 <USB_DevInit+0xa0>
  USBx_DEVICE->DCFG |= speed;
 8004d52:	f8dc 3000 	ldr.w	r3, [ip]
 8004d56:	f043 0301 	orr.w	r3, r3, #1
 8004d5a:	f8cc 3000 	str.w	r3, [ip]
  return HAL_OK;
 8004d5e:	e739      	b.n	8004bd4 <USB_DevInit+0xa0>
 8004d60:	00030d40 	.word	0x00030d40
 8004d64:	803c3800 	.word	0x803c3800

08004d68 <USB_FlushTxFifo>:
{
 8004d68:	b082      	sub	sp, #8
  __IO uint32_t count = 0U;
 8004d6a:	2300      	movs	r3, #0
    if (count > 200000U)
 8004d6c:	4a12      	ldr	r2, [pc, #72]	; (8004db8 <USB_FlushTxFifo+0x50>)
  __IO uint32_t count = 0U;
 8004d6e:	9301      	str	r3, [sp, #4]
 8004d70:	e002      	b.n	8004d78 <USB_FlushTxFifo+0x10>
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 8004d72:	6903      	ldr	r3, [r0, #16]
 8004d74:	2b00      	cmp	r3, #0
 8004d76:	db08      	blt.n	8004d8a <USB_FlushTxFifo+0x22>
    count++;
 8004d78:	9b01      	ldr	r3, [sp, #4]
 8004d7a:	3301      	adds	r3, #1
 8004d7c:	9301      	str	r3, [sp, #4]
    if (count > 200000U)
 8004d7e:	9b01      	ldr	r3, [sp, #4]
 8004d80:	4293      	cmp	r3, r2
 8004d82:	d9f6      	bls.n	8004d72 <USB_FlushTxFifo+0xa>
      return HAL_TIMEOUT;
 8004d84:	2003      	movs	r0, #3
}
 8004d86:	b002      	add	sp, #8
 8004d88:	4770      	bx	lr
  USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
 8004d8a:	0189      	lsls	r1, r1, #6
  count = 0U;
 8004d8c:	2300      	movs	r3, #0
  USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
 8004d8e:	f041 0120 	orr.w	r1, r1, #32
  count = 0U;
 8004d92:	9301      	str	r3, [sp, #4]
    if (count > 200000U)
 8004d94:	4a08      	ldr	r2, [pc, #32]	; (8004db8 <USB_FlushTxFifo+0x50>)
  USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
 8004d96:	6101      	str	r1, [r0, #16]
 8004d98:	e003      	b.n	8004da2 <USB_FlushTxFifo+0x3a>
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
 8004d9a:	6903      	ldr	r3, [r0, #16]
 8004d9c:	f013 0320 	ands.w	r3, r3, #32
 8004da0:	d006      	beq.n	8004db0 <USB_FlushTxFifo+0x48>
    count++;
 8004da2:	9b01      	ldr	r3, [sp, #4]
 8004da4:	3301      	adds	r3, #1
 8004da6:	9301      	str	r3, [sp, #4]
    if (count > 200000U)
 8004da8:	9b01      	ldr	r3, [sp, #4]
 8004daa:	4293      	cmp	r3, r2
 8004dac:	d9f5      	bls.n	8004d9a <USB_FlushTxFifo+0x32>
 8004dae:	e7e9      	b.n	8004d84 <USB_FlushTxFifo+0x1c>
  return HAL_OK;
 8004db0:	4618      	mov	r0, r3
}
 8004db2:	b002      	add	sp, #8
 8004db4:	4770      	bx	lr
 8004db6:	bf00      	nop
 8004db8:	00030d40 	.word	0x00030d40

08004dbc <USB_FlushRxFifo>:
{
 8004dbc:	b082      	sub	sp, #8
  __IO uint32_t count = 0U;
 8004dbe:	2300      	movs	r3, #0
    if (count > 200000U)
 8004dc0:	4a11      	ldr	r2, [pc, #68]	; (8004e08 <USB_FlushRxFifo+0x4c>)
  __IO uint32_t count = 0U;
 8004dc2:	9301      	str	r3, [sp, #4]
 8004dc4:	e002      	b.n	8004dcc <USB_FlushRxFifo+0x10>
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 8004dc6:	6903      	ldr	r3, [r0, #16]
 8004dc8:	2b00      	cmp	r3, #0
 8004dca:	db08      	blt.n	8004dde <USB_FlushRxFifo+0x22>
    count++;
 8004dcc:	9b01      	ldr	r3, [sp, #4]
 8004dce:	3301      	adds	r3, #1
 8004dd0:	9301      	str	r3, [sp, #4]
    if (count > 200000U)
 8004dd2:	9b01      	ldr	r3, [sp, #4]
 8004dd4:	4293      	cmp	r3, r2
 8004dd6:	d9f6      	bls.n	8004dc6 <USB_FlushRxFifo+0xa>
      return HAL_TIMEOUT;
 8004dd8:	2003      	movs	r0, #3
}
 8004dda:	b002      	add	sp, #8
 8004ddc:	4770      	bx	lr
  count = 0U;
 8004dde:	2100      	movs	r1, #0
  USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
 8004de0:	2310      	movs	r3, #16
  count = 0U;
 8004de2:	9101      	str	r1, [sp, #4]
    if (count > 200000U)
 8004de4:	4a08      	ldr	r2, [pc, #32]	; (8004e08 <USB_FlushRxFifo+0x4c>)
  USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
 8004de6:	6103      	str	r3, [r0, #16]
 8004de8:	e003      	b.n	8004df2 <USB_FlushRxFifo+0x36>
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_RXFFLSH) == USB_OTG_GRSTCTL_RXFFLSH);
 8004dea:	6903      	ldr	r3, [r0, #16]
 8004dec:	f013 0310 	ands.w	r3, r3, #16
 8004df0:	d006      	beq.n	8004e00 <USB_FlushRxFifo+0x44>
    count++;
 8004df2:	9b01      	ldr	r3, [sp, #4]
 8004df4:	3301      	adds	r3, #1
 8004df6:	9301      	str	r3, [sp, #4]
    if (count > 200000U)
 8004df8:	9b01      	ldr	r3, [sp, #4]
 8004dfa:	4293      	cmp	r3, r2
 8004dfc:	d9f5      	bls.n	8004dea <USB_FlushRxFifo+0x2e>
 8004dfe:	e7eb      	b.n	8004dd8 <USB_FlushRxFifo+0x1c>
  return HAL_OK;
 8004e00:	4618      	mov	r0, r3
}
 8004e02:	b002      	add	sp, #8
 8004e04:	4770      	bx	lr
 8004e06:	bf00      	nop
 8004e08:	00030d40 	.word	0x00030d40

08004e0c <USB_GetDevSpeed>:
  uint32_t DevEnumSpeed = USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD;
 8004e0c:	f8d0 3808 	ldr.w	r3, [r0, #2056]	; 0x808
  if (DevEnumSpeed == DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ)
 8004e10:	f013 0006 	ands.w	r0, r3, #6
 8004e14:	d004      	beq.n	8004e20 <USB_GetDevSpeed+0x14>
    speed = 0xFU;
 8004e16:	f013 0f02 	tst.w	r3, #2
 8004e1a:	bf14      	ite	ne
 8004e1c:	2002      	movne	r0, #2
 8004e1e:	200f      	moveq	r0, #15
}
 8004e20:	4770      	bx	lr
 8004e22:	bf00      	nop

08004e24 <USB_ActivateEndpoint>:
{
 8004e24:	b430      	push	{r4, r5}
  if (ep->is_in == 1U)
 8004e26:	784b      	ldrb	r3, [r1, #1]
  uint32_t epnum = (uint32_t)ep->num;
 8004e28:	780a      	ldrb	r2, [r1, #0]
  if (ep->is_in == 1U)
 8004e2a:	2b01      	cmp	r3, #1
 8004e2c:	d022      	beq.n	8004e74 <USB_ActivateEndpoint+0x50>
    USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16);
 8004e2e:	f8d0 481c 	ldr.w	r4, [r0, #2076]	; 0x81c
 8004e32:	f002 0c0f 	and.w	ip, r2, #15
 8004e36:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8004e3a:	fa03 f30c 	lsl.w	r3, r3, ip
 8004e3e:	4323      	orrs	r3, r4
    if (((USBx_OUTEP(epnum)->DOEPCTL) & USB_OTG_DOEPCTL_USBAEP) == 0U)
 8004e40:	eb00 1242 	add.w	r2, r0, r2, lsl #5
    USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16);
 8004e44:	f8c0 381c 	str.w	r3, [r0, #2076]	; 0x81c
    if (((USBx_OUTEP(epnum)->DOEPCTL) & USB_OTG_DOEPCTL_USBAEP) == 0U)
 8004e48:	f8d2 3b00 	ldr.w	r3, [r2, #2816]	; 0xb00
 8004e4c:	041b      	lsls	r3, r3, #16
 8004e4e:	d40e      	bmi.n	8004e6e <USB_ActivateEndpoint+0x4a>
      USBx_OUTEP(epnum)->DOEPCTL |= (ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ) |
 8004e50:	68cb      	ldr	r3, [r1, #12]
 8004e52:	f8d2 0b00 	ldr.w	r0, [r2, #2816]	; 0xb00
                                    ((uint32_t)ep->type << 18) |
 8004e56:	7909      	ldrb	r1, [r1, #4]
      USBx_OUTEP(epnum)->DOEPCTL |= (ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ) |
 8004e58:	f3c3 030a 	ubfx	r3, r3, #0, #11
 8004e5c:	4303      	orrs	r3, r0
 8004e5e:	ea43 4381 	orr.w	r3, r3, r1, lsl #18
 8004e62:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8004e66:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8004e6a:	f8c2 3b00 	str.w	r3, [r2, #2816]	; 0xb00
}
 8004e6e:	2000      	movs	r0, #0
 8004e70:	bc30      	pop	{r4, r5}
 8004e72:	4770      	bx	lr
    USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK));
 8004e74:	f8d0 581c 	ldr.w	r5, [r0, #2076]	; 0x81c
 8004e78:	f002 0c0f 	and.w	ip, r2, #15
 8004e7c:	fa03 f30c 	lsl.w	r3, r3, ip
 8004e80:	f500 6400 	add.w	r4, r0, #2048	; 0x800
 8004e84:	432b      	orrs	r3, r5
    if ((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_USBAEP) == 0U)
 8004e86:	eb00 1042 	add.w	r0, r0, r2, lsl #5
    USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK));
 8004e8a:	61e3      	str	r3, [r4, #28]
    if ((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_USBAEP) == 0U)
 8004e8c:	f8d0 3900 	ldr.w	r3, [r0, #2304]	; 0x900
 8004e90:	041c      	lsls	r4, r3, #16
 8004e92:	d4ec      	bmi.n	8004e6e <USB_ActivateEndpoint+0x4a>
      USBx_INEP(epnum)->DIEPCTL |= (ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ) |
 8004e94:	68cb      	ldr	r3, [r1, #12]
 8004e96:	f8d0 4900 	ldr.w	r4, [r0, #2304]	; 0x900
                                   ((uint32_t)ep->type << 18) | (epnum << 22) |
 8004e9a:	7909      	ldrb	r1, [r1, #4]
      USBx_INEP(epnum)->DIEPCTL |= (ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ) |
 8004e9c:	f3c3 030a 	ubfx	r3, r3, #0, #11
 8004ea0:	4323      	orrs	r3, r4
 8004ea2:	ea43 4381 	orr.w	r3, r3, r1, lsl #18
 8004ea6:	ea43 5282 	orr.w	r2, r3, r2, lsl #22
 8004eaa:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8004eae:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8004eb2:	f8c0 2900 	str.w	r2, [r0, #2304]	; 0x900
}
 8004eb6:	bc30      	pop	{r4, r5}
 8004eb8:	2000      	movs	r0, #0
 8004eba:	4770      	bx	lr

08004ebc <USB_DeactivateEndpoint>:
{
 8004ebc:	b410      	push	{r4}
  if (ep->is_in == 1U)
 8004ebe:	784a      	ldrb	r2, [r1, #1]
  uint32_t epnum = (uint32_t)ep->num;
 8004ec0:	780b      	ldrb	r3, [r1, #0]
  if (ep->is_in == 1U)
 8004ec2:	2a01      	cmp	r2, #1
    if ((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
 8004ec4:	eb00 1243 	add.w	r2, r0, r3, lsl #5
  if (ep->is_in == 1U)
 8004ec8:	d02c      	beq.n	8004f24 <USB_DeactivateEndpoint+0x68>
    if ((USBx_OUTEP(epnum)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 8004eca:	f8d2 1b00 	ldr.w	r1, [r2, #2816]	; 0xb00
 8004ece:	2900      	cmp	r1, #0
 8004ed0:	db1b      	blt.n	8004f0a <USB_DeactivateEndpoint+0x4e>
    USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16));
 8004ed2:	f8d0 483c 	ldr.w	r4, [r0, #2108]	; 0x83c
 8004ed6:	f44f 3180 	mov.w	r1, #65536	; 0x10000
 8004eda:	f003 030f 	and.w	r3, r3, #15
 8004ede:	fa01 f303 	lsl.w	r3, r1, r3
 8004ee2:	ea24 0403 	bic.w	r4, r4, r3
 8004ee6:	f8c0 483c 	str.w	r4, [r0, #2108]	; 0x83c
    USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16));
 8004eea:	f8d0 481c 	ldr.w	r4, [r0, #2076]	; 0x81c
    USBx_OUTEP(epnum)->DOEPCTL &= ~(USB_OTG_DOEPCTL_USBAEP |
 8004eee:	4922      	ldr	r1, [pc, #136]	; (8004f78 <USB_DeactivateEndpoint+0xbc>)
    USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16));
 8004ef0:	ea24 0303 	bic.w	r3, r4, r3
 8004ef4:	f8c0 381c 	str.w	r3, [r0, #2076]	; 0x81c
    USBx_OUTEP(epnum)->DOEPCTL &= ~(USB_OTG_DOEPCTL_USBAEP |
 8004ef8:	f8d2 3b00 	ldr.w	r3, [r2, #2816]	; 0xb00
}
 8004efc:	f85d 4b04 	ldr.w	r4, [sp], #4
    USBx_OUTEP(epnum)->DOEPCTL &= ~(USB_OTG_DOEPCTL_USBAEP |
 8004f00:	4019      	ands	r1, r3
}
 8004f02:	2000      	movs	r0, #0
    USBx_OUTEP(epnum)->DOEPCTL &= ~(USB_OTG_DOEPCTL_USBAEP |
 8004f04:	f8c2 1b00 	str.w	r1, [r2, #2816]	; 0xb00
}
 8004f08:	4770      	bx	lr
      USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SNAK;
 8004f0a:	f8d2 1b00 	ldr.w	r1, [r2, #2816]	; 0xb00
 8004f0e:	f041 6100 	orr.w	r1, r1, #134217728	; 0x8000000
 8004f12:	f8c2 1b00 	str.w	r1, [r2, #2816]	; 0xb00
      USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_EPDIS;
 8004f16:	f8d2 1b00 	ldr.w	r1, [r2, #2816]	; 0xb00
 8004f1a:	f041 4180 	orr.w	r1, r1, #1073741824	; 0x40000000
 8004f1e:	f8c2 1b00 	str.w	r1, [r2, #2816]	; 0xb00
 8004f22:	e7d6      	b.n	8004ed2 <USB_DeactivateEndpoint+0x16>
    if ((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
 8004f24:	f8d2 1900 	ldr.w	r1, [r2, #2304]	; 0x900
 8004f28:	2900      	cmp	r1, #0
 8004f2a:	da0b      	bge.n	8004f44 <USB_DeactivateEndpoint+0x88>
      USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SNAK;
 8004f2c:	f8d2 1900 	ldr.w	r1, [r2, #2304]	; 0x900
 8004f30:	f041 6100 	orr.w	r1, r1, #134217728	; 0x8000000
 8004f34:	f8c2 1900 	str.w	r1, [r2, #2304]	; 0x900
      USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_EPDIS;
 8004f38:	f8d2 1900 	ldr.w	r1, [r2, #2304]	; 0x900
 8004f3c:	f041 4180 	orr.w	r1, r1, #1073741824	; 0x40000000
 8004f40:	f8c2 1900 	str.w	r1, [r2, #2304]	; 0x900
    USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK)));
 8004f44:	f8d0 183c 	ldr.w	r1, [r0, #2108]	; 0x83c
 8004f48:	f003 040f 	and.w	r4, r3, #15
 8004f4c:	2301      	movs	r3, #1
 8004f4e:	40a3      	lsls	r3, r4
 8004f50:	ea21 0103 	bic.w	r1, r1, r3
 8004f54:	f8c0 183c 	str.w	r1, [r0, #2108]	; 0x83c
    USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK)));
 8004f58:	f8d0 481c 	ldr.w	r4, [r0, #2076]	; 0x81c
    USBx_INEP(epnum)->DIEPCTL &= ~(USB_OTG_DIEPCTL_USBAEP |
 8004f5c:	4907      	ldr	r1, [pc, #28]	; (8004f7c <USB_DeactivateEndpoint+0xc0>)
    USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK)));
 8004f5e:	ea24 0303 	bic.w	r3, r4, r3
 8004f62:	f8c0 381c 	str.w	r3, [r0, #2076]	; 0x81c
    USBx_INEP(epnum)->DIEPCTL &= ~(USB_OTG_DIEPCTL_USBAEP |
 8004f66:	f8d2 3900 	ldr.w	r3, [r2, #2304]	; 0x900
}
 8004f6a:	f85d 4b04 	ldr.w	r4, [sp], #4
    USBx_INEP(epnum)->DIEPCTL &= ~(USB_OTG_DIEPCTL_USBAEP |
 8004f6e:	4019      	ands	r1, r3
}
 8004f70:	2000      	movs	r0, #0
    USBx_INEP(epnum)->DIEPCTL &= ~(USB_OTG_DIEPCTL_USBAEP |
 8004f72:	f8c2 1900 	str.w	r1, [r2, #2304]	; 0x900
}
 8004f76:	4770      	bx	lr
 8004f78:	eff37800 	.word	0xeff37800
 8004f7c:	ec337800 	.word	0xec337800

08004f80 <USB_EPStartXfer>:
{
 8004f80:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if (ep->is_in == 1U)
 8004f84:	784c      	ldrb	r4, [r1, #1]
  uint32_t epnum = (uint32_t)ep->num;
 8004f86:	f891 c000 	ldrb.w	ip, [r1]
  if (ep->is_in == 1U)
 8004f8a:	2c01      	cmp	r4, #1
 8004f8c:	d04f      	beq.n	800502e <USB_EPStartXfer+0xae>
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ);
 8004f8e:	eb00 1c4c 	add.w	ip, r0, ip, lsl #5
 8004f92:	f50c 6330 	add.w	r3, ip, #2816	; 0xb00
 8004f96:	691c      	ldr	r4, [r3, #16]
 8004f98:	0ce4      	lsrs	r4, r4, #19
 8004f9a:	04e4      	lsls	r4, r4, #19
 8004f9c:	611c      	str	r4, [r3, #16]
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT);
 8004f9e:	691c      	ldr	r4, [r3, #16]
 8004fa0:	f024 54ff 	bic.w	r4, r4, #534773760	; 0x1fe00000
 8004fa4:	f424 14c0 	bic.w	r4, r4, #1572864	; 0x180000
 8004fa8:	611c      	str	r4, [r3, #16]
    if (ep->xfer_len == 0U)
 8004faa:	698c      	ldr	r4, [r1, #24]
 8004fac:	b374      	cbz	r4, 800500c <USB_EPStartXfer+0x8c>
      pktcnt = (uint16_t)((ep->xfer_len + ep->maxpacket - 1U) / ep->maxpacket);
 8004fae:	68cd      	ldr	r5, [r1, #12]
      USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_PKTCNT & ((uint32_t)pktcnt << 19);
 8004fb0:	4e78      	ldr	r6, [pc, #480]	; (8005194 <USB_EPStartXfer+0x214>)
      pktcnt = (uint16_t)((ep->xfer_len + ep->maxpacket - 1U) / ep->maxpacket);
 8004fb2:	442c      	add	r4, r5
 8004fb4:	3c01      	subs	r4, #1
 8004fb6:	fbb4 f4f5 	udiv	r4, r4, r5
 8004fba:	b2a4      	uxth	r4, r4
      ep->xfer_size = ep->maxpacket * pktcnt;
 8004fbc:	fb04 f505 	mul.w	r5, r4, r5
      USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_PKTCNT & ((uint32_t)pktcnt << 19);
 8004fc0:	ea06 44c4 	and.w	r4, r6, r4, lsl #19
 8004fc4:	691e      	ldr	r6, [r3, #16]
      ep->xfer_size = ep->maxpacket * pktcnt;
 8004fc6:	61cd      	str	r5, [r1, #28]
      USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_PKTCNT & ((uint32_t)pktcnt << 19);
 8004fc8:	4334      	orrs	r4, r6
 8004fca:	611c      	str	r4, [r3, #16]
      USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_XFRSIZ & ep->xfer_size;
 8004fcc:	691c      	ldr	r4, [r3, #16]
 8004fce:	f3c5 0512 	ubfx	r5, r5, #0, #19
 8004fd2:	4325      	orrs	r5, r4
    if (dma == 1U)
 8004fd4:	2a01      	cmp	r2, #1
      USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_XFRSIZ & ep->xfer_size;
 8004fd6:	611d      	str	r5, [r3, #16]
    if (dma == 1U)
 8004fd8:	d024      	beq.n	8005024 <USB_EPStartXfer+0xa4>
    if (ep->type == EP_TYPE_ISOC)
 8004fda:	790b      	ldrb	r3, [r1, #4]
 8004fdc:	2b01      	cmp	r3, #1
 8004fde:	d10c      	bne.n	8004ffa <USB_EPStartXfer+0x7a>
      if ((USBx_DEVICE->DSTS & (1U << 8)) == 0U)
 8004fe0:	f8d0 3808 	ldr.w	r3, [r0, #2056]	; 0x808
 8004fe4:	f413 7f80 	tst.w	r3, #256	; 0x100
        USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SODDFRM;
 8004fe8:	f8dc 3b00 	ldr.w	r3, [ip, #2816]	; 0xb00
 8004fec:	bf0c      	ite	eq
 8004fee:	f043 5300 	orreq.w	r3, r3, #536870912	; 0x20000000
        USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM;
 8004ff2:	f043 5380 	orrne.w	r3, r3, #268435456	; 0x10000000
 8004ff6:	f8cc 3b00 	str.w	r3, [ip, #2816]	; 0xb00
    USBx_OUTEP(epnum)->DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);
 8004ffa:	f8dc 3b00 	ldr.w	r3, [ip, #2816]	; 0xb00
 8004ffe:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
 8005002:	f8cc 3b00 	str.w	r3, [ip, #2816]	; 0xb00
}
 8005006:	2000      	movs	r0, #0
 8005008:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & ep->maxpacket);
 800500c:	68cc      	ldr	r4, [r1, #12]
 800500e:	691d      	ldr	r5, [r3, #16]
 8005010:	f3c4 0412 	ubfx	r4, r4, #0, #19
 8005014:	432c      	orrs	r4, r5
 8005016:	611c      	str	r4, [r3, #16]
      USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));
 8005018:	691c      	ldr	r4, [r3, #16]
    if (dma == 1U)
 800501a:	2a01      	cmp	r2, #1
      USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));
 800501c:	f444 2400 	orr.w	r4, r4, #524288	; 0x80000
 8005020:	611c      	str	r4, [r3, #16]
    if (dma == 1U)
 8005022:	d1da      	bne.n	8004fda <USB_EPStartXfer+0x5a>
      if ((uint32_t)ep->xfer_buff != 0U)
 8005024:	690a      	ldr	r2, [r1, #16]
 8005026:	2a00      	cmp	r2, #0
 8005028:	d0d7      	beq.n	8004fda <USB_EPStartXfer+0x5a>
        USBx_OUTEP(epnum)->DOEPDMA = (uint32_t)(ep->xfer_buff);
 800502a:	615a      	str	r2, [r3, #20]
 800502c:	e7d5      	b.n	8004fda <USB_EPStartXfer+0x5a>
    if (ep->xfer_len == 0U)
 800502e:	698e      	ldr	r6, [r1, #24]
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 8005030:	eb00 154c 	add.w	r5, r0, ip, lsl #5
    if (ep->xfer_len == 0U)
 8005034:	b3de      	cbz	r6, 80050ae <USB_EPStartXfer+0x12e>
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 8005036:	f8d5 3910 	ldr.w	r3, [r5, #2320]	; 0x910
                                     (((ep->xfer_len + ep->maxpacket - 1U) / ep->maxpacket) << 19));
 800503a:	68cf      	ldr	r7, [r1, #12]
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 800503c:	0cdb      	lsrs	r3, r3, #19
 800503e:	04db      	lsls	r3, r3, #19
 8005040:	f8c5 3910 	str.w	r3, [r5, #2320]	; 0x910
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 8005044:	f8d5 3910 	ldr.w	r3, [r5, #2320]	; 0x910
 8005048:	f023 53ff 	bic.w	r3, r3, #534773760	; 0x1fe00000
 800504c:	f423 13c0 	bic.w	r3, r3, #1572864	; 0x180000
 8005050:	f8c5 3910 	str.w	r3, [r5, #2320]	; 0x910
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT &
 8005054:	4b4f      	ldr	r3, [pc, #316]	; (8005194 <USB_EPStartXfer+0x214>)
 8005056:	f8d5 8910 	ldr.w	r8, [r5, #2320]	; 0x910
                                     (((ep->xfer_len + ep->maxpacket - 1U) / ep->maxpacket) << 19));
 800505a:	eb06 0e07 	add.w	lr, r6, r7
 800505e:	f10e 3eff 	add.w	lr, lr, #4294967295	; 0xffffffff
 8005062:	fbbe fef7 	udiv	lr, lr, r7
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT &
 8005066:	ea03 43ce 	and.w	r3, r3, lr, lsl #19
 800506a:	ea43 0308 	orr.w	r3, r3, r8
 800506e:	f8c5 3910 	str.w	r3, [r5, #2320]	; 0x910
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len);
 8005072:	f8d5 7910 	ldr.w	r7, [r5, #2320]	; 0x910
 8005076:	f3c6 0312 	ubfx	r3, r6, #0, #19
 800507a:	433b      	orrs	r3, r7
 800507c:	f8c5 3910 	str.w	r3, [r5, #2320]	; 0x910
      if (ep->type == EP_TYPE_ISOC)
 8005080:	790f      	ldrb	r7, [r1, #4]
 8005082:	2f01      	cmp	r7, #1
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 8005084:	f505 6310 	add.w	r3, r5, #2304	; 0x900
      if (ep->type == EP_TYPE_ISOC)
 8005088:	d053      	beq.n	8005132 <USB_EPStartXfer+0x1b2>
    if (dma == 1U)
 800508a:	2a01      	cmp	r2, #1
 800508c:	d06d      	beq.n	800516a <USB_EPStartXfer+0x1ea>
      USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 800508e:	f8d5 3900 	ldr.w	r3, [r5, #2304]	; 0x900
 8005092:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
 8005096:	f8c5 3900 	str.w	r3, [r5, #2304]	; 0x900
          USBx_DEVICE->DIEPEMPMSK |= 1UL << (ep->num & EP_ADDR_MSK);
 800509a:	f8d0 3834 	ldr.w	r3, [r0, #2100]	; 0x834
 800509e:	f00c 0c0f 	and.w	ip, ip, #15
 80050a2:	fa04 f40c 	lsl.w	r4, r4, ip
 80050a6:	431c      	orrs	r4, r3
 80050a8:	f8c0 4834 	str.w	r4, [r0, #2100]	; 0x834
  return HAL_OK;
 80050ac:	e7ab      	b.n	8005006 <USB_EPStartXfer+0x86>
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 80050ae:	f8d5 4910 	ldr.w	r4, [r5, #2320]	; 0x910
 80050b2:	f024 54ff 	bic.w	r4, r4, #534773760	; 0x1fe00000
 80050b6:	f424 14c0 	bic.w	r4, r4, #1572864	; 0x180000
 80050ba:	f8c5 4910 	str.w	r4, [r5, #2320]	; 0x910
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19));
 80050be:	f8d5 4910 	ldr.w	r4, [r5, #2320]	; 0x910
 80050c2:	f444 2400 	orr.w	r4, r4, #524288	; 0x80000
 80050c6:	f8c5 4910 	str.w	r4, [r5, #2320]	; 0x910
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 80050ca:	f8d5 4910 	ldr.w	r4, [r5, #2320]	; 0x910
 80050ce:	0ce4      	lsrs	r4, r4, #19
 80050d0:	04e4      	lsls	r4, r4, #19
 80050d2:	f8c5 4910 	str.w	r4, [r5, #2320]	; 0x910
    if (dma == 1U)
 80050d6:	2a01      	cmp	r2, #1
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 80050d8:	f505 6310 	add.w	r3, r5, #2304	; 0x900
      if (ep->type == EP_TYPE_ISOC)
 80050dc:	790f      	ldrb	r7, [r1, #4]
    if (dma == 1U)
 80050de:	d039      	beq.n	8005154 <USB_EPStartXfer+0x1d4>
      USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 80050e0:	f8d5 4900 	ldr.w	r4, [r5, #2304]	; 0x900
      if (ep->type != EP_TYPE_ISOC)
 80050e4:	2f01      	cmp	r7, #1
      USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 80050e6:	f044 4404 	orr.w	r4, r4, #2214592512	; 0x84000000
 80050ea:	f8c5 4900 	str.w	r4, [r5, #2304]	; 0x900
      if (ep->type != EP_TYPE_ISOC)
 80050ee:	d18a      	bne.n	8005006 <USB_EPStartXfer+0x86>
        if ((USBx_DEVICE->DSTS & (1U << 8)) == 0U)
 80050f0:	f8d0 4808 	ldr.w	r4, [r0, #2056]	; 0x808
 80050f4:	f414 7f80 	tst.w	r4, #256	; 0x100
          USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SODDFRM;
 80050f8:	681c      	ldr	r4, [r3, #0]
 80050fa:	bf0c      	ite	eq
 80050fc:	f044 5400 	orreq.w	r4, r4, #536870912	; 0x20000000
          USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM;
 8005100:	f044 5480 	orrne.w	r4, r4, #268435456	; 0x10000000
 8005104:	601c      	str	r4, [r3, #0]
  if (dma == 0U)
 8005106:	2a00      	cmp	r2, #0
 8005108:	f47f af7d 	bne.w	8005006 <USB_EPStartXfer+0x86>
    count32b = ((uint32_t)len + 3U) / 4U;
 800510c:	b2b6      	uxth	r6, r6
 800510e:	3603      	adds	r6, #3
    for (i = 0U; i < count32b; i++)
 8005110:	08b6      	lsrs	r6, r6, #2
 8005112:	f43f af78 	beq.w	8005006 <USB_EPStartXfer+0x86>
        (void)USB_WritePacket(USBx, ep->xfer_buff, ep->num, (uint16_t)ep->xfer_len, dma);
 8005116:	690b      	ldr	r3, [r1, #16]
      USBx_DFIFO((uint32_t)ch_ep_num) = __UNALIGNED_UINT32_READ(pSrc);
 8005118:	eb00 3c0c 	add.w	ip, r0, ip, lsl #12
 800511c:	f50c 5c80 	add.w	ip, ip, #4096	; 0x1000
 8005120:	eb03 0186 	add.w	r1, r3, r6, lsl #2
 8005124:	f853 2b04 	ldr.w	r2, [r3], #4
 8005128:	f8cc 2000 	str.w	r2, [ip]
    for (i = 0U; i < count32b; i++)
 800512c:	428b      	cmp	r3, r1
 800512e:	d1f9      	bne.n	8005124 <USB_EPStartXfer+0x1a4>
 8005130:	e769      	b.n	8005006 <USB_EPStartXfer+0x86>
        USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_MULCNT);
 8005132:	691c      	ldr	r4, [r3, #16]
 8005134:	f024 44c0 	bic.w	r4, r4, #1610612736	; 0x60000000
 8005138:	611c      	str	r4, [r3, #16]
        USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_MULCNT & (1U << 29));
 800513a:	691c      	ldr	r4, [r3, #16]
    if (dma == 1U)
 800513c:	2a01      	cmp	r2, #1
        USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_MULCNT & (1U << 29));
 800513e:	f044 5400 	orr.w	r4, r4, #536870912	; 0x20000000
 8005142:	611c      	str	r4, [r3, #16]
    if (dma == 1U)
 8005144:	d016      	beq.n	8005174 <USB_EPStartXfer+0x1f4>
      USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 8005146:	f8d5 4900 	ldr.w	r4, [r5, #2304]	; 0x900
 800514a:	f044 4404 	orr.w	r4, r4, #2214592512	; 0x84000000
 800514e:	f8c5 4900 	str.w	r4, [r5, #2304]	; 0x900
      if (ep->type != EP_TYPE_ISOC)
 8005152:	e7cd      	b.n	80050f0 <USB_EPStartXfer+0x170>
      if ((uint32_t)ep->dma_addr != 0U)
 8005154:	694a      	ldr	r2, [r1, #20]
 8005156:	b95a      	cbnz	r2, 8005170 <USB_EPStartXfer+0x1f0>
      if (ep->type == EP_TYPE_ISOC)
 8005158:	2f01      	cmp	r7, #1
 800515a:	d00e      	beq.n	800517a <USB_EPStartXfer+0x1fa>
      USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 800515c:	681a      	ldr	r2, [r3, #0]
 800515e:	f042 4204 	orr.w	r2, r2, #2214592512	; 0x84000000
 8005162:	601a      	str	r2, [r3, #0]
}
 8005164:	2000      	movs	r0, #0
 8005166:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if ((uint32_t)ep->dma_addr != 0U)
 800516a:	694a      	ldr	r2, [r1, #20]
 800516c:	2a00      	cmp	r2, #0
 800516e:	d0f5      	beq.n	800515c <USB_EPStartXfer+0x1dc>
        USBx_INEP(epnum)->DIEPDMA = (uint32_t)(ep->dma_addr);
 8005170:	615a      	str	r2, [r3, #20]
 8005172:	e7f1      	b.n	8005158 <USB_EPStartXfer+0x1d8>
      if ((uint32_t)ep->dma_addr != 0U)
 8005174:	694a      	ldr	r2, [r1, #20]
 8005176:	2a00      	cmp	r2, #0
 8005178:	d1fa      	bne.n	8005170 <USB_EPStartXfer+0x1f0>
        if ((USBx_DEVICE->DSTS & (1U << 8)) == 0U)
 800517a:	f8d0 2808 	ldr.w	r2, [r0, #2056]	; 0x808
 800517e:	f412 7f80 	tst.w	r2, #256	; 0x100
          USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SODDFRM;
 8005182:	681a      	ldr	r2, [r3, #0]
 8005184:	bf0c      	ite	eq
 8005186:	f042 5200 	orreq.w	r2, r2, #536870912	; 0x20000000
          USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM;
 800518a:	f042 5280 	orrne.w	r2, r2, #268435456	; 0x10000000
 800518e:	601a      	str	r2, [r3, #0]
 8005190:	e7e4      	b.n	800515c <USB_EPStartXfer+0x1dc>
 8005192:	bf00      	nop
 8005194:	1ff80000 	.word	0x1ff80000

08005198 <USB_EP0StartXfer>:
  if (ep->is_in == 1U)
 8005198:	784b      	ldrb	r3, [r1, #1]
 800519a:	2b01      	cmp	r3, #1
{
 800519c:	b4f0      	push	{r4, r5, r6, r7}
  uint32_t epnum = (uint32_t)ep->num;
 800519e:	780c      	ldrb	r4, [r1, #0]
  if (ep->is_in == 1U)
 80051a0:	d028      	beq.n	80051f4 <USB_EP0StartXfer+0x5c>
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ);
 80051a2:	eb00 1044 	add.w	r0, r0, r4, lsl #5
 80051a6:	f500 6330 	add.w	r3, r0, #2816	; 0xb00
 80051aa:	691c      	ldr	r4, [r3, #16]
 80051ac:	0ce4      	lsrs	r4, r4, #19
 80051ae:	04e4      	lsls	r4, r4, #19
 80051b0:	611c      	str	r4, [r3, #16]
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT);
 80051b2:	691c      	ldr	r4, [r3, #16]
 80051b4:	f024 54ff 	bic.w	r4, r4, #534773760	; 0x1fe00000
 80051b8:	f424 14c0 	bic.w	r4, r4, #1572864	; 0x180000
 80051bc:	611c      	str	r4, [r3, #16]
    if (ep->xfer_len > 0U)
 80051be:	698c      	ldr	r4, [r1, #24]
 80051c0:	b9ac      	cbnz	r4, 80051ee <USB_EP0StartXfer+0x56>
      if (ep->xfer_len > ep->maxpacket)
 80051c2:	68cc      	ldr	r4, [r1, #12]
    USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));
 80051c4:	691d      	ldr	r5, [r3, #16]
    ep->xfer_size = ep->maxpacket;
 80051c6:	61cc      	str	r4, [r1, #28]
    USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));
 80051c8:	f445 2500 	orr.w	r5, r5, #524288	; 0x80000
 80051cc:	611d      	str	r5, [r3, #16]
    USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & ep->xfer_size);
 80051ce:	691d      	ldr	r5, [r3, #16]
 80051d0:	f3c4 0412 	ubfx	r4, r4, #0, #19
 80051d4:	432c      	orrs	r4, r5
    if (dma == 1U)
 80051d6:	2a01      	cmp	r2, #1
    USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & ep->xfer_size);
 80051d8:	611c      	str	r4, [r3, #16]
    if (dma == 1U)
 80051da:	d043      	beq.n	8005264 <USB_EP0StartXfer+0xcc>
    USBx_OUTEP(epnum)->DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);
 80051dc:	f8d0 3b00 	ldr.w	r3, [r0, #2816]	; 0xb00
 80051e0:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
 80051e4:	f8c0 3b00 	str.w	r3, [r0, #2816]	; 0xb00
}
 80051e8:	2000      	movs	r0, #0
 80051ea:	bcf0      	pop	{r4, r5, r6, r7}
 80051ec:	4770      	bx	lr
      ep->xfer_len = ep->maxpacket;
 80051ee:	68cc      	ldr	r4, [r1, #12]
 80051f0:	618c      	str	r4, [r1, #24]
 80051f2:	e7e7      	b.n	80051c4 <USB_EP0StartXfer+0x2c>
    if (ep->xfer_len == 0U)
 80051f4:	698d      	ldr	r5, [r1, #24]
 80051f6:	2d00      	cmp	r5, #0
 80051f8:	d039      	beq.n	800526e <USB_EP0StartXfer+0xd6>
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 80051fa:	eb00 1c44 	add.w	ip, r0, r4, lsl #5
      if (ep->xfer_len > ep->maxpacket)
 80051fe:	68ce      	ldr	r6, [r1, #12]
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 8005200:	f8dc 3910 	ldr.w	r3, [ip, #2320]	; 0x910
 8005204:	0cdb      	lsrs	r3, r3, #19
 8005206:	04db      	lsls	r3, r3, #19
 8005208:	f8cc 3910 	str.w	r3, [ip, #2320]	; 0x910
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 800520c:	f8dc 3910 	ldr.w	r3, [ip, #2320]	; 0x910
 8005210:	f023 53ff 	bic.w	r3, r3, #534773760	; 0x1fe00000
 8005214:	f423 13c0 	bic.w	r3, r3, #1572864	; 0x180000
      if (ep->xfer_len > ep->maxpacket)
 8005218:	42b5      	cmp	r5, r6
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 800521a:	f8cc 3910 	str.w	r3, [ip, #2320]	; 0x910
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 800521e:	f50c 6310 	add.w	r3, ip, #2304	; 0x900
      if (ep->xfer_len > ep->maxpacket)
 8005222:	d952      	bls.n	80052ca <USB_EP0StartXfer+0x132>
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19));
 8005224:	691d      	ldr	r5, [r3, #16]
        ep->xfer_len = ep->maxpacket;
 8005226:	618e      	str	r6, [r1, #24]
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19));
 8005228:	f445 2500 	orr.w	r5, r5, #524288	; 0x80000
 800522c:	611d      	str	r5, [r3, #16]
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len);
 800522e:	691f      	ldr	r7, [r3, #16]
 8005230:	f3c6 0512 	ubfx	r5, r6, #0, #19
 8005234:	433d      	orrs	r5, r7
    if (dma == 1U)
 8005236:	2a01      	cmp	r2, #1
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len);
 8005238:	611d      	str	r5, [r3, #16]
    if (dma == 1U)
 800523a:	d03c      	beq.n	80052b6 <USB_EP0StartXfer+0x11e>
      USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 800523c:	f8dc 3900 	ldr.w	r3, [ip, #2304]	; 0x900
 8005240:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
 8005244:	f8cc 3900 	str.w	r3, [ip, #2304]	; 0x900
      if (ep->xfer_len > 0U)
 8005248:	2e00      	cmp	r6, #0
 800524a:	d0cd      	beq.n	80051e8 <USB_EP0StartXfer+0x50>
        USBx_DEVICE->DIEPEMPMSK |= 1UL << (ep->num & EP_ADDR_MSK);
 800524c:	f8d0 3834 	ldr.w	r3, [r0, #2100]	; 0x834
 8005250:	f004 020f 	and.w	r2, r4, #15
 8005254:	2401      	movs	r4, #1
 8005256:	4094      	lsls	r4, r2
 8005258:	431c      	orrs	r4, r3
 800525a:	f8c0 4834 	str.w	r4, [r0, #2100]	; 0x834
}
 800525e:	2000      	movs	r0, #0
 8005260:	bcf0      	pop	{r4, r5, r6, r7}
 8005262:	4770      	bx	lr
      if ((uint32_t)ep->xfer_buff != 0U)
 8005264:	690a      	ldr	r2, [r1, #16]
 8005266:	2a00      	cmp	r2, #0
 8005268:	d0b8      	beq.n	80051dc <USB_EP0StartXfer+0x44>
        USBx_OUTEP(epnum)->DOEPDMA = (uint32_t)(ep->xfer_buff);
 800526a:	615a      	str	r2, [r3, #20]
 800526c:	e7b6      	b.n	80051dc <USB_EP0StartXfer+0x44>
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 800526e:	eb00 1044 	add.w	r0, r0, r4, lsl #5
    if (dma == 1U)
 8005272:	2a01      	cmp	r2, #1
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 8005274:	f8d0 5910 	ldr.w	r5, [r0, #2320]	; 0x910
 8005278:	f025 55ff 	bic.w	r5, r5, #534773760	; 0x1fe00000
 800527c:	f425 15c0 	bic.w	r5, r5, #1572864	; 0x180000
 8005280:	f8c0 5910 	str.w	r5, [r0, #2320]	; 0x910
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19));
 8005284:	f8d0 5910 	ldr.w	r5, [r0, #2320]	; 0x910
 8005288:	f445 2500 	orr.w	r5, r5, #524288	; 0x80000
 800528c:	f8c0 5910 	str.w	r5, [r0, #2320]	; 0x910
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 8005290:	f8d0 5910 	ldr.w	r5, [r0, #2320]	; 0x910
 8005294:	ea4f 45d5 	mov.w	r5, r5, lsr #19
 8005298:	ea4f 45c5 	mov.w	r5, r5, lsl #19
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 800529c:	f500 6310 	add.w	r3, r0, #2304	; 0x900
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 80052a0:	611d      	str	r5, [r3, #16]
    if (dma == 1U)
 80052a2:	d008      	beq.n	80052b6 <USB_EP0StartXfer+0x11e>
      USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 80052a4:	f8d0 3900 	ldr.w	r3, [r0, #2304]	; 0x900
 80052a8:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
 80052ac:	f8c0 3900 	str.w	r3, [r0, #2304]	; 0x900
}
 80052b0:	bcf0      	pop	{r4, r5, r6, r7}
 80052b2:	2000      	movs	r0, #0
 80052b4:	4770      	bx	lr
      if ((uint32_t)ep->dma_addr != 0U)
 80052b6:	694a      	ldr	r2, [r1, #20]
 80052b8:	b102      	cbz	r2, 80052bc <USB_EP0StartXfer+0x124>
        USBx_INEP(epnum)->DIEPDMA = (uint32_t)(ep->dma_addr);
 80052ba:	615a      	str	r2, [r3, #20]
      USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 80052bc:	681a      	ldr	r2, [r3, #0]
 80052be:	f042 4204 	orr.w	r2, r2, #2214592512	; 0x84000000
}
 80052c2:	2000      	movs	r0, #0
 80052c4:	bcf0      	pop	{r4, r5, r6, r7}
      USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 80052c6:	601a      	str	r2, [r3, #0]
}
 80052c8:	4770      	bx	lr
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19));
 80052ca:	691e      	ldr	r6, [r3, #16]
 80052cc:	f446 2600 	orr.w	r6, r6, #524288	; 0x80000
 80052d0:	611e      	str	r6, [r3, #16]
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len);
 80052d2:	691e      	ldr	r6, [r3, #16]
 80052d4:	f3c5 0512 	ubfx	r5, r5, #0, #19
 80052d8:	4335      	orrs	r5, r6
    if (dma == 1U)
 80052da:	2a01      	cmp	r2, #1
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len);
 80052dc:	611d      	str	r5, [r3, #16]
    if (dma == 1U)
 80052de:	d0ea      	beq.n	80052b6 <USB_EP0StartXfer+0x11e>
      USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 80052e0:	f8dc 3900 	ldr.w	r3, [ip, #2304]	; 0x900
 80052e4:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
 80052e8:	f8cc 3900 	str.w	r3, [ip, #2304]	; 0x900
      if (ep->xfer_len > 0U)
 80052ec:	e7ae      	b.n	800524c <USB_EP0StartXfer+0xb4>
 80052ee:	bf00      	nop

080052f0 <USB_EPStopXfer>:
  if (ep->is_in == 1U)
 80052f0:	784b      	ldrb	r3, [r1, #1]
{
 80052f2:	b082      	sub	sp, #8
  __IO uint32_t count = 0U;
 80052f4:	2200      	movs	r2, #0
  if (ep->is_in == 1U)
 80052f6:	2b01      	cmp	r3, #1
  __IO uint32_t count = 0U;
 80052f8:	9201      	str	r2, [sp, #4]
    if (((USBx_INEP(ep->num)->DIEPCTL) & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
 80052fa:	780b      	ldrb	r3, [r1, #0]
  if (ep->is_in == 1U)
 80052fc:	d020      	beq.n	8005340 <USB_EPStopXfer+0x50>
    if (((USBx_OUTEP(ep->num)->DOEPCTL) & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 80052fe:	f500 6030 	add.w	r0, r0, #2816	; 0xb00
 8005302:	eb00 1043 	add.w	r0, r0, r3, lsl #5
 8005306:	6803      	ldr	r3, [r0, #0]
 8005308:	2b00      	cmp	r3, #0
 800530a:	db02      	blt.n	8005312 <USB_EPStopXfer+0x22>
  HAL_StatusTypeDef ret = HAL_OK;
 800530c:	2000      	movs	r0, #0
}
 800530e:	b002      	add	sp, #8
 8005310:	4770      	bx	lr
      USBx_OUTEP(ep->num)->DOEPCTL |= (USB_OTG_DOEPCTL_SNAK);
 8005312:	6803      	ldr	r3, [r0, #0]
 8005314:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 8005318:	6003      	str	r3, [r0, #0]
      USBx_OUTEP(ep->num)->DOEPCTL |= (USB_OTG_DOEPCTL_EPDIS);
 800531a:	6803      	ldr	r3, [r0, #0]
 800531c:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
        if (count > 10000U)
 8005320:	f242 7210 	movw	r2, #10000	; 0x2710
      USBx_OUTEP(ep->num)->DOEPCTL |= (USB_OTG_DOEPCTL_EPDIS);
 8005324:	6003      	str	r3, [r0, #0]
 8005326:	e002      	b.n	800532e <USB_EPStopXfer+0x3e>
      } while (((USBx_OUTEP(ep->num)->DOEPCTL) & USB_OTG_DOEPCTL_EPENA) ==  USB_OTG_DOEPCTL_EPENA);
 8005328:	6803      	ldr	r3, [r0, #0]
 800532a:	2b00      	cmp	r3, #0
 800532c:	daee      	bge.n	800530c <USB_EPStopXfer+0x1c>
        count++;
 800532e:	9b01      	ldr	r3, [sp, #4]
 8005330:	3301      	adds	r3, #1
 8005332:	9301      	str	r3, [sp, #4]
        if (count > 10000U)
 8005334:	9b01      	ldr	r3, [sp, #4]
 8005336:	4293      	cmp	r3, r2
 8005338:	d9f6      	bls.n	8005328 <USB_EPStopXfer+0x38>
          ret = HAL_ERROR;
 800533a:	2001      	movs	r0, #1
}
 800533c:	b002      	add	sp, #8
 800533e:	4770      	bx	lr
    if (((USBx_INEP(ep->num)->DIEPCTL) & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
 8005340:	f500 6010 	add.w	r0, r0, #2304	; 0x900
 8005344:	eb00 1343 	add.w	r3, r0, r3, lsl #5
 8005348:	681a      	ldr	r2, [r3, #0]
 800534a:	2a00      	cmp	r2, #0
 800534c:	dade      	bge.n	800530c <USB_EPStopXfer+0x1c>
      USBx_INEP(ep->num)->DIEPCTL |= (USB_OTG_DIEPCTL_SNAK);
 800534e:	681a      	ldr	r2, [r3, #0]
 8005350:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
 8005354:	601a      	str	r2, [r3, #0]
      USBx_INEP(ep->num)->DIEPCTL |= (USB_OTG_DIEPCTL_EPDIS);
 8005356:	681a      	ldr	r2, [r3, #0]
 8005358:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
        if (count > 10000U)
 800535c:	f242 7110 	movw	r1, #10000	; 0x2710
      USBx_INEP(ep->num)->DIEPCTL |= (USB_OTG_DIEPCTL_EPDIS);
 8005360:	601a      	str	r2, [r3, #0]
 8005362:	e002      	b.n	800536a <USB_EPStopXfer+0x7a>
      } while (((USBx_INEP(ep->num)->DIEPCTL) & USB_OTG_DIEPCTL_EPENA) ==  USB_OTG_DIEPCTL_EPENA);
 8005364:	681a      	ldr	r2, [r3, #0]
 8005366:	2a00      	cmp	r2, #0
 8005368:	dad0      	bge.n	800530c <USB_EPStopXfer+0x1c>
        count++;
 800536a:	9a01      	ldr	r2, [sp, #4]
 800536c:	3201      	adds	r2, #1
 800536e:	9201      	str	r2, [sp, #4]
        if (count > 10000U)
 8005370:	9a01      	ldr	r2, [sp, #4]
 8005372:	428a      	cmp	r2, r1
 8005374:	d9f6      	bls.n	8005364 <USB_EPStopXfer+0x74>
 8005376:	e7e0      	b.n	800533a <USB_EPStopXfer+0x4a>

08005378 <USB_WritePacket>:
{
 8005378:	b410      	push	{r4}
 800537a:	f89d 4004 	ldrb.w	r4, [sp, #4]
  if (dma == 0U)
 800537e:	b964      	cbnz	r4, 800539a <USB_WritePacket+0x22>
    count32b = ((uint32_t)len + 3U) / 4U;
 8005380:	3303      	adds	r3, #3
    for (i = 0U; i < count32b; i++)
 8005382:	089b      	lsrs	r3, r3, #2
 8005384:	d009      	beq.n	800539a <USB_WritePacket+0x22>
      USBx_DFIFO((uint32_t)ch_ep_num) = __UNALIGNED_UINT32_READ(pSrc);
 8005386:	3201      	adds	r2, #1
 8005388:	eb00 3002 	add.w	r0, r0, r2, lsl #12
 800538c:	eb01 0383 	add.w	r3, r1, r3, lsl #2
 8005390:	f851 2b04 	ldr.w	r2, [r1], #4
 8005394:	6002      	str	r2, [r0, #0]
    for (i = 0U; i < count32b; i++)
 8005396:	428b      	cmp	r3, r1
 8005398:	d1fa      	bne.n	8005390 <USB_WritePacket+0x18>
}
 800539a:	2000      	movs	r0, #0
 800539c:	f85d 4b04 	ldr.w	r4, [sp], #4
 80053a0:	4770      	bx	lr
 80053a2:	bf00      	nop

080053a4 <USB_ReadPacket>:
  for (i = 0U; i < count32b; i++)
 80053a4:	ea5f 0c92 	movs.w	ip, r2, lsr #2
{
 80053a8:	b570      	push	{r4, r5, r6, lr}
 80053aa:	4605      	mov	r5, r0
  uint16_t remaining_bytes = len % 4U;
 80053ac:	f002 0603 	and.w	r6, r2, #3
  for (i = 0U; i < count32b; i++)
 80053b0:	d01e      	beq.n	80053f0 <USB_ReadPacket+0x4c>
    __UNALIGNED_UINT32_WRITE(&pData, USBx_DFIFO(0U));
 80053b2:	f500 5e80 	add.w	lr, r0, #4096	; 0x1000
  uint8_t *pDest = dest;
 80053b6:	460a      	mov	r2, r1
  for (i = 0U; i < count32b; i++)
 80053b8:	2300      	movs	r3, #0
 80053ba:	3301      	adds	r3, #1
    __UNALIGNED_UINT32_WRITE(pDest, USBx_DFIFO(0U));
 80053bc:	f8de 4000 	ldr.w	r4, [lr]
 80053c0:	f842 4b04 	str.w	r4, [r2], #4
  for (i = 0U; i < count32b; i++)
 80053c4:	459c      	cmp	ip, r3
 80053c6:	d1f8      	bne.n	80053ba <USB_ReadPacket+0x16>
    pDest++;
 80053c8:	eb01 008c 	add.w	r0, r1, ip, lsl #2
  if (remaining_bytes != 0U)
 80053cc:	b17e      	cbz	r6, 80053ee <USB_ReadPacket+0x4a>
    __UNALIGNED_UINT32_WRITE(&pData, USBx_DFIFO(0U));
 80053ce:	f505 5580 	add.w	r5, r5, #4096	; 0x1000
      remaining_bytes--;
 80053d2:	1e73      	subs	r3, r6, #1
    __UNALIGNED_UINT32_WRITE(&pData, USBx_DFIFO(0U));
 80053d4:	682a      	ldr	r2, [r5, #0]
      *(uint8_t *)pDest = (uint8_t)(pData >> (8U * (uint8_t)(i)));
 80053d6:	7002      	strb	r2, [r0, #0]
      remaining_bytes--;
 80053d8:	b29b      	uxth	r3, r3
    } while (remaining_bytes != 0U);
 80053da:	b13b      	cbz	r3, 80053ec <USB_ReadPacket+0x48>
 80053dc:	2b01      	cmp	r3, #1
      *(uint8_t *)pDest = (uint8_t)(pData >> (8U * (uint8_t)(i)));
 80053de:	ea4f 2112 	mov.w	r1, r2, lsr #8
 80053e2:	bf18      	it	ne
 80053e4:	0c12      	lsrne	r2, r2, #16
 80053e6:	7041      	strb	r1, [r0, #1]
 80053e8:	bf18      	it	ne
 80053ea:	7082      	strbne	r2, [r0, #2]
      pDest++;
 80053ec:	4430      	add	r0, r6
}
 80053ee:	bd70      	pop	{r4, r5, r6, pc}
  uint8_t *pDest = dest;
 80053f0:	4608      	mov	r0, r1
 80053f2:	e7eb      	b.n	80053cc <USB_ReadPacket+0x28>

080053f4 <USB_EPSetStall>:
  if (ep->is_in == 1U)
 80053f4:	784a      	ldrb	r2, [r1, #1]
  uint32_t epnum = (uint32_t)ep->num;
 80053f6:	780b      	ldrb	r3, [r1, #0]
  if (ep->is_in == 1U)
 80053f8:	2a01      	cmp	r2, #1
    if (((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == 0U) && (epnum != 0U))
 80053fa:	eb00 1043 	add.w	r0, r0, r3, lsl #5
  if (ep->is_in == 1U)
 80053fe:	d00c      	beq.n	800541a <USB_EPSetStall+0x26>
    if (((USBx_OUTEP(epnum)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == 0U) && (epnum != 0U))
 8005400:	f8d0 2b00 	ldr.w	r2, [r0, #2816]	; 0xb00
 8005404:	2a00      	cmp	r2, #0
 8005406:	db00      	blt.n	800540a <USB_EPSetStall+0x16>
 8005408:	b9d3      	cbnz	r3, 8005440 <USB_EPSetStall+0x4c>
    USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_STALL;
 800540a:	f8d0 3b00 	ldr.w	r3, [r0, #2816]	; 0xb00
 800540e:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8005412:	f8c0 3b00 	str.w	r3, [r0, #2816]	; 0xb00
}
 8005416:	2000      	movs	r0, #0
 8005418:	4770      	bx	lr
    if (((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == 0U) && (epnum != 0U))
 800541a:	f8d0 2900 	ldr.w	r2, [r0, #2304]	; 0x900
 800541e:	2a00      	cmp	r2, #0
 8005420:	db06      	blt.n	8005430 <USB_EPSetStall+0x3c>
 8005422:	b12b      	cbz	r3, 8005430 <USB_EPSetStall+0x3c>
      USBx_INEP(epnum)->DIEPCTL &= ~(USB_OTG_DIEPCTL_EPDIS);
 8005424:	f8d0 3900 	ldr.w	r3, [r0, #2304]	; 0x900
 8005428:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
 800542c:	f8c0 3900 	str.w	r3, [r0, #2304]	; 0x900
    USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_STALL;
 8005430:	f8d0 3900 	ldr.w	r3, [r0, #2304]	; 0x900
 8005434:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8005438:	f8c0 3900 	str.w	r3, [r0, #2304]	; 0x900
}
 800543c:	2000      	movs	r0, #0
 800543e:	4770      	bx	lr
      USBx_OUTEP(epnum)->DOEPCTL &= ~(USB_OTG_DOEPCTL_EPDIS);
 8005440:	f8d0 3b00 	ldr.w	r3, [r0, #2816]	; 0xb00
 8005444:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
 8005448:	f8c0 3b00 	str.w	r3, [r0, #2816]	; 0xb00
 800544c:	e7dd      	b.n	800540a <USB_EPSetStall+0x16>
 800544e:	bf00      	nop

08005450 <USB_EPClearStall>:
  if (ep->is_in == 1U)
 8005450:	784a      	ldrb	r2, [r1, #1]
  uint32_t epnum = (uint32_t)ep->num;
 8005452:	780b      	ldrb	r3, [r1, #0]
  if (ep->is_in == 1U)
 8005454:	2a01      	cmp	r2, #1
    USBx_INEP(epnum)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
 8005456:	eb00 1043 	add.w	r0, r0, r3, lsl #5
  if (ep->is_in == 1U)
 800545a:	d013      	beq.n	8005484 <USB_EPClearStall+0x34>
    USBx_OUTEP(epnum)->DOEPCTL &= ~USB_OTG_DOEPCTL_STALL;
 800545c:	f8d0 3b00 	ldr.w	r3, [r0, #2816]	; 0xb00
 8005460:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 8005464:	f8c0 3b00 	str.w	r3, [r0, #2816]	; 0xb00
    if ((ep->type == EP_TYPE_INTR) || (ep->type == EP_TYPE_BULK))
 8005468:	790b      	ldrb	r3, [r1, #4]
 800546a:	3b02      	subs	r3, #2
 800546c:	2b01      	cmp	r3, #1
 800546e:	d901      	bls.n	8005474 <USB_EPClearStall+0x24>
}
 8005470:	2000      	movs	r0, #0
 8005472:	4770      	bx	lr
      USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM; /* DATA0 */
 8005474:	f8d0 3b00 	ldr.w	r3, [r0, #2816]	; 0xb00
 8005478:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800547c:	f8c0 3b00 	str.w	r3, [r0, #2816]	; 0xb00
}
 8005480:	2000      	movs	r0, #0
 8005482:	4770      	bx	lr
    USBx_INEP(epnum)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
 8005484:	f8d0 3900 	ldr.w	r3, [r0, #2304]	; 0x900
 8005488:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 800548c:	f8c0 3900 	str.w	r3, [r0, #2304]	; 0x900
    if ((ep->type == EP_TYPE_INTR) || (ep->type == EP_TYPE_BULK))
 8005490:	790b      	ldrb	r3, [r1, #4]
 8005492:	3b02      	subs	r3, #2
 8005494:	2b01      	cmp	r3, #1
 8005496:	d8eb      	bhi.n	8005470 <USB_EPClearStall+0x20>
      USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM; /* DATA0 */
 8005498:	f8d0 3900 	ldr.w	r3, [r0, #2304]	; 0x900
 800549c:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 80054a0:	f8c0 3900 	str.w	r3, [r0, #2304]	; 0x900
}
 80054a4:	2000      	movs	r0, #0
 80054a6:	4770      	bx	lr

080054a8 <USB_SetDevAddress>:
  USBx_DEVICE->DCFG &= ~(USB_OTG_DCFG_DAD);
 80054a8:	f8d0 3800 	ldr.w	r3, [r0, #2048]	; 0x800
 80054ac:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
 80054b0:	f8c0 3800 	str.w	r3, [r0, #2048]	; 0x800
  USBx_DEVICE->DCFG |= ((uint32_t)address << 4) & USB_OTG_DCFG_DAD;
 80054b4:	f8d0 3800 	ldr.w	r3, [r0, #2048]	; 0x800
 80054b8:	0109      	lsls	r1, r1, #4
 80054ba:	f401 61fe 	and.w	r1, r1, #2032	; 0x7f0
 80054be:	4319      	orrs	r1, r3
 80054c0:	f8c0 1800 	str.w	r1, [r0, #2048]	; 0x800
}
 80054c4:	2000      	movs	r0, #0
 80054c6:	4770      	bx	lr

080054c8 <USB_DevConnect>:
  USBx_PCGCCTL &= ~(USB_OTG_PCGCCTL_STOPCLK | USB_OTG_PCGCCTL_GATECLK);
 80054c8:	f8d0 2e00 	ldr.w	r2, [r0, #3584]	; 0xe00
{
 80054cc:	4603      	mov	r3, r0
  USBx_PCGCCTL &= ~(USB_OTG_PCGCCTL_STOPCLK | USB_OTG_PCGCCTL_GATECLK);
 80054ce:	f022 0203 	bic.w	r2, r2, #3
 80054d2:	f8c3 2e00 	str.w	r2, [r3, #3584]	; 0xe00
  USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_SDIS;
 80054d6:	f8d3 3804 	ldr.w	r3, [r3, #2052]	; 0x804
 80054da:	f500 6100 	add.w	r1, r0, #2048	; 0x800
 80054de:	f023 0302 	bic.w	r3, r3, #2
}
 80054e2:	2000      	movs	r0, #0
  USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_SDIS;
 80054e4:	604b      	str	r3, [r1, #4]
}
 80054e6:	4770      	bx	lr

080054e8 <USB_DevDisconnect>:
  USBx_PCGCCTL &= ~(USB_OTG_PCGCCTL_STOPCLK | USB_OTG_PCGCCTL_GATECLK);
 80054e8:	f8d0 2e00 	ldr.w	r2, [r0, #3584]	; 0xe00
{
 80054ec:	4603      	mov	r3, r0
  USBx_PCGCCTL &= ~(USB_OTG_PCGCCTL_STOPCLK | USB_OTG_PCGCCTL_GATECLK);
 80054ee:	f022 0203 	bic.w	r2, r2, #3
 80054f2:	f8c3 2e00 	str.w	r2, [r3, #3584]	; 0xe00
  USBx_DEVICE->DCTL |= USB_OTG_DCTL_SDIS;
 80054f6:	f8d3 3804 	ldr.w	r3, [r3, #2052]	; 0x804
 80054fa:	f500 6100 	add.w	r1, r0, #2048	; 0x800
 80054fe:	f043 0302 	orr.w	r3, r3, #2
}
 8005502:	2000      	movs	r0, #0
  USBx_DEVICE->DCTL |= USB_OTG_DCTL_SDIS;
 8005504:	604b      	str	r3, [r1, #4]
}
 8005506:	4770      	bx	lr

08005508 <USB_ReadInterrupts>:
  tmpreg = USBx->GINTSTS;
 8005508:	6942      	ldr	r2, [r0, #20]
  tmpreg &= USBx->GINTMSK;
 800550a:	6980      	ldr	r0, [r0, #24]
}
 800550c:	4010      	ands	r0, r2
 800550e:	4770      	bx	lr

08005510 <USB_ReadDevAllOutEpInterrupt>:
  tmpreg  = USBx_DEVICE->DAINT;
 8005510:	f8d0 3818 	ldr.w	r3, [r0, #2072]	; 0x818
 8005514:	f500 6000 	add.w	r0, r0, #2048	; 0x800
  tmpreg &= USBx_DEVICE->DAINTMSK;
 8005518:	69c0      	ldr	r0, [r0, #28]
 800551a:	4018      	ands	r0, r3
}
 800551c:	0c00      	lsrs	r0, r0, #16
 800551e:	4770      	bx	lr

08005520 <USB_ReadDevAllInEpInterrupt>:
  tmpreg  = USBx_DEVICE->DAINT;
 8005520:	f8d0 3818 	ldr.w	r3, [r0, #2072]	; 0x818
 8005524:	f500 6000 	add.w	r0, r0, #2048	; 0x800
  tmpreg &= USBx_DEVICE->DAINTMSK;
 8005528:	69c0      	ldr	r0, [r0, #28]
 800552a:	4018      	ands	r0, r3
}
 800552c:	b280      	uxth	r0, r0
 800552e:	4770      	bx	lr

08005530 <USB_ReadDevOutEPInterrupt>:
  tmpreg  = USBx_OUTEP((uint32_t)epnum)->DOEPINT;
 8005530:	eb00 1141 	add.w	r1, r0, r1, lsl #5
  tmpreg &= USBx_DEVICE->DOEPMSK;
 8005534:	f500 6000 	add.w	r0, r0, #2048	; 0x800
  tmpreg  = USBx_OUTEP((uint32_t)epnum)->DOEPINT;
 8005538:	f8d1 2b08 	ldr.w	r2, [r1, #2824]	; 0xb08
  tmpreg &= USBx_DEVICE->DOEPMSK;
 800553c:	6940      	ldr	r0, [r0, #20]
}
 800553e:	4010      	ands	r0, r2
 8005540:	4770      	bx	lr
 8005542:	bf00      	nop

08005544 <USB_ReadDevInEPInterrupt>:
  msk = USBx_DEVICE->DIEPMSK;
 8005544:	f8d0 2810 	ldr.w	r2, [r0, #2064]	; 0x810
  emp = USBx_DEVICE->DIEPEMPMSK;
 8005548:	f8d0 3834 	ldr.w	r3, [r0, #2100]	; 0x834
  tmpreg = USBx_INEP((uint32_t)epnum)->DIEPINT & msk;
 800554c:	eb00 1041 	add.w	r0, r0, r1, lsl #5
  msk |= ((emp >> (epnum & EP_ADDR_MSK)) & 0x1U) << 7;
 8005550:	f001 010f 	and.w	r1, r1, #15
 8005554:	40cb      	lsrs	r3, r1
 8005556:	01db      	lsls	r3, r3, #7
  tmpreg = USBx_INEP((uint32_t)epnum)->DIEPINT & msk;
 8005558:	f8d0 0908 	ldr.w	r0, [r0, #2312]	; 0x908
  msk |= ((emp >> (epnum & EP_ADDR_MSK)) & 0x1U) << 7;
 800555c:	b2db      	uxtb	r3, r3
 800555e:	4313      	orrs	r3, r2
}
 8005560:	4018      	ands	r0, r3
 8005562:	4770      	bx	lr

08005564 <USB_GetMode>:
  return ((USBx->GINTSTS) & 0x1U);
 8005564:	6940      	ldr	r0, [r0, #20]
}
 8005566:	f000 0001 	and.w	r0, r0, #1
 800556a:	4770      	bx	lr

0800556c <USB_ActivateSetup>:
  USBx_INEP(0U)->DIEPCTL &= ~USB_OTG_DIEPCTL_MPSIZ;
 800556c:	f8d0 2900 	ldr.w	r2, [r0, #2304]	; 0x900
{
 8005570:	4603      	mov	r3, r0
  USBx_INEP(0U)->DIEPCTL &= ~USB_OTG_DIEPCTL_MPSIZ;
 8005572:	f422 62ff 	bic.w	r2, r2, #2040	; 0x7f8
 8005576:	f022 0207 	bic.w	r2, r2, #7
 800557a:	f8c3 2900 	str.w	r2, [r3, #2304]	; 0x900
  USBx_DEVICE->DCTL |= USB_OTG_DCTL_CGINAK;
 800557e:	f8d3 3804 	ldr.w	r3, [r3, #2052]	; 0x804
 8005582:	f500 6100 	add.w	r1, r0, #2048	; 0x800
 8005586:	f443 7380 	orr.w	r3, r3, #256	; 0x100
}
 800558a:	2000      	movs	r0, #0
  USBx_DEVICE->DCTL |= USB_OTG_DCTL_CGINAK;
 800558c:	604b      	str	r3, [r1, #4]
}
 800558e:	4770      	bx	lr

08005590 <USB_EP0_OutStart>:
{
 8005590:	b410      	push	{r4}
  if (gSNPSiD > USB_OTG_CORE_ID_300A)
 8005592:	4b14      	ldr	r3, [pc, #80]	; (80055e4 <USB_EP0_OutStart+0x54>)
  uint32_t gSNPSiD = *(__IO uint32_t *)(&USBx->CID + 0x1U);
 8005594:	6c04      	ldr	r4, [r0, #64]	; 0x40
  if (gSNPSiD > USB_OTG_CORE_ID_300A)
 8005596:	429c      	cmp	r4, r3
 8005598:	d81a      	bhi.n	80055d0 <USB_EP0_OutStart+0x40>
    if ((USBx_OUTEP(0U)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 800559a:	f500 6030 	add.w	r0, r0, #2816	; 0xb00
  USBx_OUTEP(0U)->DOEPTSIZ = 0U;
 800559e:	2300      	movs	r3, #0
 80055a0:	6103      	str	r3, [r0, #16]
  USBx_OUTEP(0U)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));
 80055a2:	6903      	ldr	r3, [r0, #16]
 80055a4:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 80055a8:	6103      	str	r3, [r0, #16]
  USBx_OUTEP(0U)->DOEPTSIZ |= (3U * 8U);
 80055aa:	6903      	ldr	r3, [r0, #16]
 80055ac:	f043 0318 	orr.w	r3, r3, #24
 80055b0:	6103      	str	r3, [r0, #16]
  USBx_OUTEP(0U)->DOEPTSIZ |=  USB_OTG_DOEPTSIZ_STUPCNT;
 80055b2:	6903      	ldr	r3, [r0, #16]
  if (dma == 1U)
 80055b4:	2901      	cmp	r1, #1
  USBx_OUTEP(0U)->DOEPTSIZ |=  USB_OTG_DOEPTSIZ_STUPCNT;
 80055b6:	f043 43c0 	orr.w	r3, r3, #1610612736	; 0x60000000
 80055ba:	6103      	str	r3, [r0, #16]
  if (dma == 1U)
 80055bc:	d104      	bne.n	80055c8 <USB_EP0_OutStart+0x38>
    USBx_OUTEP(0U)->DOEPDMA = (uint32_t)psetup;
 80055be:	6142      	str	r2, [r0, #20]
    USBx_OUTEP(0U)->DOEPCTL |= USB_OTG_DOEPCTL_EPENA | USB_OTG_DOEPCTL_USBAEP;
 80055c0:	6803      	ldr	r3, [r0, #0]
 80055c2:	f043 2380 	orr.w	r3, r3, #2147516416	; 0x80008000
 80055c6:	6003      	str	r3, [r0, #0]
}
 80055c8:	2000      	movs	r0, #0
 80055ca:	f85d 4b04 	ldr.w	r4, [sp], #4
 80055ce:	4770      	bx	lr
    if ((USBx_OUTEP(0U)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 80055d0:	f8d0 3b00 	ldr.w	r3, [r0, #2816]	; 0xb00
 80055d4:	2b00      	cmp	r3, #0
 80055d6:	f500 6030 	add.w	r0, r0, #2816	; 0xb00
 80055da:	dae0      	bge.n	800559e <USB_EP0_OutStart+0xe>
}
 80055dc:	2000      	movs	r0, #0
 80055de:	f85d 4b04 	ldr.w	r4, [sp], #4
 80055e2:	4770      	bx	lr
 80055e4:	4f54300a 	.word	0x4f54300a

080055e8 <USBD_AUDIO_GetCfgDesc>:
* @param  length : pointer data length
* @retval pointer to descriptor buffer
*/
static uint8_t  *USBD_AUDIO_GetCfgDesc (uint16_t *length)
{
  *length = sizeof (USBD_AUDIO_CfgDesc);
 80055e8:	2376      	movs	r3, #118	; 0x76
 80055ea:	8003      	strh	r3, [r0, #0]
  return USBD_AUDIO_CfgDesc;
}
 80055ec:	4800      	ldr	r0, [pc, #0]	; (80055f0 <USBD_AUDIO_GetCfgDesc+0x8>)
 80055ee:	4770      	bx	lr
 80055f0:	20002680 	.word	0x20002680

080055f4 <USBD_AUDIO_EP0_RxReady>:
* @param  pdev: device instance
* @retval status
*/

static uint8_t  USBD_AUDIO_EP0_RxReady (USBD_HandleTypeDef *pdev)
{  
 80055f4:	b510      	push	{r4, lr}
  USBD_AUDIO_HandleTypeDef   *haudio;
  haudio = pdev->pClassData;  
 80055f6:	f8d0 42bc 	ldr.w	r4, [r0, #700]	; 0x2bc
  if (haudio->control.cmd == AUDIO_REQ_SET_CUR)
 80055fa:	7f23      	ldrb	r3, [r4, #28]
 80055fc:	2b01      	cmp	r3, #1
 80055fe:	d001      	beq.n	8005604 <USBD_AUDIO_EP0_RxReady+0x10>
      haudio->control.data[0]=0;
      haudio->control.data[0]=0;
    }
  }    
  return USBD_OK;
}
 8005600:	2000      	movs	r0, #0
 8005602:	bd10      	pop	{r4, pc}
    if (haudio->control.unit == AUDIO_OUT_STREAMING_CTRL)
 8005604:	f894 305e 	ldrb.w	r3, [r4, #94]	; 0x5e
 8005608:	2b02      	cmp	r3, #2
 800560a:	d1f9      	bne.n	8005600 <USBD_AUDIO_EP0_RxReady+0xc>
      ((USBD_AUDIO_ItfTypeDef *)pdev->pUserData[pdev->classId])->VolumeCtl(VOL_CUR);    
 800560c:	f8d0 32d4 	ldr.w	r3, [r0, #724]	; 0x2d4
 8005610:	4a07      	ldr	r2, [pc, #28]	; (8005630 <USBD_AUDIO_EP0_RxReady+0x3c>)
 8005612:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 8005616:	f9b2 0076 	ldrsh.w	r0, [r2, #118]	; 0x76
 800561a:	f8d3 32c4 	ldr.w	r3, [r3, #708]	; 0x2c4
 800561e:	68db      	ldr	r3, [r3, #12]
 8005620:	4798      	blx	r3
      haudio->control.len = 0;
 8005622:	2300      	movs	r3, #0
 8005624:	f8a4 305d 	strh.w	r3, [r4, #93]	; 0x5d
      haudio->control.cmd = 0;
 8005628:	83a3      	strh	r3, [r4, #28]
}
 800562a:	2000      	movs	r0, #0
 800562c:	bd10      	pop	{r4, pc}
 800562e:	bf00      	nop
 8005630:	20002680 	.word	0x20002680

08005634 <USBD_AUDIO_EP0_TxReady>:
*/
static uint8_t  USBD_AUDIO_EP0_TxReady (USBD_HandleTypeDef *pdev)
{
  /* Only OUT control data are processed */
  return USBD_OK;
}
 8005634:	2000      	movs	r0, #0
 8005636:	4770      	bx	lr

08005638 <USBD_AUDIO_DataOut>:
*/
static uint8_t  USBD_AUDIO_DataOut (USBD_HandleTypeDef *pdev, 
                                    uint8_t epnum)
{  
  return USBD_OK;
}
 8005638:	2000      	movs	r0, #0
 800563a:	4770      	bx	lr

0800563c <USBD_AUDIO_GetDeviceQualifierDesc>:
* @param  length : pointer data length
* @retval pointer to descriptor buffer
*/
static uint8_t  *USBD_AUDIO_GetDeviceQualifierDesc (uint16_t *length)
{
  *length = sizeof (USBD_AUDIO_DeviceQualifierDesc);
 800563c:	230a      	movs	r3, #10
 800563e:	8003      	strh	r3, [r0, #0]
  return USBD_AUDIO_DeviceQualifierDesc;
}
 8005640:	4800      	ldr	r0, [pc, #0]	; (8005644 <USBD_AUDIO_GetDeviceQualifierDesc+0x8>)
 8005642:	4770      	bx	lr
 8005644:	20000084 	.word	0x20000084

08005648 <USBD_AUDIO_DataIn>:
{
 8005648:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  haudio = pdev->pClassData;
 800564c:	f8d0 42bc 	ldr.w	r4, [r0, #700]	; 0x2bc
  haudio->timeout=0;
 8005650:	2300      	movs	r3, #0
  if (epnum == (AUDIO_IN_EP & 0x7F))
 8005652:	2901      	cmp	r1, #1
  uint16_t IsocInWr_app = haudio->wr_ptr;
 8005654:	8b27      	ldrh	r7, [r4, #24]
  uint16_t true_dim = haudio->buffer_length;
 8005656:	f8b4 900e 	ldrh.w	r9, [r4, #14]
  uint16_t packet_dim = haudio->paketDimension;
 800565a:	8a66      	ldrh	r6, [r4, #18]
  uint16_t channels = haudio->channels;
 800565c:	f894 8004 	ldrb.w	r8, [r4, #4]
  haudio->timeout=0;
 8005660:	81a3      	strh	r3, [r4, #12]
  if (epnum == (AUDIO_IN_EP & 0x7F))
 8005662:	d002      	beq.n	800566a <USBD_AUDIO_DataIn+0x22>
}
 8005664:	2000      	movs	r0, #0
 8005666:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    if (haudio->state == STATE_USB_IDLE) 
 800566a:	7d22      	ldrb	r2, [r4, #20]
 800566c:	2a01      	cmp	r2, #1
 800566e:	4605      	mov	r5, r0
 8005670:	d10a      	bne.n	8005688 <USBD_AUDIO_DataIn+0x40>
      haudio->state=STATE_USB_REQUESTS_STARTED;
 8005672:	2302      	movs	r3, #2
 8005674:	7523      	strb	r3, [r4, #20]
      ((USBD_AUDIO_ItfTypeDef *)pdev->pUserData[pdev->classId])->Record();      
 8005676:	f8d0 32d4 	ldr.w	r3, [r0, #724]	; 0x2d4
 800567a:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 800567e:	f8d3 32c4 	ldr.w	r3, [r3, #708]	; 0x2c4
 8005682:	689b      	ldr	r3, [r3, #8]
 8005684:	4798      	blx	r3
    if (haudio->state == STATE_USB_BUFFER_WRITE_STARTED)   
 8005686:	7d22      	ldrb	r2, [r4, #20]
 8005688:	2a03      	cmp	r2, #3
  length_usb_pck = packet_dim;  
 800568a:	4633      	mov	r3, r6
    if (haudio->state == STATE_USB_BUFFER_WRITE_STARTED)   
 800568c:	d136      	bne.n	80056fc <USBD_AUDIO_DataIn+0xb4>
      haudio->rd_ptr = haudio->rd_ptr % (true_dim);              
 800568e:	8ae2      	ldrh	r2, [r4, #22]
 8005690:	fbb2 f1f9 	udiv	r1, r2, r9
 8005694:	fb09 2211 	mls	r2, r9, r1, r2
 8005698:	b292      	uxth	r2, r2
      if(IsocInWr_app<haudio->rd_ptr){
 800569a:	42ba      	cmp	r2, r7
        app = ((true_dim) - haudio->rd_ptr) +  IsocInWr_app;
 800569c:	bf88      	it	hi
 800569e:	444f      	addhi	r7, r9
      if(app >= (packet_dim*haudio->upper_treshold)){       
 80056a0:	7ea1      	ldrb	r1, [r4, #26]
      haudio->rd_ptr = haudio->rd_ptr % (true_dim);              
 80056a2:	82e2      	strh	r2, [r4, #22]
        app = IsocInWr_app - haudio->rd_ptr;
 80056a4:	1abf      	subs	r7, r7, r2
 80056a6:	b2bf      	uxth	r7, r7
      if(app >= (packet_dim*haudio->upper_treshold)){       
 80056a8:	fb06 f101 	mul.w	r1, r6, r1
 80056ac:	428f      	cmp	r7, r1
 80056ae:	db2d      	blt.n	800570c <USBD_AUDIO_DataIn+0xc4>
        length_usb_pck += channels*2;
 80056b0:	eb06 0348 	add.w	r3, r6, r8, lsl #1
      haudio->rd_ptr += length_usb_pck;      
 80056b4:	b29e      	uxth	r6, r3
      USBD_LL_Transmit (pdev,AUDIO_IN_EP,
 80056b6:	6e21      	ldr	r1, [r4, #96]	; 0x60
 80056b8:	4628      	mov	r0, r5
 80056ba:	440a      	add	r2, r1
 80056bc:	2181      	movs	r1, #129	; 0x81
 80056be:	f7fc f881 	bl	80017c4 <USBD_LL_Transmit>
      haudio->rd_ptr += length_usb_pck;      
 80056c2:	8ae3      	ldrh	r3, [r4, #22]
      if(app < haudio->buffer_length/10)
 80056c4:	4a16      	ldr	r2, [pc, #88]	; (8005720 <USBD_AUDIO_DataIn+0xd8>)
      haudio->rd_ptr += length_usb_pck;      
 80056c6:	441e      	add	r6, r3
      if(app < haudio->buffer_length/10)
 80056c8:	89e3      	ldrh	r3, [r4, #14]
      haudio->rd_ptr += length_usb_pck;      
 80056ca:	82e6      	strh	r6, [r4, #22]
      if(app < haudio->buffer_length/10)
 80056cc:	fba2 2303 	umull	r2, r3, r2, r3
 80056d0:	ebb7 0fd3 	cmp.w	r7, r3, lsr #3
 80056d4:	d2c6      	bcs.n	8005664 <USBD_AUDIO_DataIn+0x1c>
        ((USBD_AUDIO_ItfTypeDef *)pdev->pUserData[pdev->classId])->Stop();
 80056d6:	f8d5 32d4 	ldr.w	r3, [r5, #724]	; 0x2d4
 80056da:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 80056de:	f8d3 32c4 	ldr.w	r3, [r3, #708]	; 0x2c4
 80056e2:	695b      	ldr	r3, [r3, #20]
 80056e4:	4798      	blx	r3
        memset(haudio->buffer,0,(haudio->buffer_length + haudio->dataAmount));
 80056e6:	89e2      	ldrh	r2, [r4, #14]
 80056e8:	8a23      	ldrh	r3, [r4, #16]
        haudio->timeout=0;
 80056ea:	2100      	movs	r1, #0
        haudio->state = STATE_USB_IDLE; 
 80056ec:	2001      	movs	r0, #1
 80056ee:	7520      	strb	r0, [r4, #20]
        haudio->timeout=0;
 80056f0:	81a1      	strh	r1, [r4, #12]
        memset(haudio->buffer,0,(haudio->buffer_length + haudio->dataAmount));
 80056f2:	6e20      	ldr	r0, [r4, #96]	; 0x60
 80056f4:	441a      	add	r2, r3
 80056f6:	f003 fc87 	bl	8009008 <memset>
 80056fa:	e7b3      	b.n	8005664 <USBD_AUDIO_DataIn+0x1c>
      USBD_LL_Transmit (pdev,AUDIO_IN_EP,
 80056fc:	4a09      	ldr	r2, [pc, #36]	; (8005724 <USBD_AUDIO_DataIn+0xdc>)
 80056fe:	2181      	movs	r1, #129	; 0x81
 8005700:	4628      	mov	r0, r5
 8005702:	f7fc f85f 	bl	80017c4 <USBD_LL_Transmit>
}
 8005706:	2000      	movs	r0, #0
 8005708:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      }else if(app <= (packet_dim*haudio->lower_treshold)){
 800570c:	7ee1      	ldrb	r1, [r4, #27]
 800570e:	fb06 f101 	mul.w	r1, r6, r1
 8005712:	428f      	cmp	r7, r1
        length_usb_pck -= channels*2;
 8005714:	bfdc      	itt	le
 8005716:	eba6 0348 	suble.w	r3, r6, r8, lsl #1
      haudio->rd_ptr += length_usb_pck;      
 800571a:	b29e      	uxthle	r6, r3
 800571c:	e7cb      	b.n	80056b6 <USBD_AUDIO_DataIn+0x6e>
 800571e:	bf00      	nop
 8005720:	cccccccd 	.word	0xcccccccd
 8005724:	200026f8 	.word	0x200026f8

08005728 <USBD_AUDIO_Setup>:
{
 8005728:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800572a:	780c      	ldrb	r4, [r1, #0]
  haudio = pdev->pClassData;
 800572c:	f8d0 72bc 	ldr.w	r7, [r0, #700]	; 0x2bc
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8005730:	f014 0460 	ands.w	r4, r4, #96	; 0x60
{
 8005734:	460d      	mov	r5, r1
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8005736:	d014      	beq.n	8005762 <USBD_AUDIO_Setup+0x3a>
 8005738:	2c20      	cmp	r4, #32
 800573a:	d10f      	bne.n	800575c <USBD_AUDIO_Setup+0x34>
    switch (req->bRequest)
 800573c:	784e      	ldrb	r6, [r1, #1]
 800573e:	2e01      	cmp	r6, #1
 8005740:	d047      	beq.n	80057d2 <USBD_AUDIO_Setup+0xaa>
 8005742:	f106 037f 	add.w	r3, r6, #127	; 0x7f
 8005746:	b2db      	uxtb	r3, r3
 8005748:	2b03      	cmp	r3, #3
 800574a:	4602      	mov	r2, r0
 800574c:	d85c      	bhi.n	8005808 <USBD_AUDIO_Setup+0xe0>
 800574e:	3e81      	subs	r6, #129	; 0x81
 8005750:	2e03      	cmp	r6, #3
 8005752:	d859      	bhi.n	8005808 <USBD_AUDIO_Setup+0xe0>
 8005754:	e8df f006 	tbb	[pc, r6]
 8005758:	18232b2f 	.word	0x18232b2f
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 800575c:	2400      	movs	r4, #0
}
 800575e:	4620      	mov	r0, r4
 8005760:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    switch (req->bRequest)
 8005762:	784b      	ldrb	r3, [r1, #1]
 8005764:	2b0a      	cmp	r3, #10
 8005766:	d04a      	beq.n	80057fe <USBD_AUDIO_Setup+0xd6>
 8005768:	2b0b      	cmp	r3, #11
 800576a:	d043      	beq.n	80057f4 <USBD_AUDIO_Setup+0xcc>
 800576c:	2b06      	cmp	r3, #6
 800576e:	d1f6      	bne.n	800575e <USBD_AUDIO_Setup+0x36>
      if( (req->wValue >> 8) == AUDIO_DESCRIPTOR_TYPE)
 8005770:	884b      	ldrh	r3, [r1, #2]
 8005772:	0a1b      	lsrs	r3, r3, #8
 8005774:	2b21      	cmp	r3, #33	; 0x21
 8005776:	d1f2      	bne.n	800575e <USBD_AUDIO_Setup+0x36>
        len = MIN(USB_AUDIO_DESC_SIZ , req->wLength);   
 8005778:	88ca      	ldrh	r2, [r1, #6]
        USBD_CtlSendData (pdev, 
 800577a:	4928      	ldr	r1, [pc, #160]	; (800581c <USBD_AUDIO_Setup+0xf4>)
 800577c:	2a09      	cmp	r2, #9
 800577e:	bf28      	it	cs
 8005780:	2209      	movcs	r2, #9
 8005782:	f001 fb1f 	bl	8006dc4 <USBD_CtlSendData>
 8005786:	e7ea      	b.n	800575e <USBD_AUDIO_Setup+0x36>
*/
static void AUDIO_REQ_GetResolution(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
  USBD_AUDIO_HandleTypeDef   *haudio;
  haudio = pdev->pClassData;  
  (haudio->control.data)[0] = (uint16_t)VOL_RES & 0xFF;
 8005788:	4639      	mov	r1, r7
 800578a:	2323      	movs	r3, #35	; 0x23
 800578c:	f821 3f1d 	strh.w	r3, [r1, #29]!
  (haudio->control.data)[1] = ((uint16_t)VOL_RES & 0xFF00 ) >> 8;  
  USBD_CtlSendData (pdev, 
 8005790:	4610      	mov	r0, r2
  return ret;
 8005792:	2400      	movs	r4, #0
  USBD_CtlSendData (pdev, 
 8005794:	88ea      	ldrh	r2, [r5, #6]
 8005796:	f001 fb15 	bl	8006dc4 <USBD_CtlSendData>
}
 800579a:	4620      	mov	r0, r4
 800579c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  (haudio->control.data)[0] = (uint16_t)VOL_MAX & 0xFF;
 800579e:	4639      	mov	r1, r7
 80057a0:	2400      	movs	r4, #0
 80057a2:	f821 4f1d 	strh.w	r4, [r1, #29]!
  USBD_CtlSendData (pdev, 
 80057a6:	88ea      	ldrh	r2, [r5, #6]
 80057a8:	f001 fb0c 	bl	8006dc4 <USBD_CtlSendData>
}
 80057ac:	e7d7      	b.n	800575e <USBD_AUDIO_Setup+0x36>
  (haudio->control.data)[0] = (uint16_t)VOL_MIN & 0xFF;
 80057ae:	4639      	mov	r1, r7
 80057b0:	f64d 33e0 	movw	r3, #56288	; 0xdbe0
 80057b4:	e7ea      	b.n	800578c <USBD_AUDIO_Setup+0x64>
static void AUDIO_REQ_GetCurrent(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{  
  USBD_AUDIO_HandleTypeDef   *haudio;
  haudio = pdev->pClassData;
  
  (haudio->control.data)[0] = (uint16_t)VOL_CUR & 0xFF;
 80057b6:	4b1a      	ldr	r3, [pc, #104]	; (8005820 <USBD_AUDIO_Setup+0xf8>)
 80057b8:	f9b3 3076 	ldrsh.w	r3, [r3, #118]	; 0x76
 80057bc:	777b      	strb	r3, [r7, #29]
  (haudio->control.data)[1] = ((uint16_t)VOL_CUR & 0xFF00 ) >> 8;
 80057be:	f3c3 2307 	ubfx	r3, r3, #8, #8
 80057c2:	77bb      	strb	r3, [r7, #30]
  
  USBD_CtlSendData (pdev, 
 80057c4:	88ca      	ldrh	r2, [r1, #6]
 80057c6:	f107 011d 	add.w	r1, r7, #29
 80057ca:	f001 fafb 	bl	8006dc4 <USBD_CtlSendData>
  return ret;
 80057ce:	2400      	movs	r4, #0
                    haudio->control.data,
                    req->wLength);  
}
 80057d0:	e7c5      	b.n	800575e <USBD_AUDIO_Setup+0x36>
*/
static void AUDIO_REQ_SetCurrent(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{ 
  USBD_AUDIO_HandleTypeDef   *haudio;
  haudio = pdev->pClassData;  
  if (req->wLength)
 80057d2:	88cc      	ldrh	r4, [r1, #6]
 80057d4:	2c00      	cmp	r4, #0
 80057d6:	d0c2      	beq.n	800575e <USBD_AUDIO_Setup+0x36>
  {
    /* Prepare the reception of the buffer over EP0 */
    USBD_CtlPrepareRx (pdev,
 80057d8:	4622      	mov	r2, r4
 80057da:	4912      	ldr	r1, [pc, #72]	; (8005824 <USBD_AUDIO_Setup+0xfc>)
 80057dc:	f001 fb08 	bl	8006df0 <USBD_CtlPrepareRx>
                       (uint8_t *)&VOL_CUR,
                       req->wLength);
    
    haudio->control.cmd = AUDIO_REQ_SET_CUR;     /* Set the request value */
 80057e0:	773e      	strb	r6, [r7, #28]
    haudio->control.len = req->wLength;          /* Set the request data length */
 80057e2:	88eb      	ldrh	r3, [r5, #6]
 80057e4:	f887 305d 	strb.w	r3, [r7, #93]	; 0x5d
    haudio->control.unit = HIBYTE(req->wIndex);  /* Set the request target unit */
 80057e8:	88ab      	ldrh	r3, [r5, #4]
 80057ea:	0a1b      	lsrs	r3, r3, #8
  return ret;
 80057ec:	2400      	movs	r4, #0
    haudio->control.unit = HIBYTE(req->wIndex);  /* Set the request target unit */
 80057ee:	f887 305e 	strb.w	r3, [r7, #94]	; 0x5e
 80057f2:	e7b4      	b.n	800575e <USBD_AUDIO_Setup+0x36>
      if ((uint8_t)(req->wValue) < USBD_MAX_NUM_INTERFACES)
 80057f4:	788b      	ldrb	r3, [r1, #2]
 80057f6:	2b01      	cmp	r3, #1
 80057f8:	d80c      	bhi.n	8005814 <USBD_AUDIO_Setup+0xec>
        haudio->alt_setting = (uint8_t)(req->wValue);
 80057fa:	603b      	str	r3, [r7, #0]
 80057fc:	e7af      	b.n	800575e <USBD_AUDIO_Setup+0x36>
                        (uint8_t *)haudio->alt_setting,
 80057fe:	6839      	ldr	r1, [r7, #0]
      USBD_CtlSendData (pdev,
 8005800:	2201      	movs	r2, #1
 8005802:	f001 fadf 	bl	8006dc4 <USBD_CtlSendData>
      break;
 8005806:	e7aa      	b.n	800575e <USBD_AUDIO_Setup+0x36>
      USBD_CtlError (pdev, req);
 8005808:	4629      	mov	r1, r5
 800580a:	4610      	mov	r0, r2
 800580c:	f001 faa4 	bl	8006d58 <USBD_CtlError>
      return USBD_FAIL;
 8005810:	2403      	movs	r4, #3
 8005812:	e7a4      	b.n	800575e <USBD_AUDIO_Setup+0x36>
        USBD_CtlError (pdev, req);
 8005814:	f001 faa0 	bl	8006d58 <USBD_CtlError>
 8005818:	e7a1      	b.n	800575e <USBD_AUDIO_Setup+0x36>
 800581a:	bf00      	nop
 800581c:	20002692 	.word	0x20002692
 8005820:	20002680 	.word	0x20002680
 8005824:	200026f6 	.word	0x200026f6

08005828 <USBD_AUDIO_DeInit>:
{
 8005828:	b510      	push	{r4, lr}
 800582a:	4604      	mov	r4, r0
  USBD_LL_CloseEP(pdev,AUDIO_IN_EP);  
 800582c:	2181      	movs	r1, #129	; 0x81
 800582e:	f7fb ff8d 	bl	800174c <USBD_LL_CloseEP>
  if(pdev->pClassData != NULL)
 8005832:	f8d4 32bc 	ldr.w	r3, [r4, #700]	; 0x2bc
 8005836:	b163      	cbz	r3, 8005852 <USBD_AUDIO_DeInit+0x2a>
    ((USBD_AUDIO_ItfTypeDef *)pdev->pUserData[pdev->classId])->DeInit(0);
 8005838:	f8d4 32d4 	ldr.w	r3, [r4, #724]	; 0x2d4
 800583c:	eb04 0483 	add.w	r4, r4, r3, lsl #2
 8005840:	2000      	movs	r0, #0
 8005842:	f8d4 32c4 	ldr.w	r3, [r4, #708]	; 0x2c4
 8005846:	685b      	ldr	r3, [r3, #4]
 8005848:	4798      	blx	r3
    haudioInstance.state = STATE_USB_WAITING_FOR_INIT; 
 800584a:	4b03      	ldr	r3, [pc, #12]	; (8005858 <USBD_AUDIO_DeInit+0x30>)
 800584c:	2200      	movs	r2, #0
 800584e:	f883 220c 	strb.w	r2, [r3, #524]	; 0x20c
}
 8005852:	2000      	movs	r0, #0
 8005854:	bd10      	pop	{r4, pc}
 8005856:	bf00      	nop
 8005858:	20002680 	.word	0x20002680

0800585c <USBD_AUDIO_Init>:
{
 800585c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if(haudioInstance.state!=STATE_USB_WAITING_FOR_INIT)
 800585e:	4c20      	ldr	r4, [pc, #128]	; (80058e0 <USBD_AUDIO_Init+0x84>)
 8005860:	f894 620c 	ldrb.w	r6, [r4, #524]	; 0x20c
 8005864:	bbc6      	cbnz	r6, 80058d8 <USBD_AUDIO_Init+0x7c>
  uint16_t packet_dim = haudio->paketDimension;
 8005866:	f8b4 720a 	ldrh.w	r7, [r4, #522]	; 0x20a
  uint16_t wr_rd_offset = (AUDIO_IN_PACKET_NUM/2) * haudio->dataAmount / haudio->paketDimension;
 800586a:	f8b4 3208 	ldrh.w	r3, [r4, #520]	; 0x208
  haudio->rd_ptr = 0;
 800586e:	f8a4 620e 	strh.w	r6, [r4, #526]	; 0x20e
  uint16_t wr_rd_offset = (AUDIO_IN_PACKET_NUM/2) * haudio->dataAmount / haudio->paketDimension;
 8005872:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8005876:	fbb3 f3f7 	udiv	r3, r3, r7
  haudio->wr_ptr=wr_rd_offset * packet_dim;
 800587a:	fb13 f307 	smulbb	r3, r3, r7
 800587e:	f8a4 3210 	strh.w	r3, [r4, #528]	; 0x210
  ((USBD_AUDIO_ItfTypeDef *)pdev->pUserData[pdev->classId])->Init(haudio->frequency,0,haudio->channels);
 8005882:	f8d0 32d4 	ldr.w	r3, [r0, #724]	; 0x2d4
  haudio->timeout = 0;
 8005886:	f8a4 6204 	strh.w	r6, [r4, #516]	; 0x204
  ((USBD_AUDIO_ItfTypeDef *)pdev->pUserData[pdev->classId])->Init(haudio->frequency,0,haudio->channels);
 800588a:	eb00 0383 	add.w	r3, r0, r3, lsl #2
  pdev->pClassData = &haudioInstance;
 800588e:	f504 72fc 	add.w	r2, r4, #504	; 0x1f8
  ((USBD_AUDIO_ItfTypeDef *)pdev->pUserData[pdev->classId])->Init(haudio->frequency,0,haudio->channels);
 8005892:	f8d3 32c4 	ldr.w	r3, [r3, #708]	; 0x2c4
  pdev->pClassData = &haudioInstance;
 8005896:	f8c0 22bc 	str.w	r2, [r0, #700]	; 0x2bc
  ((USBD_AUDIO_ItfTypeDef *)pdev->pUserData[pdev->classId])->Init(haudio->frequency,0,haudio->channels);
 800589a:	4605      	mov	r5, r0
 800589c:	f894 21fc 	ldrb.w	r2, [r4, #508]	; 0x1fc
 80058a0:	681b      	ldr	r3, [r3, #0]
 80058a2:	f8d4 0200 	ldr.w	r0, [r4, #512]	; 0x200
 80058a6:	4631      	mov	r1, r6
 80058a8:	4798      	blx	r3
  USBD_LL_OpenEP(pdev,
 80058aa:	f44f 7348 	mov.w	r3, #800	; 0x320
 80058ae:	2201      	movs	r2, #1
 80058b0:	2181      	movs	r1, #129	; 0x81
 80058b2:	4628      	mov	r0, r5
 80058b4:	f7fb ff40 	bl	8001738 <USBD_LL_OpenEP>
  USBD_LL_FlushEP(pdev, AUDIO_IN_EP);
 80058b8:	2181      	movs	r1, #129	; 0x81
 80058ba:	4628      	mov	r0, r5
 80058bc:	f7fb ff4e 	bl	800175c <USBD_LL_FlushEP>
  USBD_LL_Transmit(pdev, AUDIO_IN_EP,
 80058c0:	463b      	mov	r3, r7
 80058c2:	f104 0278 	add.w	r2, r4, #120	; 0x78
 80058c6:	4628      	mov	r0, r5
 80058c8:	2181      	movs	r1, #129	; 0x81
 80058ca:	f7fb ff7b 	bl	80017c4 <USBD_LL_Transmit>
  haudio->state=STATE_USB_IDLE;
 80058ce:	2301      	movs	r3, #1
 80058d0:	f884 320c 	strb.w	r3, [r4, #524]	; 0x20c
}
 80058d4:	4630      	mov	r0, r6
 80058d6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return USBD_FAIL; 
 80058d8:	2603      	movs	r6, #3
}
 80058da:	4630      	mov	r0, r6
 80058dc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80058de:	bf00      	nop
 80058e0:	20002680 	.word	0x20002680

080058e4 <USBD_AUDIO_IsoINIncomplete>:
 80058e4:	2000      	movs	r0, #0
 80058e6:	4770      	bx	lr

080058e8 <USBD_AUDIO_SOF>:
 80058e8:	2000      	movs	r0, #0
 80058ea:	4770      	bx	lr

080058ec <USBD_AUDIO_IsoOutIncomplete>:
 80058ec:	2000      	movs	r0, #0
 80058ee:	4770      	bx	lr

080058f0 <USBD_AUDIO_Data_Transfer>:
{
  
  USBD_AUDIO_HandleTypeDef   *haudio;
  haudio = (USBD_AUDIO_HandleTypeDef *)pdev->pClassData;
  
  if(haudioInstance.state==STATE_USB_WAITING_FOR_INIT){    
 80058f0:	4b3c      	ldr	r3, [pc, #240]	; (80059e4 <USBD_AUDIO_Data_Transfer+0xf4>)
 80058f2:	f893 320c 	ldrb.w	r3, [r3, #524]	; 0x20c
 80058f6:	2b00      	cmp	r3, #0
 80058f8:	d03d      	beq.n	8005976 <USBD_AUDIO_Data_Transfer+0x86>
{
 80058fa:	b570      	push	{r4, r5, r6, lr}
  haudio = (USBD_AUDIO_HandleTypeDef *)pdev->pClassData;
 80058fc:	f8d0 42bc 	ldr.w	r4, [r0, #700]	; 0x2bc
  uint16_t dataAmount = PCMSamples * 2; /*Bytes*/
  uint16_t true_dim = haudio->buffer_length;
  uint16_t current_data_Amount = haudio->dataAmount;
  uint16_t packet_dim = haudio->paketDimension;
  
  if(haudio->state==STATE_USB_REQUESTS_STARTED  || current_data_Amount!=dataAmount){   
 8005900:	7d23      	ldrb	r3, [r4, #20]
  uint16_t dataAmount = PCMSamples * 2; /*Bytes*/
 8005902:	0052      	lsls	r2, r2, #1
  if(haudio->state==STATE_USB_REQUESTS_STARTED  || current_data_Amount!=dataAmount){   
 8005904:	2b02      	cmp	r3, #2
{
 8005906:	b082      	sub	sp, #8
  uint16_t dataAmount = PCMSamples * 2; /*Bytes*/
 8005908:	b295      	uxth	r5, r2
  if(haudio->state==STATE_USB_REQUESTS_STARTED  || current_data_Amount!=dataAmount){   
 800590a:	d002      	beq.n	8005912 <USBD_AUDIO_Data_Transfer+0x22>
 800590c:	8a22      	ldrh	r2, [r4, #16]
 800590e:	42aa      	cmp	r2, r5
 8005910:	d033      	beq.n	800597a <USBD_AUDIO_Data_Transfer+0x8a>
  uint16_t packet_dim = haudio->paketDimension;
 8005912:	8a60      	ldrh	r0, [r4, #18]
    uint16_t wr_rd_offset = (AUDIO_IN_PACKET_NUM/2) * dataAmount / packet_dim; 
    haudio->wr_ptr=wr_rd_offset * packet_dim;
    haudio->rd_ptr = 0;
    haudio->upper_treshold = wr_rd_offset + 1;
    haudio->lower_treshold = wr_rd_offset - 1;
    haudio->buffer_length = (packet_dim * (dataAmount / packet_dim) * AUDIO_IN_PACKET_NUM);
 8005914:	fbb5 f3f0 	udiv	r3, r5, r0
 8005918:	fb13 f300 	smulbb	r3, r3, r0
 800591c:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    uint16_t wr_rd_offset = (AUDIO_IN_PACKET_NUM/2) * dataAmount / packet_dim; 
 8005920:	eb05 0145 	add.w	r1, r5, r5, lsl #1
 8005924:	fbb1 f1f0 	udiv	r1, r1, r0
    haudio->wr_ptr=wr_rd_offset * packet_dim;
 8005928:	fb11 f000 	smulbb	r0, r1, r0
    haudio->buffer_length = (packet_dim * (dataAmount / packet_dim) * AUDIO_IN_PACKET_NUM);
 800592c:	005a      	lsls	r2, r3, #1
    haudio->upper_treshold = wr_rd_offset + 1;
 800592e:	b2c9      	uxtb	r1, r1
    haudio->rd_ptr = 0;
 8005930:	2300      	movs	r3, #0
    haudio->wr_ptr=wr_rd_offset * packet_dim;
 8005932:	8320      	strh	r0, [r4, #24]
    
    /*Memory allocation for data buffer, depending (also) on data amount passed to the transfer function*/
    if(haudio->buffer != NULL)
 8005934:	6e20      	ldr	r0, [r4, #96]	; 0x60
    haudio->rd_ptr = 0;
 8005936:	82e3      	strh	r3, [r4, #22]
    haudio->buffer_length = (packet_dim * (dataAmount / packet_dim) * AUDIO_IN_PACKET_NUM);
 8005938:	b292      	uxth	r2, r2
    haudio->upper_treshold = wr_rd_offset + 1;
 800593a:	1c4b      	adds	r3, r1, #1
    haudio->lower_treshold = wr_rd_offset - 1;
 800593c:	3901      	subs	r1, #1
    uint16_t wr_rd_offset = (AUDIO_IN_PACKET_NUM/2) * dataAmount / packet_dim; 
 800593e:	46ac      	mov	ip, r5
    haudio->dataAmount=dataAmount;                  
 8005940:	8225      	strh	r5, [r4, #16]
    haudio->upper_treshold = wr_rd_offset + 1;
 8005942:	76a3      	strb	r3, [r4, #26]
    haudio->lower_treshold = wr_rd_offset - 1;
 8005944:	76e1      	strb	r1, [r4, #27]
    haudio->buffer_length = (packet_dim * (dataAmount / packet_dim) * AUDIO_IN_PACKET_NUM);
 8005946:	81e2      	strh	r2, [r4, #14]
    if(haudio->buffer != NULL)
 8005948:	b120      	cbz	r0, 8005954 <USBD_AUDIO_Data_Transfer+0x64>
    {
      USBD_free(haudio->buffer);      
 800594a:	f003 fb47 	bl	8008fdc <free>
    }
    haudio->buffer = USBD_malloc(haudio->buffer_length + haudio->dataAmount);
 800594e:	89e2      	ldrh	r2, [r4, #14]
 8005950:	f8b4 c010 	ldrh.w	ip, [r4, #16]
 8005954:	4462      	add	r2, ip
 8005956:	4610      	mov	r0, r2
 8005958:	9201      	str	r2, [sp, #4]
 800595a:	f003 fb37 	bl	8008fcc <malloc>
 800595e:	6620      	str	r0, [r4, #96]	; 0x60
    if(haudio->buffer == NULL)
 8005960:	2800      	cmp	r0, #0
 8005962:	d03d      	beq.n	80059e0 <USBD_AUDIO_Data_Transfer+0xf0>
    {
      return USBD_FAIL;       
    }
    memset(haudio->buffer,0,(haudio->buffer_length + haudio->dataAmount));
 8005964:	9a01      	ldr	r2, [sp, #4]
 8005966:	2100      	movs	r1, #0
 8005968:	f003 fb4e 	bl	8009008 <memset>
    haudio->state=STATE_USB_BUFFER_WRITE_STARTED;
 800596c:	2303      	movs	r3, #3
 800596e:	7523      	strb	r3, [r4, #20]
    haudio->wr_ptr = haudio->wr_ptr % (true_dim);    
    if((haudio->wr_ptr-dataAmount) == 0){
      memcpy((uint8_t *)(((uint8_t *)haudio->buffer)+true_dim),(uint8_t *)haudio->buffer, dataAmount);
    }
  }
  return USBD_OK;  
 8005970:	2000      	movs	r0, #0
}
 8005972:	b002      	add	sp, #8
 8005974:	bd70      	pop	{r4, r5, r6, pc}
    return USBD_BUSY;    
 8005976:	2001      	movs	r0, #1
}
 8005978:	4770      	bx	lr
  }else if(haudio->state==STATE_USB_BUFFER_WRITE_STARTED){
 800597a:	2b03      	cmp	r3, #3
 800597c:	d002      	beq.n	8005984 <USBD_AUDIO_Data_Transfer+0x94>
  return USBD_OK;  
 800597e:	2000      	movs	r0, #0
}
 8005980:	b002      	add	sp, #8
 8005982:	bd70      	pop	{r4, r5, r6, pc}
    if(haudio->timeout++==TIMEOUT_VALUE){
 8005984:	89a3      	ldrh	r3, [r4, #12]
  uint16_t true_dim = haudio->buffer_length;
 8005986:	89e6      	ldrh	r6, [r4, #14]
    if(haudio->timeout++==TIMEOUT_VALUE){
 8005988:	1c5a      	adds	r2, r3, #1
 800598a:	b21b      	sxth	r3, r3
 800598c:	b212      	sxth	r2, r2
 800598e:	2bc8      	cmp	r3, #200	; 0xc8
 8005990:	81a2      	strh	r2, [r4, #12]
 8005992:	d016      	beq.n	80059c2 <USBD_AUDIO_Data_Transfer+0xd2>
    memcpy((uint8_t * )&haudio->buffer[haudio->wr_ptr], (uint8_t *)(audioData), dataAmount);    
 8005994:	8b23      	ldrh	r3, [r4, #24]
 8005996:	6e20      	ldr	r0, [r4, #96]	; 0x60
 8005998:	462a      	mov	r2, r5
 800599a:	4418      	add	r0, r3
 800599c:	f003 fb26 	bl	8008fec <memcpy>
    haudio->wr_ptr += dataAmount;
 80059a0:	8b23      	ldrh	r3, [r4, #24]
 80059a2:	442b      	add	r3, r5
    haudio->wr_ptr = haudio->wr_ptr % (true_dim);    
 80059a4:	b29b      	uxth	r3, r3
 80059a6:	fbb3 f2f6 	udiv	r2, r3, r6
 80059aa:	fb06 3312 	mls	r3, r6, r2, r3
 80059ae:	b29b      	uxth	r3, r3
    if((haudio->wr_ptr-dataAmount) == 0){
 80059b0:	42ab      	cmp	r3, r5
    haudio->wr_ptr = haudio->wr_ptr % (true_dim);    
 80059b2:	8323      	strh	r3, [r4, #24]
    if((haudio->wr_ptr-dataAmount) == 0){
 80059b4:	d1e3      	bne.n	800597e <USBD_AUDIO_Data_Transfer+0x8e>
      memcpy((uint8_t *)(((uint8_t *)haudio->buffer)+true_dim),(uint8_t *)haudio->buffer, dataAmount);
 80059b6:	6e21      	ldr	r1, [r4, #96]	; 0x60
 80059b8:	462a      	mov	r2, r5
 80059ba:	1988      	adds	r0, r1, r6
 80059bc:	f003 fb16 	bl	8008fec <memcpy>
 80059c0:	e7dd      	b.n	800597e <USBD_AUDIO_Data_Transfer+0x8e>
      haudio->state=STATE_USB_IDLE;
 80059c2:	2301      	movs	r3, #1
 80059c4:	7523      	strb	r3, [r4, #20]
      ((USBD_AUDIO_ItfTypeDef *)pdev->pUserData[pdev->classId])->Stop();   
 80059c6:	f8d0 32d4 	ldr.w	r3, [r0, #724]	; 0x2d4
 80059ca:	9101      	str	r1, [sp, #4]
 80059cc:	eb00 0083 	add.w	r0, r0, r3, lsl #2
 80059d0:	f8d0 32c4 	ldr.w	r3, [r0, #708]	; 0x2c4
 80059d4:	695b      	ldr	r3, [r3, #20]
 80059d6:	4798      	blx	r3
     haudio->timeout=0;
 80059d8:	2300      	movs	r3, #0
 80059da:	9901      	ldr	r1, [sp, #4]
 80059dc:	81a3      	strh	r3, [r4, #12]
 80059de:	e7d9      	b.n	8005994 <USBD_AUDIO_Data_Transfer+0xa4>
      return USBD_FAIL;       
 80059e0:	2003      	movs	r0, #3
 80059e2:	e7c6      	b.n	8005972 <USBD_AUDIO_Data_Transfer+0x82>
 80059e4:	20002680 	.word	0x20002680

080059e8 <USBD_AUDIO_RegisterInterface>:
* @retval status
*/
uint8_t  USBD_AUDIO_RegisterInterface  (USBD_HandleTypeDef   *pdev, 
                                        USBD_AUDIO_ItfTypeDef *fops)
{
  if(fops != NULL)
 80059e8:	b109      	cbz	r1, 80059ee <USBD_AUDIO_RegisterInterface+0x6>
  {
    pdev->pUserData[0]= fops;
 80059ea:	f8c0 12c4 	str.w	r1, [r0, #708]	; 0x2c4
  }
  return 0;}
 80059ee:	2000      	movs	r0, #0
 80059f0:	4770      	bx	lr
 80059f2:	bf00      	nop

080059f4 <USBD_AUDIO_Init_Microphone_Descriptor>:
*/
void USBD_AUDIO_Init_Microphone_Descriptor(USBD_HandleTypeDef   *pdev, uint32_t samplingFrequency, uint8_t Channels)
{
  uint16_t index;
  uint8_t AUDIO_CONTROLS;   
  USBD_AUDIO_CfgDesc[0] = 0x09;                                                /* bLength */
 80059f4:	4b5f      	ldr	r3, [pc, #380]	; (8005b74 <USBD_AUDIO_Init_Microphone_Descriptor+0x180>)
{
 80059f6:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  USBD_AUDIO_CfgDesc[1] = 0x02;                                                /* bDescriptorType */
  USBD_AUDIO_CfgDesc[2] = ((USB_AUDIO_CONFIG_DESC_SIZ+Channels-1)&0xff);       /* wTotalLength */
 80059fa:	f102 006c 	add.w	r0, r2, #108	; 0x6c
  USBD_AUDIO_CfgDesc[0] = 0x09;                                                /* bLength */
 80059fe:	f240 2409 	movw	r4, #521	; 0x209
  USBD_AUDIO_CfgDesc[3] = ((USB_AUDIO_CONFIG_DESC_SIZ+Channels-1)>>8);
  USBD_AUDIO_CfgDesc[4] = 0x02;                                                /* bNumInterfaces */
  USBD_AUDIO_CfgDesc[5] = 0x01;                                                /* bConfigurationValue */
  USBD_AUDIO_CfgDesc[6] = 0x00;                                                /* iConfiguration */
  USBD_AUDIO_CfgDesc[7] = 0x80;                                                /* bmAttributes  BUS Powered*/
  USBD_AUDIO_CfgDesc[8] = 0x32;                                                /* bMaxPower = 100 mA*/   
 8005a02:	f8df e184 	ldr.w	lr, [pc, #388]	; 8005b88 <USBD_AUDIO_Init_Microphone_Descriptor+0x194>
  USBD_AUDIO_CfgDesc[0] = 0x09;                                                /* bLength */
 8005a06:	801c      	strh	r4, [r3, #0]
  USBD_AUDIO_CfgDesc[2] = ((USB_AUDIO_CONFIG_DESC_SIZ+Channels-1)&0xff);       /* wTotalLength */
 8005a08:	7098      	strb	r0, [r3, #2]
  USBD_AUDIO_CfgDesc[3] = ((USB_AUDIO_CONFIG_DESC_SIZ+Channels-1)>>8);
 8005a0a:	1204      	asrs	r4, r0, #8
  USBD_AUDIO_CfgDesc[8] = 0x32;                                                /* bMaxPower = 100 mA*/   
 8005a0c:	485a      	ldr	r0, [pc, #360]	; (8005b78 <USBD_AUDIO_Init_Microphone_Descriptor+0x184>)
  USBD_AUDIO_CfgDesc[11] = 0x00;                                               /* bInterfaceNumber */
  USBD_AUDIO_CfgDesc[12] = 0x00;                                               /* bAlternateSetting */
  USBD_AUDIO_CfgDesc[13] = 0x00;                                               /* bNumEndpoints */
  USBD_AUDIO_CfgDesc[14] = USB_DEVICE_CLASS_AUDIO;                             /* bInterfaceClass */
  USBD_AUDIO_CfgDesc[15] = AUDIO_SUBCLASS_AUDIOCONTROL;                        /* bInterfaceSubClass */
  USBD_AUDIO_CfgDesc[16] = AUDIO_PROTOCOL_UNDEFINED;                           /* bInterfaceProtocol */
 8005a0e:	f8df 817c 	ldr.w	r8, [pc, #380]	; 8005b8c <USBD_AUDIO_Init_Microphone_Descriptor+0x198>
  USBD_AUDIO_CfgDesc[3] = ((USB_AUDIO_CONFIG_DESC_SIZ+Channels-1)>>8);
 8005a12:	70dc      	strb	r4, [r3, #3]
  USBD_AUDIO_CfgDesc[8] = 0x32;                                                /* bMaxPower = 100 mA*/   
 8005a14:	e9c3 e001 	strd	lr, r0, [r3, #4]
  USBD_AUDIO_CfgDesc[16] = AUDIO_PROTOCOL_UNDEFINED;                           /* bInterfaceProtocol */
 8005a18:	4858      	ldr	r0, [pc, #352]	; (8005b7c <USBD_AUDIO_Init_Microphone_Descriptor+0x188>)
  USBD_AUDIO_CfgDesc[29] = AUDIO_CONTROL_INPUT_TERMINAL;                       /* bDescriptorSubtype */
  USBD_AUDIO_CfgDesc[30] = 0x01;                                               /* bTerminalID */
  USBD_AUDIO_CfgDesc[31] = 0x01;                                               /* wTerminalType AUDIO_TERMINAL_USB_MICROPHONE   0x0201 */
  USBD_AUDIO_CfgDesc[32] = 0x02;
  USBD_AUDIO_CfgDesc[33] = 0x00;                                               /* bAssocTerminal */
  USBD_AUDIO_CfgDesc[34] = Channels;                                           /* bNrChannels */   
 8005a1a:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
  USBD_AUDIO_CfgDesc[16] = AUDIO_PROTOCOL_UNDEFINED;                           /* bInterfaceProtocol */
 8005a1e:	e9c3 8003 	strd	r8, r0, [r3, #12]
  USBD_AUDIO_CfgDesc[23] = 0x25+Channels;                                      /* wTotalLength = 37+AUDIO_CHANNELS*/
 8005a22:	f102 0025 	add.w	r0, r2, #37	; 0x25
 8005a26:	75d8      	strb	r0, [r3, #23]
  USBD_AUDIO_CfgDesc[24] = 0x00;
 8005a28:	4855      	ldr	r0, [pc, #340]	; (8005b80 <USBD_AUDIO_Init_Microphone_Descriptor+0x18c>)
 8005a2a:	6198      	str	r0, [r3, #24]
  USBD_AUDIO_CfgDesc[28] = AUDIO_INTERFACE_DESCRIPTOR_TYPE;                    /* bDescriptorType */
 8005a2c:	f100 4075 	add.w	r0, r0, #4110417920	; 0xf5000000
 8005a30:	f500 7092 	add.w	r0, r0, #292	; 0x124
 8005a34:	61d8      	str	r0, [r3, #28]
  USBD_AUDIO_CfgDesc[32] = 0x02;
 8005a36:	2002      	movs	r0, #2
  USBD_AUDIO_CfgDesc[20] = AUDIO_CONTROL_HEADER;                               /* bDescriptorSubtype */
 8005a38:	2401      	movs	r4, #1
  if(Channels != 2)
 8005a3a:	4282      	cmp	r2, r0
{
 8005a3c:	b0bd      	sub	sp, #244	; 0xf4
  USBD_AUDIO_CfgDesc[20] = AUDIO_CONTROL_HEADER;                               /* bDescriptorSubtype */
 8005a3e:	829c      	strh	r4, [r3, #20]
  USBD_AUDIO_CfgDesc[22] = 0x01;
 8005a40:	759c      	strb	r4, [r3, #22]
  USBD_AUDIO_CfgDesc[32] = 0x02;
 8005a42:	8418      	strh	r0, [r3, #32]
{
 8005a44:	468b      	mov	fp, r1
  if(Channels != 2)
 8005a46:	f000 8219 	beq.w	8005e7c <USBD_AUDIO_Init_Microphone_Descriptor+0x488>
  }   
  USBD_AUDIO_CfgDesc[37] = 0x00;                                               /* iChannelNames */
  USBD_AUDIO_CfgDesc[38] = 0x00;                                               /* iTerminal */   
  /* USB Microphone Audio Feature Unit Descriptor */
  USBD_AUDIO_CfgDesc[39] = 0x07+Channels+1;                                    /* bLength */
  USBD_AUDIO_CfgDesc[40] = AUDIO_INTERFACE_DESCRIPTOR_TYPE;                    /* bDescriptorType */
 8005a4a:	494e      	ldr	r1, [pc, #312]	; (8005b84 <USBD_AUDIO_Init_Microphone_Descriptor+0x190>)
 8005a4c:	6299      	str	r1, [r3, #40]	; 0x28
    USBD_AUDIO_CfgDesc[35] = 0x00;                                             /* wChannelConfig 0x0000  Mono */
 8005a4e:	2100      	movs	r1, #0
 8005a50:	f8c3 1023 	str.w	r1, [r3, #35]	; 0x23
  USBD_AUDIO_CfgDesc[41] = AUDIO_CONTROL_FEATURE_UNIT;                         /* bDescriptorSubtype */
  USBD_AUDIO_CfgDesc[42] = 0x02;                                               /* bUnitID */
  USBD_AUDIO_CfgDesc[43] = 0x01;                                               /* bSourceID */
  USBD_AUDIO_CfgDesc[44] = 0x01;                                               /* bControlSize */   
  index = 47;   
  if(Channels == 1)
 8005a54:	42a2      	cmp	r2, r4
  USBD_AUDIO_CfgDesc[39] = 0x07+Channels+1;                                    /* bLength */
 8005a56:	f102 0108 	add.w	r1, r2, #8
  USBD_AUDIO_CfgDesc[44] = 0x01;                                               /* bControlSize */   
 8005a5a:	f883 402c 	strb.w	r4, [r3, #44]	; 0x2c
  USBD_AUDIO_CfgDesc[39] = 0x07+Channels+1;                                    /* bLength */
 8005a5e:	f883 1027 	strb.w	r1, [r3, #39]	; 0x27
  if(Channels == 1)
 8005a62:	f040 8095 	bne.w	8005b90 <USBD_AUDIO_Init_Microphone_Descriptor+0x19c>
  {
    AUDIO_CONTROLS = (0x02);     
    USBD_AUDIO_CfgDesc[45] = AUDIO_CONTROLS;
 8005a66:	276c      	movs	r7, #108	; 0x6c
 8005a68:	216b      	movs	r1, #107	; 0x6b
 8005a6a:	e9cd 7117 	strd	r7, r1, [sp, #92]	; 0x5c
 8005a6e:	f04f 0c6a 	mov.w	ip, #106	; 0x6a
 8005a72:	2169      	movs	r1, #105	; 0x69
 8005a74:	e9cd 1c19 	strd	r1, ip, [sp, #100]	; 0x64
 8005a78:	f04f 0e68 	mov.w	lr, #104	; 0x68
 8005a7c:	2167      	movs	r1, #103	; 0x67
 8005a7e:	e9cd 1e1b 	strd	r1, lr, [sp, #108]	; 0x6c
 8005a82:	f04f 0866 	mov.w	r8, #102	; 0x66
 8005a86:	2165      	movs	r1, #101	; 0x65
 8005a88:	e9cd 181d 	strd	r1, r8, [sp, #116]	; 0x74
 8005a8c:	f04f 0964 	mov.w	r9, #100	; 0x64
 8005a90:	2163      	movs	r1, #99	; 0x63
 8005a92:	e9cd 191f 	strd	r1, r9, [sp, #124]	; 0x7c
 8005a96:	f04f 0a62 	mov.w	sl, #98	; 0x62
 8005a9a:	2161      	movs	r1, #97	; 0x61
 8005a9c:	e9cd 1a21 	strd	r1, sl, [sp, #132]	; 0x84
 8005aa0:	f8a3 002d 	strh.w	r0, [r3, #45]	; 0x2d
 8005aa4:	215f      	movs	r1, #95	; 0x5f
 8005aa6:	2060      	movs	r0, #96	; 0x60
 8005aa8:	e9cd 1023 	strd	r1, r0, [sp, #140]	; 0x8c
 8005aac:	215e      	movs	r1, #94	; 0x5e
 8005aae:	910c      	str	r1, [sp, #48]	; 0x30
 8005ab0:	215d      	movs	r1, #93	; 0x5d
 8005ab2:	9131      	str	r1, [sp, #196]	; 0xc4
 8005ab4:	265c      	movs	r6, #92	; 0x5c
 8005ab6:	215b      	movs	r1, #91	; 0x5b
 8005ab8:	e9cd 612f 	strd	r6, r1, [sp, #188]	; 0xbc
 8005abc:	215a      	movs	r1, #90	; 0x5a
 8005abe:	9106      	str	r1, [sp, #24]
 8005ac0:	2159      	movs	r1, #89	; 0x59
 8005ac2:	910d      	str	r1, [sp, #52]	; 0x34
 8005ac4:	2158      	movs	r1, #88	; 0x58
 8005ac6:	9107      	str	r1, [sp, #28]
 8005ac8:	2157      	movs	r1, #87	; 0x57
 8005aca:	910e      	str	r1, [sp, #56]	; 0x38
 8005acc:	2156      	movs	r1, #86	; 0x56
 8005ace:	9108      	str	r1, [sp, #32]
 8005ad0:	2155      	movs	r1, #85	; 0x55
 8005ad2:	910f      	str	r1, [sp, #60]	; 0x3c
 8005ad4:	2154      	movs	r1, #84	; 0x54
 8005ad6:	9109      	str	r1, [sp, #36]	; 0x24
 8005ad8:	2153      	movs	r1, #83	; 0x53
 8005ada:	9110      	str	r1, [sp, #64]	; 0x40
 8005adc:	2152      	movs	r1, #82	; 0x52
 8005ade:	910a      	str	r1, [sp, #40]	; 0x28
 8005ae0:	2151      	movs	r1, #81	; 0x51
 8005ae2:	9111      	str	r1, [sp, #68]	; 0x44
 8005ae4:	2150      	movs	r1, #80	; 0x50
 8005ae6:	910b      	str	r1, [sp, #44]	; 0x2c
 8005ae8:	214f      	movs	r1, #79	; 0x4f
 8005aea:	9112      	str	r1, [sp, #72]	; 0x48
 8005aec:	f04f 0e4e 	mov.w	lr, #78	; 0x4e
 8005af0:	214d      	movs	r1, #77	; 0x4d
 8005af2:	e9cd e12d 	strd	lr, r1, [sp, #180]	; 0xb4
 8005af6:	f04f 084c 	mov.w	r8, #76	; 0x4c
 8005afa:	214b      	movs	r1, #75	; 0x4b
 8005afc:	e9cd 812b 	strd	r8, r1, [sp, #172]	; 0xac
 8005b00:	f04f 094a 	mov.w	r9, #74	; 0x4a
 8005b04:	2149      	movs	r1, #73	; 0x49
 8005b06:	f04f 0a48 	mov.w	sl, #72	; 0x48
 8005b0a:	e9cd 9129 	strd	r9, r1, [sp, #164]	; 0xa4
 8005b0e:	2147      	movs	r1, #71	; 0x47
 8005b10:	e9cd a127 	strd	sl, r1, [sp, #156]	; 0x9c
 8005b14:	2046      	movs	r0, #70	; 0x46
 8005b16:	2145      	movs	r1, #69	; 0x45
 8005b18:	e9cd 0125 	strd	r0, r1, [sp, #148]	; 0x94
 8005b1c:	2144      	movs	r1, #68	; 0x44
 8005b1e:	9113      	str	r1, [sp, #76]	; 0x4c
 8005b20:	2143      	movs	r1, #67	; 0x43
 8005b22:	9101      	str	r1, [sp, #4]
 8005b24:	2142      	movs	r1, #66	; 0x42
 8005b26:	9135      	str	r1, [sp, #212]	; 0xd4
 8005b28:	2141      	movs	r1, #65	; 0x41
 8005b2a:	913a      	str	r1, [sp, #232]	; 0xe8
 8005b2c:	2140      	movs	r1, #64	; 0x40
 8005b2e:	9134      	str	r1, [sp, #208]	; 0xd0
 8005b30:	213f      	movs	r1, #63	; 0x3f
 8005b32:	9139      	str	r1, [sp, #228]	; 0xe4
 8005b34:	213e      	movs	r1, #62	; 0x3e
 8005b36:	9133      	str	r1, [sp, #204]	; 0xcc
 8005b38:	213d      	movs	r1, #61	; 0x3d
 8005b3a:	9138      	str	r1, [sp, #224]	; 0xe0
 8005b3c:	213c      	movs	r1, #60	; 0x3c
 8005b3e:	203b      	movs	r0, #59	; 0x3b
 8005b40:	9132      	str	r1, [sp, #200]	; 0xc8
 8005b42:	213a      	movs	r1, #58	; 0x3a
 8005b44:	e9cd 1036 	strd	r1, r0, [sp, #216]	; 0xd8
 8005b48:	2139      	movs	r1, #57	; 0x39
 8005b4a:	9116      	str	r1, [sp, #88]	; 0x58
 8005b4c:	2138      	movs	r1, #56	; 0x38
 8005b4e:	9105      	str	r1, [sp, #20]
 8005b50:	2137      	movs	r1, #55	; 0x37
 8005b52:	9115      	str	r1, [sp, #84]	; 0x54
 8005b54:	2136      	movs	r1, #54	; 0x36
 8005b56:	9104      	str	r1, [sp, #16]
 8005b58:	2135      	movs	r1, #53	; 0x35
 8005b5a:	9114      	str	r1, [sp, #80]	; 0x50
 8005b5c:	2134      	movs	r1, #52	; 0x34
 8005b5e:	9103      	str	r1, [sp, #12]
 8005b60:	2132      	movs	r1, #50	; 0x32
 8005b62:	f04f 0a33 	mov.w	sl, #51	; 0x33
 8005b66:	9102      	str	r1, [sp, #8]
 8005b68:	f04f 0831 	mov.w	r8, #49	; 0x31
 8005b6c:	2730      	movs	r7, #48	; 0x30
 8005b6e:	202f      	movs	r0, #47	; 0x2f
 8005b70:	e0b5      	b.n	8005cde <USBD_AUDIO_Init_Microphone_Descriptor+0x2ea>
 8005b72:	bf00      	nop
 8005b74:	20002680 	.word	0x20002680
 8005b78:	00040932 	.word	0x00040932
 8005b7c:	24090000 	.word	0x24090000
 8005b80:	0c010100 	.word	0x0c010100
 8005b84:	01020624 	.word	0x01020624
 8005b88:	80000102 	.word	0x80000102
 8005b8c:	01010000 	.word	0x01010000
    USBD_AUDIO_CfgDesc[46] = 0x00;     
  }
  else
  {
    AUDIO_CONTROLS = (0x02);     
    USBD_AUDIO_CfgDesc[45] = 0x00;
 8005b90:	f44f 7100 	mov.w	r1, #512	; 0x200
    USBD_AUDIO_CfgDesc[46] = AUDIO_CONTROLS;
    USBD_AUDIO_CfgDesc[index] = AUDIO_CONTROLS;
    index++;
  }   
  if(Channels > 2)
 8005b94:	2a02      	cmp	r2, #2
    USBD_AUDIO_CfgDesc[45] = 0x00;
 8005b96:	f8a3 102d 	strh.w	r1, [r3, #45]	; 0x2d
    USBD_AUDIO_CfgDesc[index] = AUDIO_CONTROLS;
 8005b9a:	f883 002f 	strb.w	r0, [r3, #47]	; 0x2f
  if(Channels > 2)
 8005b9e:	f240 8178 	bls.w	8005e92 <USBD_AUDIO_Init_Microphone_Descriptor+0x49e>
  {
    USBD_AUDIO_CfgDesc[index] = AUDIO_CONTROLS;
    index++;
  }   
  if(Channels > 3)
 8005ba2:	2a03      	cmp	r2, #3
    USBD_AUDIO_CfgDesc[index] = AUDIO_CONTROLS;
 8005ba4:	f883 0030 	strb.w	r0, [r3, #48]	; 0x30
  if(Channels > 3)
 8005ba8:	f000 81fa 	beq.w	8005fa0 <USBD_AUDIO_Init_Microphone_Descriptor+0x5ac>
  {
    USBD_AUDIO_CfgDesc[index] = AUDIO_CONTROLS;
    index++;
  }   
  if(Channels > 4)
 8005bac:	2a04      	cmp	r2, #4
    USBD_AUDIO_CfgDesc[index] = AUDIO_CONTROLS;
 8005bae:	f883 0031 	strb.w	r0, [r3, #49]	; 0x31
  if(Channels > 4)
 8005bb2:	f000 83fc 	beq.w	80063ae <USBD_AUDIO_Init_Microphone_Descriptor+0x9ba>
  {
    USBD_AUDIO_CfgDesc[index] = AUDIO_CONTROLS;
    index++;
  }   
  if(Channels > 5)
 8005bb6:	2a05      	cmp	r2, #5
    USBD_AUDIO_CfgDesc[index] = AUDIO_CONTROLS;
 8005bb8:	f883 0032 	strb.w	r0, [r3, #50]	; 0x32
  if(Channels > 5)
 8005bbc:	f000 8373 	beq.w	80062a6 <USBD_AUDIO_Init_Microphone_Descriptor+0x8b2>
  {
    USBD_AUDIO_CfgDesc[index] = AUDIO_CONTROLS;
    index++;
  }   
  if(Channels > 6)
 8005bc0:	2a06      	cmp	r2, #6
    USBD_AUDIO_CfgDesc[index] = AUDIO_CONTROLS;
 8005bc2:	f883 0033 	strb.w	r0, [r3, #51]	; 0x33
  if(Channels > 6)
 8005bc6:	f000 82ea 	beq.w	800619e <USBD_AUDIO_Init_Microphone_Descriptor+0x7aa>
  {
    USBD_AUDIO_CfgDesc[index] = AUDIO_CONTROLS;
    index++;
  }   
  if(Channels > 7)
 8005bca:	2a07      	cmp	r2, #7
    USBD_AUDIO_CfgDesc[index] = AUDIO_CONTROLS;
 8005bcc:	f883 0034 	strb.w	r0, [r3, #52]	; 0x34
  if(Channels > 7)
 8005bd0:	f000 8264 	beq.w	800609c <USBD_AUDIO_Init_Microphone_Descriptor+0x6a8>
  {
    USBD_AUDIO_CfgDesc[index] = AUDIO_CONTROLS;
 8005bd4:	2172      	movs	r1, #114	; 0x72
 8005bd6:	2573      	movs	r5, #115	; 0x73
 8005bd8:	e9cd 5117 	strd	r5, r1, [sp, #92]	; 0x5c
 8005bdc:	2671      	movs	r6, #113	; 0x71
 8005bde:	2170      	movs	r1, #112	; 0x70
 8005be0:	e9cd 1619 	strd	r1, r6, [sp, #100]	; 0x64
 8005be4:	276f      	movs	r7, #111	; 0x6f
 8005be6:	216e      	movs	r1, #110	; 0x6e
 8005be8:	e9cd 171b 	strd	r1, r7, [sp, #108]	; 0x6c
 8005bec:	f04f 0c6d 	mov.w	ip, #109	; 0x6d
 8005bf0:	216c      	movs	r1, #108	; 0x6c
 8005bf2:	e9cd 1c1d 	strd	r1, ip, [sp, #116]	; 0x74
 8005bf6:	f04f 0e6b 	mov.w	lr, #107	; 0x6b
 8005bfa:	216a      	movs	r1, #106	; 0x6a
 8005bfc:	e9cd 1e1f 	strd	r1, lr, [sp, #124]	; 0x7c
 8005c00:	f04f 0869 	mov.w	r8, #105	; 0x69
 8005c04:	2168      	movs	r1, #104	; 0x68
 8005c06:	e9cd 1821 	strd	r1, r8, [sp, #132]	; 0x84
 8005c0a:	f04f 0967 	mov.w	r9, #103	; 0x67
 8005c0e:	2166      	movs	r1, #102	; 0x66
 8005c10:	e9cd 1923 	strd	r1, r9, [sp, #140]	; 0x8c
 8005c14:	2165      	movs	r1, #101	; 0x65
 8005c16:	910c      	str	r1, [sp, #48]	; 0x30
 8005c18:	2164      	movs	r1, #100	; 0x64
 8005c1a:	9131      	str	r1, [sp, #196]	; 0xc4
 8005c1c:	2463      	movs	r4, #99	; 0x63
 8005c1e:	2162      	movs	r1, #98	; 0x62
 8005c20:	e9cd 412f 	strd	r4, r1, [sp, #188]	; 0xbc
 8005c24:	2161      	movs	r1, #97	; 0x61
 8005c26:	9106      	str	r1, [sp, #24]
 8005c28:	2160      	movs	r1, #96	; 0x60
 8005c2a:	910d      	str	r1, [sp, #52]	; 0x34
 8005c2c:	215f      	movs	r1, #95	; 0x5f
 8005c2e:	9107      	str	r1, [sp, #28]
 8005c30:	215e      	movs	r1, #94	; 0x5e
 8005c32:	910e      	str	r1, [sp, #56]	; 0x38
 8005c34:	215d      	movs	r1, #93	; 0x5d
 8005c36:	9108      	str	r1, [sp, #32]
 8005c38:	215c      	movs	r1, #92	; 0x5c
 8005c3a:	910f      	str	r1, [sp, #60]	; 0x3c
 8005c3c:	215b      	movs	r1, #91	; 0x5b
 8005c3e:	9109      	str	r1, [sp, #36]	; 0x24
 8005c40:	215a      	movs	r1, #90	; 0x5a
 8005c42:	9110      	str	r1, [sp, #64]	; 0x40
 8005c44:	2159      	movs	r1, #89	; 0x59
 8005c46:	910a      	str	r1, [sp, #40]	; 0x28
 8005c48:	2158      	movs	r1, #88	; 0x58
 8005c4a:	9111      	str	r1, [sp, #68]	; 0x44
 8005c4c:	2157      	movs	r1, #87	; 0x57
 8005c4e:	910b      	str	r1, [sp, #44]	; 0x2c
 8005c50:	2156      	movs	r1, #86	; 0x56
 8005c52:	9112      	str	r1, [sp, #72]	; 0x48
 8005c54:	2755      	movs	r7, #85	; 0x55
 8005c56:	2154      	movs	r1, #84	; 0x54
 8005c58:	f883 0035 	strb.w	r0, [r3, #53]	; 0x35
 8005c5c:	f04f 0c53 	mov.w	ip, #83	; 0x53
 8005c60:	e9cd 712d 	strd	r7, r1, [sp, #180]	; 0xb4
 8005c64:	2152      	movs	r1, #82	; 0x52
 8005c66:	e9cd c12b 	strd	ip, r1, [sp, #172]	; 0xac
 8005c6a:	f04f 0e51 	mov.w	lr, #81	; 0x51
 8005c6e:	2150      	movs	r1, #80	; 0x50
 8005c70:	f04f 084f 	mov.w	r8, #79	; 0x4f
 8005c74:	e9cd e129 	strd	lr, r1, [sp, #164]	; 0xa4
 8005c78:	214e      	movs	r1, #78	; 0x4e
 8005c7a:	e9cd 8127 	strd	r8, r1, [sp, #156]	; 0x9c
 8005c7e:	f04f 094d 	mov.w	r9, #77	; 0x4d
 8005c82:	214c      	movs	r1, #76	; 0x4c
 8005c84:	e9cd 9125 	strd	r9, r1, [sp, #148]	; 0x94
 8005c88:	214b      	movs	r1, #75	; 0x4b
 8005c8a:	9113      	str	r1, [sp, #76]	; 0x4c
 8005c8c:	214a      	movs	r1, #74	; 0x4a
 8005c8e:	9101      	str	r1, [sp, #4]
 8005c90:	2149      	movs	r1, #73	; 0x49
 8005c92:	9135      	str	r1, [sp, #212]	; 0xd4
 8005c94:	2148      	movs	r1, #72	; 0x48
 8005c96:	913a      	str	r1, [sp, #232]	; 0xe8
 8005c98:	2147      	movs	r1, #71	; 0x47
 8005c9a:	9134      	str	r1, [sp, #208]	; 0xd0
 8005c9c:	2146      	movs	r1, #70	; 0x46
 8005c9e:	9139      	str	r1, [sp, #228]	; 0xe4
 8005ca0:	2145      	movs	r1, #69	; 0x45
 8005ca2:	9133      	str	r1, [sp, #204]	; 0xcc
 8005ca4:	2144      	movs	r1, #68	; 0x44
 8005ca6:	9138      	str	r1, [sp, #224]	; 0xe0
 8005ca8:	2143      	movs	r1, #67	; 0x43
 8005caa:	9132      	str	r1, [sp, #200]	; 0xc8
 8005cac:	f04f 0942 	mov.w	r9, #66	; 0x42
 8005cb0:	2141      	movs	r1, #65	; 0x41
 8005cb2:	e9cd 1936 	strd	r1, r9, [sp, #216]	; 0xd8
 8005cb6:	2140      	movs	r1, #64	; 0x40
 8005cb8:	9116      	str	r1, [sp, #88]	; 0x58
 8005cba:	213f      	movs	r1, #63	; 0x3f
 8005cbc:	9105      	str	r1, [sp, #20]
 8005cbe:	213e      	movs	r1, #62	; 0x3e
 8005cc0:	9115      	str	r1, [sp, #84]	; 0x54
 8005cc2:	213d      	movs	r1, #61	; 0x3d
 8005cc4:	9104      	str	r1, [sp, #16]
 8005cc6:	213c      	movs	r1, #60	; 0x3c
 8005cc8:	9114      	str	r1, [sp, #80]	; 0x50
 8005cca:	213b      	movs	r1, #59	; 0x3b
 8005ccc:	9103      	str	r1, [sp, #12]
 8005cce:	2139      	movs	r1, #57	; 0x39
 8005cd0:	f04f 0a3a 	mov.w	sl, #58	; 0x3a
 8005cd4:	9102      	str	r1, [sp, #8]
 8005cd6:	f04f 0838 	mov.w	r8, #56	; 0x38
 8005cda:	2737      	movs	r7, #55	; 0x37
 8005cdc:	2036      	movs	r0, #54	; 0x36
  /* Endpoint 1 - Standard Descriptor */
  USBD_AUDIO_CfgDesc[index++] =  AUDIO_STANDARD_ENDPOINT_DESC_SIZE;            /* bLength */
  USBD_AUDIO_CfgDesc[index++] = 0x05;                                          /* bDescriptorType */
  USBD_AUDIO_CfgDesc[index++] = AUDIO_IN_EP;                                   /* bEndpointAddress 1 in endpoint*/
  USBD_AUDIO_CfgDesc[index++] = 0x05;                                          /* bmAttributes */
  USBD_AUDIO_CfgDesc[index++] = ((samplingFrequency/1000+2)*Channels*2)&0xFF;  /* wMaxPacketSize */ 
 8005cde:	49ad      	ldr	r1, [pc, #692]	; (8005f94 <USBD_AUDIO_Init_Microphone_Descriptor+0x5a0>)
 8005ce0:	fba1 1c0b 	umull	r1, ip, r1, fp
 8005ce4:	ea4f 1c9c 	mov.w	ip, ip, lsr #6
  USBD_AUDIO_CfgDesc[index++] = 0x00;                                          /* bmAttributes */
  USBD_AUDIO_CfgDesc[index++] = 0x00;                                          /* bLockDelayUnits */
  USBD_AUDIO_CfgDesc[index++] = 0x00;                                          /* wLockDelay */
  USBD_AUDIO_CfgDesc[index++] = 0x00;    
    
  haudioInstance.paketDimension = (samplingFrequency/1000*Channels*2);
 8005ce8:	fb1c fe02 	smulbb	lr, ip, r2
  USBD_AUDIO_CfgDesc[index++] = ((samplingFrequency/1000+2)*Channels*2)&0xFF;  /* wMaxPacketSize */ 
 8005cec:	f10c 0c02 	add.w	ip, ip, #2
 8005cf0:	fb1c f602 	smulbb	r6, ip, r2
 8005cf4:	0075      	lsls	r5, r6, #1
  USBD_AUDIO_CfgDesc[index] = 0x00;                                            /* iTerminal */
 8005cf6:	2100      	movs	r1, #0
  USBD_AUDIO_CfgDesc[index++] = ((samplingFrequency/1000+2)*Channels*2)&0xFF;  /* wMaxPacketSize */ 
 8005cf8:	953b      	str	r5, [sp, #236]	; 0xec
  USBD_AUDIO_CfgDesc[index++] = 0x09;                                          /* bLength */
 8005cfa:	2509      	movs	r5, #9
  USBD_AUDIO_CfgDesc[index] = 0x00;                                            /* iTerminal */
 8005cfc:	5419      	strb	r1, [r3, r0]
  USBD_AUDIO_CfgDesc[index++] = AUDIO_CONTROL_OUTPUT_TERMINAL;                 /* bDescriptorSubtype */
 8005cfe:	9e02      	ldr	r6, [sp, #8]
  USBD_AUDIO_CfgDesc[index++] = 0x09;                                          /* bLength */
 8005d00:	55dd      	strb	r5, [r3, r7]
  USBD_AUDIO_CfgDesc[index++] = AUDIO_INTERFACE_DESCRIPTOR_TYPE;               /* bDescriptorType */
 8005d02:	2724      	movs	r7, #36	; 0x24
 8005d04:	f803 7008 	strb.w	r7, [r3, r8]
  USBD_AUDIO_CfgDesc[index++] = AUDIO_CONTROL_OUTPUT_TERMINAL;                 /* bDescriptorSubtype */
 8005d08:	f04f 0803 	mov.w	r8, #3
 8005d0c:	f803 8006 	strb.w	r8, [r3, r6]
  USBD_AUDIO_CfgDesc[index++] = 0x01;                                          /* wTerminalType AUDIO_TERMINAL_USB_STREAMING 0x0101*/
 8005d10:	9e03      	ldr	r6, [sp, #12]
  USBD_AUDIO_CfgDesc[index++] = 0x03;                                          /* bTerminalID */
 8005d12:	f803 800a 	strb.w	r8, [r3, sl]
  USBD_AUDIO_CfgDesc[index++] = 0x01;                                          /* wTerminalType AUDIO_TERMINAL_USB_STREAMING 0x0101*/
 8005d16:	2001      	movs	r0, #1
 8005d18:	5598      	strb	r0, [r3, r6]
  USBD_AUDIO_CfgDesc[index++] = 0x01;
 8005d1a:	9e14      	ldr	r6, [sp, #80]	; 0x50
 8005d1c:	5598      	strb	r0, [r3, r6]
  USBD_AUDIO_CfgDesc[index++] = 0x00;
 8005d1e:	9e04      	ldr	r6, [sp, #16]
 8005d20:	5599      	strb	r1, [r3, r6]
  USBD_AUDIO_CfgDesc[index++] = 0x02;
 8005d22:	9e15      	ldr	r6, [sp, #84]	; 0x54
 8005d24:	2402      	movs	r4, #2
 8005d26:	559c      	strb	r4, [r3, r6]
  USBD_AUDIO_CfgDesc[index++] = 0x00;   
 8005d28:	9e05      	ldr	r6, [sp, #20]
 8005d2a:	5599      	strb	r1, [r3, r6]
  USBD_AUDIO_CfgDesc[index++] = 9;                                             /* bLength */
 8005d2c:	9e16      	ldr	r6, [sp, #88]	; 0x58
 8005d2e:	559d      	strb	r5, [r3, r6]
  USBD_AUDIO_CfgDesc[index++] = USB_INTERFACE_DESCRIPTOR_TYPE;                 /* bDescriptorType */
 8005d30:	9e36      	ldr	r6, [sp, #216]	; 0xd8
 8005d32:	f04f 0a04 	mov.w	sl, #4
 8005d36:	f803 a006 	strb.w	sl, [r3, r6]
  USBD_AUDIO_CfgDesc[index++] = 0x01;                                          /* bInterfaceNumber */
 8005d3a:	9e37      	ldr	r6, [sp, #220]	; 0xdc
 8005d3c:	5598      	strb	r0, [r3, r6]
  USBD_AUDIO_CfgDesc[index++] = 0x00;                                          /* bAlternateSetting */
 8005d3e:	9e32      	ldr	r6, [sp, #200]	; 0xc8
 8005d40:	5599      	strb	r1, [r3, r6]
  USBD_AUDIO_CfgDesc[index++] = 0x00;                                          /* bNumEndpoints */
 8005d42:	9e38      	ldr	r6, [sp, #224]	; 0xe0
 8005d44:	5599      	strb	r1, [r3, r6]
  USBD_AUDIO_CfgDesc[index++] = USB_DEVICE_CLASS_AUDIO;                        /* bInterfaceClass */
 8005d46:	9e33      	ldr	r6, [sp, #204]	; 0xcc
 8005d48:	5598      	strb	r0, [r3, r6]
  USBD_AUDIO_CfgDesc[index++] = AUDIO_SUBCLASS_AUDIOSTREAMING;                 /* bInterfaceSubClass */
 8005d4a:	9e39      	ldr	r6, [sp, #228]	; 0xe4
 8005d4c:	559c      	strb	r4, [r3, r6]
  USBD_AUDIO_CfgDesc[index++] = AUDIO_PROTOCOL_UNDEFINED;                      /* bInterfaceProtocol */
 8005d4e:	9e34      	ldr	r6, [sp, #208]	; 0xd0
 8005d50:	5599      	strb	r1, [r3, r6]
  USBD_AUDIO_CfgDesc[index++] = 0x00;   
 8005d52:	9e3a      	ldr	r6, [sp, #232]	; 0xe8
 8005d54:	5599      	strb	r1, [r3, r6]
  USBD_AUDIO_CfgDesc[index++] = 9;                                             /* bLength */
 8005d56:	9e35      	ldr	r6, [sp, #212]	; 0xd4
 8005d58:	559d      	strb	r5, [r3, r6]
  USBD_AUDIO_CfgDesc[index++] = USB_INTERFACE_DESCRIPTOR_TYPE;                 /* bDescriptorType */
 8005d5a:	9e01      	ldr	r6, [sp, #4]
 8005d5c:	f803 a006 	strb.w	sl, [r3, r6]
  USBD_AUDIO_CfgDesc[index++] = 0x01;                                          /* bInterfaceNumber */
 8005d60:	9e13      	ldr	r6, [sp, #76]	; 0x4c
 8005d62:	5598      	strb	r0, [r3, r6]
  USBD_AUDIO_CfgDesc[index++] = 0x01;                                          /* bAlternateSetting */
 8005d64:	9e26      	ldr	r6, [sp, #152]	; 0x98
 8005d66:	5598      	strb	r0, [r3, r6]
  USBD_AUDIO_CfgDesc[index++] = 0x01;                                          /* bNumEndpoints */
 8005d68:	9e25      	ldr	r6, [sp, #148]	; 0x94
 8005d6a:	5598      	strb	r0, [r3, r6]
  USBD_AUDIO_CfgDesc[index++] = USB_DEVICE_CLASS_AUDIO;                        /* bInterfaceClass */
 8005d6c:	9e28      	ldr	r6, [sp, #160]	; 0xa0
 8005d6e:	5598      	strb	r0, [r3, r6]
  USBD_AUDIO_CfgDesc[index++] = AUDIO_SUBCLASS_AUDIOSTREAMING;                 /* bInterfaceSubClass */
 8005d70:	9e27      	ldr	r6, [sp, #156]	; 0x9c
 8005d72:	559c      	strb	r4, [r3, r6]
  USBD_AUDIO_CfgDesc[index++] = AUDIO_PROTOCOL_UNDEFINED;                      /* bInterfaceProtocol */
 8005d74:	9e2a      	ldr	r6, [sp, #168]	; 0xa8
 8005d76:	5599      	strb	r1, [r3, r6]
  USBD_AUDIO_CfgDesc[index++] = 0x00;                                          /* iInterface */   
 8005d78:	9e29      	ldr	r6, [sp, #164]	; 0xa4
 8005d7a:	5599      	strb	r1, [r3, r6]
  USBD_AUDIO_CfgDesc[index++] = AUDIO_STREAMING_INTERFACE_DESC_SIZE;           /* bLength */
 8005d7c:	9e2c      	ldr	r6, [sp, #176]	; 0xb0
 8005d7e:	f04f 0a07 	mov.w	sl, #7
 8005d82:	f803 a006 	strb.w	sl, [r3, r6]
  USBD_AUDIO_CfgDesc[index++] = AUDIO_INTERFACE_DESCRIPTOR_TYPE;               /* bDescriptorType */
 8005d86:	9e2b      	ldr	r6, [sp, #172]	; 0xac
 8005d88:	559f      	strb	r7, [r3, r6]
  USBD_AUDIO_CfgDesc[index++] = AUDIO_STREAMING_GENERAL;                       /* bDescriptorSubtype */
 8005d8a:	9e2e      	ldr	r6, [sp, #184]	; 0xb8
 8005d8c:	5598      	strb	r0, [r3, r6]
  USBD_AUDIO_CfgDesc[index++] = 0x03;                                          /* bTerminalLink */
 8005d8e:	9e2d      	ldr	r6, [sp, #180]	; 0xb4
 8005d90:	f803 8006 	strb.w	r8, [r3, r6]
  USBD_AUDIO_CfgDesc[index++] = 0x01;                                          /* bDelay */
 8005d94:	9e12      	ldr	r6, [sp, #72]	; 0x48
  haudioInstance.paketDimension = (samplingFrequency/1000*Channels*2);
 8005d96:	fa1f fe8e 	uxth.w	lr, lr
  USBD_AUDIO_CfgDesc[index++] = 0x01;                                          /* bDelay */
 8005d9a:	5598      	strb	r0, [r3, r6]
  USBD_AUDIO_CfgDesc[index++] = 0x01;                                          /* wFormatTag AUDIO_FORMAT_PCM  0x0001*/
 8005d9c:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
  haudioInstance.paketDimension = (samplingFrequency/1000*Channels*2);
 8005d9e:	ea4f 094e 	mov.w	r9, lr, lsl #1
  USBD_AUDIO_CfgDesc[index++] = 0x01;                                          /* wFormatTag AUDIO_FORMAT_PCM  0x0001*/
 8005da2:	5598      	strb	r0, [r3, r6]
  haudioInstance.paketDimension = (samplingFrequency/1000*Channels*2);
 8005da4:	f8a3 920a 	strh.w	r9, [r3, #522]	; 0x20a
  USBD_AUDIO_CfgDesc[index++] = 0x00;                
 8005da8:	9e11      	ldr	r6, [sp, #68]	; 0x44
  haudioInstance.frequency=samplingFrequency;
 8005daa:	f8c3 b200 	str.w	fp, [r3, #512]	; 0x200
  USBD_AUDIO_CfgDesc[index++] = 0x00;                
 8005dae:	5599      	strb	r1, [r3, r6]
  USBD_AUDIO_CfgDesc[index++] = 0x0B;                                          /* bLength */
 8005db0:	9e0a      	ldr	r6, [sp, #40]	; 0x28
  haudioInstance.buffer_length = haudioInstance.paketDimension * AUDIO_IN_PACKET_NUM;
 8005db2:	44ce      	add	lr, r9
  USBD_AUDIO_CfgDesc[index++] = 0x0B;                                          /* bLength */
 8005db4:	f04f 090b 	mov.w	r9, #11
 8005db8:	f803 9006 	strb.w	r9, [r3, r6]
  USBD_AUDIO_CfgDesc[index++] = AUDIO_INTERFACE_DESCRIPTOR_TYPE;               /* bDescriptorType */
 8005dbc:	9e10      	ldr	r6, [sp, #64]	; 0x40
 8005dbe:	559f      	strb	r7, [r3, r6]
  USBD_AUDIO_CfgDesc[index++] = AUDIO_STREAMING_FORMAT_TYPE;                   /* bDescriptorSubtype */
 8005dc0:	9e09      	ldr	r6, [sp, #36]	; 0x24
 8005dc2:	559c      	strb	r4, [r3, r6]
  USBD_AUDIO_CfgDesc[index++] = AUDIO_FORMAT_TYPE_I;                           /* bFormatType */
 8005dc4:	9e0f      	ldr	r6, [sp, #60]	; 0x3c
 8005dc6:	5598      	strb	r0, [r3, r6]
  USBD_AUDIO_CfgDesc[index++] = Channels;                                      /* bNrChannels */
 8005dc8:	9e08      	ldr	r6, [sp, #32]
 8005dca:	559a      	strb	r2, [r3, r6]
  USBD_AUDIO_CfgDesc[index++] = 0x02;                                          /* bSubFrameSize */
 8005dcc:	9e0e      	ldr	r6, [sp, #56]	; 0x38
 8005dce:	559c      	strb	r4, [r3, r6]
  USBD_AUDIO_CfgDesc[index++] = 16;                                            /* bBitResolution */
 8005dd0:	9e07      	ldr	r6, [sp, #28]
 8005dd2:	2410      	movs	r4, #16
 8005dd4:	559c      	strb	r4, [r3, r6]
  USBD_AUDIO_CfgDesc[index++] = 0x01;                                           /* bSamFreqType */
 8005dd6:	9c0d      	ldr	r4, [sp, #52]	; 0x34
  USBD_AUDIO_CfgDesc[index++] = (samplingFrequency>>8)&0xff;
 8005dd8:	9e30      	ldr	r6, [sp, #192]	; 0xc0
  USBD_AUDIO_CfgDesc[index++] = 0x01;                                           /* bSamFreqType */
 8005dda:	5518      	strb	r0, [r3, r4]
  USBD_AUDIO_CfgDesc[index++] = samplingFrequency&0xff;                        /* tSamFreq 8000 = 0x1F40 */
 8005ddc:	9c06      	ldr	r4, [sp, #24]
 8005dde:	f803 b004 	strb.w	fp, [r3, r4]
  USBD_AUDIO_CfgDesc[index++] = (samplingFrequency>>8)&0xff;
 8005de2:	ea4f 241b 	mov.w	r4, fp, lsr #8
 8005de6:	559c      	strb	r4, [r3, r6]
  USBD_AUDIO_CfgDesc[index++] = samplingFrequency>>16;   
 8005de8:	9e2f      	ldr	r6, [sp, #188]	; 0xbc
 8005dea:	ea4f 441b 	mov.w	r4, fp, lsr #16
 8005dee:	559c      	strb	r4, [r3, r6]
  USBD_AUDIO_CfgDesc[index++] =  AUDIO_STANDARD_ENDPOINT_DESC_SIZE;            /* bLength */
 8005df0:	9c31      	ldr	r4, [sp, #196]	; 0xc4
 8005df2:	551d      	strb	r5, [r3, r4]
  USBD_AUDIO_CfgDesc[index++] = 0x05;                                          /* bDescriptorType */
 8005df4:	9c0c      	ldr	r4, [sp, #48]	; 0x30
  USBD_AUDIO_CfgDesc[index++] = AUDIO_IN_EP;                                   /* bEndpointAddress 1 in endpoint*/
 8005df6:	9d23      	ldr	r5, [sp, #140]	; 0x8c
  USBD_AUDIO_CfgDesc[index++] = 0x05;                                          /* bDescriptorType */
 8005df8:	f04f 0805 	mov.w	r8, #5
 8005dfc:	f803 8004 	strb.w	r8, [r3, r4]
  USBD_AUDIO_CfgDesc[index++] = AUDIO_IN_EP;                                   /* bEndpointAddress 1 in endpoint*/
 8005e00:	2481      	movs	r4, #129	; 0x81
 8005e02:	555c      	strb	r4, [r3, r5]
  USBD_AUDIO_CfgDesc[index++] = 0x05;                                          /* bmAttributes */
 8005e04:	9c24      	ldr	r4, [sp, #144]	; 0x90
 8005e06:	f803 8004 	strb.w	r8, [r3, r4]
  USBD_AUDIO_CfgDesc[index++] = ((samplingFrequency/1000+2)*Channels*2)&0xFF;  /* wMaxPacketSize */ 
 8005e0a:	9c21      	ldr	r4, [sp, #132]	; 0x84
 8005e0c:	9d3b      	ldr	r5, [sp, #236]	; 0xec
 8005e0e:	551d      	strb	r5, [r3, r4]
  USBD_AUDIO_CfgDesc[index++] = ((samplingFrequency/1000+2)*Channels*2)>>8; 
 8005e10:	fb0c fc02 	mul.w	ip, ip, r2
 8005e14:	9c22      	ldr	r4, [sp, #136]	; 0x88
  USBD_AUDIO_CfgDesc[index++] = AUDIO_ENDPOINT_DESCRIPTOR_TYPE;                /* bDescriptorType */
 8005e16:	9d1b      	ldr	r5, [sp, #108]	; 0x6c
  haudioInstance.channels=Channels;  
 8005e18:	f883 21fc 	strb.w	r2, [r3, #508]	; 0x1fc
  USBD_AUDIO_CfgDesc[index++] = ((samplingFrequency/1000+2)*Channels*2)>>8; 
 8005e1c:	f3cc 1cd7 	ubfx	ip, ip, #7, #24
 8005e20:	f803 c004 	strb.w	ip, [r3, r4]
  USBD_AUDIO_CfgDesc[index++] = 0x01;                                          /* bInterval */
 8005e24:	9c1f      	ldr	r4, [sp, #124]	; 0x7c
  haudioInstance.upper_treshold = 5;
  haudioInstance.lower_treshold = 2;
  haudioInstance.state = STATE_USB_WAITING_FOR_INIT;
 8005e26:	f883 120c 	strb.w	r1, [r3, #524]	; 0x20c
  USBD_AUDIO_CfgDesc[index++] = 0x01;                                          /* bInterval */
 8005e2a:	5518      	strb	r0, [r3, r4]
  USBD_AUDIO_CfgDesc[index++] = 0x00;                                          /* bRefresh */
 8005e2c:	9c20      	ldr	r4, [sp, #128]	; 0x80
  haudioInstance.wr_ptr = 3 * haudioInstance.paketDimension;
  haudioInstance.rd_ptr = 0;  
 8005e2e:	f8a3 120e 	strh.w	r1, [r3, #526]	; 0x20e
  USBD_AUDIO_CfgDesc[index++] = 0x00;                                          /* bRefresh */
 8005e32:	5519      	strb	r1, [r3, r4]
  USBD_AUDIO_CfgDesc[index++] = 0x00;                                          /* bSynchAddress */   
 8005e34:	9c1d      	ldr	r4, [sp, #116]	; 0x74
  haudioInstance.dataAmount=0;
 8005e36:	f8a3 1208 	strh.w	r1, [r3, #520]	; 0x208
  USBD_AUDIO_CfgDesc[index++] = 0x00;                                          /* bSynchAddress */   
 8005e3a:	5519      	strb	r1, [r3, r4]
  USBD_AUDIO_CfgDesc[index++] = AUDIO_STREAMING_ENDPOINT_DESC_SIZE;            /* bLength */
 8005e3c:	9c1e      	ldr	r4, [sp, #120]	; 0x78
 8005e3e:	f803 a004 	strb.w	sl, [r3, r4]
  USBD_AUDIO_CfgDesc[index++] = AUDIO_ENDPOINT_DESCRIPTOR_TYPE;                /* bDescriptorType */
 8005e42:	2425      	movs	r4, #37	; 0x25
 8005e44:	555c      	strb	r4, [r3, r5]
  USBD_AUDIO_CfgDesc[index++] = AUDIO_ENDPOINT_GENERAL;                        /* bDescriptor */
 8005e46:	9c1c      	ldr	r4, [sp, #112]	; 0x70
 8005e48:	5518      	strb	r0, [r3, r4]
  USBD_AUDIO_CfgDesc[index++] = 0x00;                                          /* bmAttributes */
 8005e4a:	9819      	ldr	r0, [sp, #100]	; 0x64
 8005e4c:	5419      	strb	r1, [r3, r0]
  USBD_AUDIO_CfgDesc[index++] = 0x00;                                          /* bLockDelayUnits */
 8005e4e:	981a      	ldr	r0, [sp, #104]	; 0x68
 8005e50:	5419      	strb	r1, [r3, r0]
  USBD_AUDIO_CfgDesc[index++] = 0x00;                                          /* wLockDelay */
 8005e52:	9818      	ldr	r0, [sp, #96]	; 0x60
 8005e54:	5419      	strb	r1, [r3, r0]
  USBD_AUDIO_CfgDesc[index++] = 0x00;    
 8005e56:	9817      	ldr	r0, [sp, #92]	; 0x5c
 8005e58:	5419      	strb	r1, [r3, r0]
  haudioInstance.buffer_length = haudioInstance.paketDimension * AUDIO_IN_PACKET_NUM;
 8005e5a:	ea4f 008e 	mov.w	r0, lr, lsl #2
 8005e5e:	f8a3 0206 	strh.w	r0, [r3, #518]	; 0x206
  haudioInstance.wr_ptr = 3 * haudioInstance.paketDimension;
 8005e62:	ea4f 0e4e 	mov.w	lr, lr, lsl #1
  haudioInstance.upper_treshold = 5;
 8005e66:	f240 2005 	movw	r0, #517	; 0x205
 8005e6a:	f8a3 0212 	strh.w	r0, [r3, #530]	; 0x212
  haudioInstance.wr_ptr = 3 * haudioInstance.paketDimension;
 8005e6e:	f8a3 e210 	strh.w	lr, [r3, #528]	; 0x210
  haudioInstance.buffer = 0;
 8005e72:	f8c3 1258 	str.w	r1, [r3, #600]	; 0x258
}
 8005e76:	b03d      	add	sp, #244	; 0xf4
 8005e78:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    USBD_AUDIO_CfgDesc[35] = 0x03;                                             /* wChannelConfig 0x0003  Stereo */
 8005e7c:	4846      	ldr	r0, [pc, #280]	; (8005f98 <USBD_AUDIO_Init_Microphone_Descriptor+0x5a4>)
 8005e7e:	4947      	ldr	r1, [pc, #284]	; (8005f9c <USBD_AUDIO_Init_Microphone_Descriptor+0x5a8>)
 8005e80:	f8c3 0027 	str.w	r0, [r3, #39]	; 0x27
 8005e84:	2403      	movs	r4, #3
 8005e86:	f8c3 4023 	str.w	r4, [r3, #35]	; 0x23
 8005e8a:	f8c3 102b 	str.w	r1, [r3, #43]	; 0x2b
    USBD_AUDIO_CfgDesc[index] = AUDIO_CONTROLS;
 8005e8e:	f883 202f 	strb.w	r2, [r3, #47]	; 0x2f
  if(Channels > 2)
 8005e92:	206d      	movs	r0, #109	; 0x6d
 8005e94:	216c      	movs	r1, #108	; 0x6c
 8005e96:	e9cd 0117 	strd	r0, r1, [sp, #92]	; 0x5c
 8005e9a:	246b      	movs	r4, #107	; 0x6b
 8005e9c:	216a      	movs	r1, #106	; 0x6a
 8005e9e:	e9cd 1419 	strd	r1, r4, [sp, #100]	; 0x64
 8005ea2:	2569      	movs	r5, #105	; 0x69
 8005ea4:	2168      	movs	r1, #104	; 0x68
 8005ea6:	e9cd 151b 	strd	r1, r5, [sp, #108]	; 0x6c
 8005eaa:	2667      	movs	r6, #103	; 0x67
 8005eac:	2166      	movs	r1, #102	; 0x66
 8005eae:	e9cd 161d 	strd	r1, r6, [sp, #116]	; 0x74
 8005eb2:	2765      	movs	r7, #101	; 0x65
 8005eb4:	2164      	movs	r1, #100	; 0x64
 8005eb6:	e9cd 171f 	strd	r1, r7, [sp, #124]	; 0x7c
 8005eba:	f04f 0c63 	mov.w	ip, #99	; 0x63
 8005ebe:	2162      	movs	r1, #98	; 0x62
 8005ec0:	e9cd 1c21 	strd	r1, ip, [sp, #132]	; 0x84
 8005ec4:	f04f 0e61 	mov.w	lr, #97	; 0x61
 8005ec8:	2160      	movs	r1, #96	; 0x60
 8005eca:	e9cd 1e23 	strd	r1, lr, [sp, #140]	; 0x8c
 8005ece:	215f      	movs	r1, #95	; 0x5f
 8005ed0:	910c      	str	r1, [sp, #48]	; 0x30
 8005ed2:	215e      	movs	r1, #94	; 0x5e
 8005ed4:	9131      	str	r1, [sp, #196]	; 0xc4
 8005ed6:	f04f 0a5d 	mov.w	sl, #93	; 0x5d
 8005eda:	215c      	movs	r1, #92	; 0x5c
 8005edc:	e9cd a12f 	strd	sl, r1, [sp, #188]	; 0xbc
 8005ee0:	215b      	movs	r1, #91	; 0x5b
 8005ee2:	9106      	str	r1, [sp, #24]
 8005ee4:	215a      	movs	r1, #90	; 0x5a
 8005ee6:	910d      	str	r1, [sp, #52]	; 0x34
 8005ee8:	2159      	movs	r1, #89	; 0x59
 8005eea:	9107      	str	r1, [sp, #28]
 8005eec:	2158      	movs	r1, #88	; 0x58
 8005eee:	910e      	str	r1, [sp, #56]	; 0x38
 8005ef0:	2157      	movs	r1, #87	; 0x57
 8005ef2:	9108      	str	r1, [sp, #32]
 8005ef4:	2156      	movs	r1, #86	; 0x56
 8005ef6:	910f      	str	r1, [sp, #60]	; 0x3c
 8005ef8:	2155      	movs	r1, #85	; 0x55
 8005efa:	9109      	str	r1, [sp, #36]	; 0x24
 8005efc:	2154      	movs	r1, #84	; 0x54
 8005efe:	9110      	str	r1, [sp, #64]	; 0x40
 8005f00:	2153      	movs	r1, #83	; 0x53
 8005f02:	910a      	str	r1, [sp, #40]	; 0x28
 8005f04:	2152      	movs	r1, #82	; 0x52
 8005f06:	9111      	str	r1, [sp, #68]	; 0x44
 8005f08:	2151      	movs	r1, #81	; 0x51
 8005f0a:	910b      	str	r1, [sp, #44]	; 0x2c
 8005f0c:	2150      	movs	r1, #80	; 0x50
 8005f0e:	9112      	str	r1, [sp, #72]	; 0x48
 8005f10:	254f      	movs	r5, #79	; 0x4f
 8005f12:	214e      	movs	r1, #78	; 0x4e
 8005f14:	e9cd 512d 	strd	r5, r1, [sp, #180]	; 0xb4
 8005f18:	264d      	movs	r6, #77	; 0x4d
 8005f1a:	214c      	movs	r1, #76	; 0x4c
 8005f1c:	e9cd 612b 	strd	r6, r1, [sp, #172]	; 0xac
 8005f20:	274b      	movs	r7, #75	; 0x4b
 8005f22:	214a      	movs	r1, #74	; 0x4a
 8005f24:	e9cd 7129 	strd	r7, r1, [sp, #164]	; 0xa4
 8005f28:	f04f 0c49 	mov.w	ip, #73	; 0x49
 8005f2c:	2148      	movs	r1, #72	; 0x48
 8005f2e:	f04f 0e47 	mov.w	lr, #71	; 0x47
 8005f32:	e9cd c127 	strd	ip, r1, [sp, #156]	; 0x9c
 8005f36:	2146      	movs	r1, #70	; 0x46
 8005f38:	e9cd e125 	strd	lr, r1, [sp, #148]	; 0x94
 8005f3c:	2145      	movs	r1, #69	; 0x45
 8005f3e:	9113      	str	r1, [sp, #76]	; 0x4c
 8005f40:	2144      	movs	r1, #68	; 0x44
 8005f42:	9101      	str	r1, [sp, #4]
 8005f44:	2143      	movs	r1, #67	; 0x43
 8005f46:	9135      	str	r1, [sp, #212]	; 0xd4
 8005f48:	2142      	movs	r1, #66	; 0x42
 8005f4a:	913a      	str	r1, [sp, #232]	; 0xe8
 8005f4c:	2141      	movs	r1, #65	; 0x41
 8005f4e:	9134      	str	r1, [sp, #208]	; 0xd0
 8005f50:	2140      	movs	r1, #64	; 0x40
 8005f52:	9139      	str	r1, [sp, #228]	; 0xe4
 8005f54:	213f      	movs	r1, #63	; 0x3f
 8005f56:	9133      	str	r1, [sp, #204]	; 0xcc
 8005f58:	213e      	movs	r1, #62	; 0x3e
 8005f5a:	9138      	str	r1, [sp, #224]	; 0xe0
 8005f5c:	213d      	movs	r1, #61	; 0x3d
 8005f5e:	9132      	str	r1, [sp, #200]	; 0xc8
 8005f60:	f04f 0e3c 	mov.w	lr, #60	; 0x3c
 8005f64:	213b      	movs	r1, #59	; 0x3b
 8005f66:	e9cd 1e36 	strd	r1, lr, [sp, #216]	; 0xd8
 8005f6a:	213a      	movs	r1, #58	; 0x3a
 8005f6c:	9116      	str	r1, [sp, #88]	; 0x58
 8005f6e:	2139      	movs	r1, #57	; 0x39
 8005f70:	9105      	str	r1, [sp, #20]
 8005f72:	2138      	movs	r1, #56	; 0x38
 8005f74:	9115      	str	r1, [sp, #84]	; 0x54
 8005f76:	2137      	movs	r1, #55	; 0x37
 8005f78:	9104      	str	r1, [sp, #16]
 8005f7a:	2136      	movs	r1, #54	; 0x36
 8005f7c:	9114      	str	r1, [sp, #80]	; 0x50
 8005f7e:	2135      	movs	r1, #53	; 0x35
 8005f80:	9103      	str	r1, [sp, #12]
 8005f82:	2133      	movs	r1, #51	; 0x33
 8005f84:	f04f 0a34 	mov.w	sl, #52	; 0x34
 8005f88:	9102      	str	r1, [sp, #8]
 8005f8a:	f04f 0832 	mov.w	r8, #50	; 0x32
 8005f8e:	2731      	movs	r7, #49	; 0x31
 8005f90:	2030      	movs	r0, #48	; 0x30
 8005f92:	e6a4      	b.n	8005cde <USBD_AUDIO_Init_Microphone_Descriptor+0x2ea>
 8005f94:	10624dd3 	.word	0x10624dd3
 8005f98:	0206240a 	.word	0x0206240a
 8005f9c:	02000101 	.word	0x02000101
 8005fa0:	216d      	movs	r1, #109	; 0x6d
 8005fa2:	f04f 096e 	mov.w	r9, #110	; 0x6e
 8005fa6:	e9cd 9117 	strd	r9, r1, [sp, #92]	; 0x5c
 8005faa:	f04f 0a6c 	mov.w	sl, #108	; 0x6c
 8005fae:	216b      	movs	r1, #107	; 0x6b
 8005fb0:	e9cd 1a19 	strd	r1, sl, [sp, #100]	; 0x64
 8005fb4:	206a      	movs	r0, #106	; 0x6a
 8005fb6:	2169      	movs	r1, #105	; 0x69
 8005fb8:	e9cd 101b 	strd	r1, r0, [sp, #108]	; 0x6c
 8005fbc:	2468      	movs	r4, #104	; 0x68
 8005fbe:	2167      	movs	r1, #103	; 0x67
 8005fc0:	e9cd 141d 	strd	r1, r4, [sp, #116]	; 0x74
 8005fc4:	2566      	movs	r5, #102	; 0x66
 8005fc6:	2165      	movs	r1, #101	; 0x65
 8005fc8:	e9cd 151f 	strd	r1, r5, [sp, #124]	; 0x7c
 8005fcc:	2664      	movs	r6, #100	; 0x64
 8005fce:	2163      	movs	r1, #99	; 0x63
 8005fd0:	e9cd 1621 	strd	r1, r6, [sp, #132]	; 0x84
 8005fd4:	2762      	movs	r7, #98	; 0x62
 8005fd6:	2161      	movs	r1, #97	; 0x61
 8005fd8:	e9cd 1723 	strd	r1, r7, [sp, #140]	; 0x8c
 8005fdc:	2160      	movs	r1, #96	; 0x60
 8005fde:	910c      	str	r1, [sp, #48]	; 0x30
 8005fe0:	215f      	movs	r1, #95	; 0x5f
 8005fe2:	9131      	str	r1, [sp, #196]	; 0xc4
 8005fe4:	f04f 085e 	mov.w	r8, #94	; 0x5e
 8005fe8:	215d      	movs	r1, #93	; 0x5d
 8005fea:	e9cd 812f 	strd	r8, r1, [sp, #188]	; 0xbc
 8005fee:	215c      	movs	r1, #92	; 0x5c
 8005ff0:	9106      	str	r1, [sp, #24]
 8005ff2:	215b      	movs	r1, #91	; 0x5b
 8005ff4:	910d      	str	r1, [sp, #52]	; 0x34
 8005ff6:	215a      	movs	r1, #90	; 0x5a
 8005ff8:	9107      	str	r1, [sp, #28]
 8005ffa:	2159      	movs	r1, #89	; 0x59
 8005ffc:	910e      	str	r1, [sp, #56]	; 0x38
 8005ffe:	2158      	movs	r1, #88	; 0x58
 8006000:	9108      	str	r1, [sp, #32]
 8006002:	2157      	movs	r1, #87	; 0x57
 8006004:	910f      	str	r1, [sp, #60]	; 0x3c
 8006006:	2156      	movs	r1, #86	; 0x56
 8006008:	9109      	str	r1, [sp, #36]	; 0x24
 800600a:	2155      	movs	r1, #85	; 0x55
 800600c:	9110      	str	r1, [sp, #64]	; 0x40
 800600e:	2154      	movs	r1, #84	; 0x54
 8006010:	910a      	str	r1, [sp, #40]	; 0x28
 8006012:	2153      	movs	r1, #83	; 0x53
 8006014:	9111      	str	r1, [sp, #68]	; 0x44
 8006016:	2152      	movs	r1, #82	; 0x52
 8006018:	910b      	str	r1, [sp, #44]	; 0x2c
 800601a:	2151      	movs	r1, #81	; 0x51
 800601c:	9112      	str	r1, [sp, #72]	; 0x48
 800601e:	2050      	movs	r0, #80	; 0x50
 8006020:	214f      	movs	r1, #79	; 0x4f
 8006022:	e9cd 012d 	strd	r0, r1, [sp, #180]	; 0xb4
 8006026:	244e      	movs	r4, #78	; 0x4e
 8006028:	214d      	movs	r1, #77	; 0x4d
 800602a:	e9cd 412b 	strd	r4, r1, [sp, #172]	; 0xac
 800602e:	254c      	movs	r5, #76	; 0x4c
 8006030:	214b      	movs	r1, #75	; 0x4b
 8006032:	e9cd 5129 	strd	r5, r1, [sp, #164]	; 0xa4
 8006036:	264a      	movs	r6, #74	; 0x4a
 8006038:	2149      	movs	r1, #73	; 0x49
 800603a:	2748      	movs	r7, #72	; 0x48
 800603c:	e9cd 6127 	strd	r6, r1, [sp, #156]	; 0x9c
 8006040:	2147      	movs	r1, #71	; 0x47
 8006042:	e9cd 7125 	strd	r7, r1, [sp, #148]	; 0x94
 8006046:	2146      	movs	r1, #70	; 0x46
 8006048:	9113      	str	r1, [sp, #76]	; 0x4c
 800604a:	2145      	movs	r1, #69	; 0x45
 800604c:	9101      	str	r1, [sp, #4]
 800604e:	2144      	movs	r1, #68	; 0x44
 8006050:	9135      	str	r1, [sp, #212]	; 0xd4
 8006052:	2143      	movs	r1, #67	; 0x43
 8006054:	913a      	str	r1, [sp, #232]	; 0xe8
 8006056:	2142      	movs	r1, #66	; 0x42
 8006058:	9134      	str	r1, [sp, #208]	; 0xd0
 800605a:	2141      	movs	r1, #65	; 0x41
 800605c:	9139      	str	r1, [sp, #228]	; 0xe4
 800605e:	2140      	movs	r1, #64	; 0x40
 8006060:	9133      	str	r1, [sp, #204]	; 0xcc
 8006062:	213f      	movs	r1, #63	; 0x3f
 8006064:	9138      	str	r1, [sp, #224]	; 0xe0
 8006066:	213e      	movs	r1, #62	; 0x3e
 8006068:	273d      	movs	r7, #61	; 0x3d
 800606a:	9132      	str	r1, [sp, #200]	; 0xc8
 800606c:	213c      	movs	r1, #60	; 0x3c
 800606e:	e9cd 1736 	strd	r1, r7, [sp, #216]	; 0xd8
 8006072:	213b      	movs	r1, #59	; 0x3b
 8006074:	9116      	str	r1, [sp, #88]	; 0x58
 8006076:	213a      	movs	r1, #58	; 0x3a
 8006078:	9105      	str	r1, [sp, #20]
 800607a:	2139      	movs	r1, #57	; 0x39
 800607c:	9115      	str	r1, [sp, #84]	; 0x54
 800607e:	2138      	movs	r1, #56	; 0x38
 8006080:	9104      	str	r1, [sp, #16]
 8006082:	2137      	movs	r1, #55	; 0x37
 8006084:	9114      	str	r1, [sp, #80]	; 0x50
 8006086:	2136      	movs	r1, #54	; 0x36
 8006088:	9103      	str	r1, [sp, #12]
 800608a:	2134      	movs	r1, #52	; 0x34
 800608c:	f04f 0a35 	mov.w	sl, #53	; 0x35
 8006090:	9102      	str	r1, [sp, #8]
 8006092:	f04f 0833 	mov.w	r8, #51	; 0x33
 8006096:	2732      	movs	r7, #50	; 0x32
 8006098:	2031      	movs	r0, #49	; 0x31
 800609a:	e620      	b.n	8005cde <USBD_AUDIO_Init_Microphone_Descriptor+0x2ea>
 800609c:	2072      	movs	r0, #114	; 0x72
 800609e:	2171      	movs	r1, #113	; 0x71
 80060a0:	e9cd 0117 	strd	r0, r1, [sp, #92]	; 0x5c
 80060a4:	2470      	movs	r4, #112	; 0x70
 80060a6:	216f      	movs	r1, #111	; 0x6f
 80060a8:	e9cd 1419 	strd	r1, r4, [sp, #100]	; 0x64
 80060ac:	256e      	movs	r5, #110	; 0x6e
 80060ae:	216d      	movs	r1, #109	; 0x6d
 80060b0:	e9cd 151b 	strd	r1, r5, [sp, #108]	; 0x6c
 80060b4:	266c      	movs	r6, #108	; 0x6c
 80060b6:	216b      	movs	r1, #107	; 0x6b
 80060b8:	e9cd 161d 	strd	r1, r6, [sp, #116]	; 0x74
 80060bc:	276a      	movs	r7, #106	; 0x6a
 80060be:	2169      	movs	r1, #105	; 0x69
 80060c0:	e9cd 171f 	strd	r1, r7, [sp, #124]	; 0x7c
 80060c4:	f04f 0c68 	mov.w	ip, #104	; 0x68
 80060c8:	2167      	movs	r1, #103	; 0x67
 80060ca:	e9cd 1c21 	strd	r1, ip, [sp, #132]	; 0x84
 80060ce:	f04f 0e66 	mov.w	lr, #102	; 0x66
 80060d2:	2165      	movs	r1, #101	; 0x65
 80060d4:	e9cd 1e23 	strd	r1, lr, [sp, #140]	; 0x8c
 80060d8:	2164      	movs	r1, #100	; 0x64
 80060da:	910c      	str	r1, [sp, #48]	; 0x30
 80060dc:	2163      	movs	r1, #99	; 0x63
 80060de:	9131      	str	r1, [sp, #196]	; 0xc4
 80060e0:	f04f 0a62 	mov.w	sl, #98	; 0x62
 80060e4:	2161      	movs	r1, #97	; 0x61
 80060e6:	e9cd a12f 	strd	sl, r1, [sp, #188]	; 0xbc
 80060ea:	2160      	movs	r1, #96	; 0x60
 80060ec:	9106      	str	r1, [sp, #24]
 80060ee:	215f      	movs	r1, #95	; 0x5f
 80060f0:	910d      	str	r1, [sp, #52]	; 0x34
 80060f2:	215e      	movs	r1, #94	; 0x5e
 80060f4:	9107      	str	r1, [sp, #28]
 80060f6:	215d      	movs	r1, #93	; 0x5d
 80060f8:	910e      	str	r1, [sp, #56]	; 0x38
 80060fa:	215c      	movs	r1, #92	; 0x5c
 80060fc:	9108      	str	r1, [sp, #32]
 80060fe:	215b      	movs	r1, #91	; 0x5b
 8006100:	910f      	str	r1, [sp, #60]	; 0x3c
 8006102:	215a      	movs	r1, #90	; 0x5a
 8006104:	9109      	str	r1, [sp, #36]	; 0x24
 8006106:	2159      	movs	r1, #89	; 0x59
 8006108:	9110      	str	r1, [sp, #64]	; 0x40
 800610a:	2158      	movs	r1, #88	; 0x58
 800610c:	910a      	str	r1, [sp, #40]	; 0x28
 800610e:	2157      	movs	r1, #87	; 0x57
 8006110:	9111      	str	r1, [sp, #68]	; 0x44
 8006112:	2156      	movs	r1, #86	; 0x56
 8006114:	910b      	str	r1, [sp, #44]	; 0x2c
 8006116:	2155      	movs	r1, #85	; 0x55
 8006118:	9112      	str	r1, [sp, #72]	; 0x48
 800611a:	2554      	movs	r5, #84	; 0x54
 800611c:	2153      	movs	r1, #83	; 0x53
 800611e:	e9cd 512d 	strd	r5, r1, [sp, #180]	; 0xb4
 8006122:	2652      	movs	r6, #82	; 0x52
 8006124:	2151      	movs	r1, #81	; 0x51
 8006126:	e9cd 612b 	strd	r6, r1, [sp, #172]	; 0xac
 800612a:	2750      	movs	r7, #80	; 0x50
 800612c:	214f      	movs	r1, #79	; 0x4f
 800612e:	e9cd 7129 	strd	r7, r1, [sp, #164]	; 0xa4
 8006132:	f04f 0c4e 	mov.w	ip, #78	; 0x4e
 8006136:	214d      	movs	r1, #77	; 0x4d
 8006138:	f04f 0e4c 	mov.w	lr, #76	; 0x4c
 800613c:	e9cd c127 	strd	ip, r1, [sp, #156]	; 0x9c
 8006140:	214b      	movs	r1, #75	; 0x4b
 8006142:	e9cd e125 	strd	lr, r1, [sp, #148]	; 0x94
 8006146:	214a      	movs	r1, #74	; 0x4a
 8006148:	9113      	str	r1, [sp, #76]	; 0x4c
 800614a:	2149      	movs	r1, #73	; 0x49
 800614c:	9101      	str	r1, [sp, #4]
 800614e:	2148      	movs	r1, #72	; 0x48
 8006150:	9135      	str	r1, [sp, #212]	; 0xd4
 8006152:	2147      	movs	r1, #71	; 0x47
 8006154:	913a      	str	r1, [sp, #232]	; 0xe8
 8006156:	2146      	movs	r1, #70	; 0x46
 8006158:	9134      	str	r1, [sp, #208]	; 0xd0
 800615a:	2145      	movs	r1, #69	; 0x45
 800615c:	9139      	str	r1, [sp, #228]	; 0xe4
 800615e:	2144      	movs	r1, #68	; 0x44
 8006160:	9133      	str	r1, [sp, #204]	; 0xcc
 8006162:	2143      	movs	r1, #67	; 0x43
 8006164:	9138      	str	r1, [sp, #224]	; 0xe0
 8006166:	2142      	movs	r1, #66	; 0x42
 8006168:	9132      	str	r1, [sp, #200]	; 0xc8
 800616a:	f04f 0e41 	mov.w	lr, #65	; 0x41
 800616e:	2140      	movs	r1, #64	; 0x40
 8006170:	e9cd 1e36 	strd	r1, lr, [sp, #216]	; 0xd8
 8006174:	213f      	movs	r1, #63	; 0x3f
 8006176:	9116      	str	r1, [sp, #88]	; 0x58
 8006178:	213e      	movs	r1, #62	; 0x3e
 800617a:	9105      	str	r1, [sp, #20]
 800617c:	213d      	movs	r1, #61	; 0x3d
 800617e:	9115      	str	r1, [sp, #84]	; 0x54
 8006180:	213c      	movs	r1, #60	; 0x3c
 8006182:	9104      	str	r1, [sp, #16]
 8006184:	213b      	movs	r1, #59	; 0x3b
 8006186:	9114      	str	r1, [sp, #80]	; 0x50
 8006188:	213a      	movs	r1, #58	; 0x3a
 800618a:	9103      	str	r1, [sp, #12]
 800618c:	2138      	movs	r1, #56	; 0x38
 800618e:	f04f 0a39 	mov.w	sl, #57	; 0x39
 8006192:	9102      	str	r1, [sp, #8]
 8006194:	f04f 0837 	mov.w	r8, #55	; 0x37
 8006198:	2736      	movs	r7, #54	; 0x36
 800619a:	2035      	movs	r0, #53	; 0x35
 800619c:	e59f      	b.n	8005cde <USBD_AUDIO_Init_Microphone_Descriptor+0x2ea>
 800619e:	2170      	movs	r1, #112	; 0x70
 80061a0:	2571      	movs	r5, #113	; 0x71
 80061a2:	e9cd 5117 	strd	r5, r1, [sp, #92]	; 0x5c
 80061a6:	266f      	movs	r6, #111	; 0x6f
 80061a8:	216e      	movs	r1, #110	; 0x6e
 80061aa:	e9cd 1619 	strd	r1, r6, [sp, #100]	; 0x64
 80061ae:	276d      	movs	r7, #109	; 0x6d
 80061b0:	216c      	movs	r1, #108	; 0x6c
 80061b2:	e9cd 171b 	strd	r1, r7, [sp, #108]	; 0x6c
 80061b6:	f04f 0c6b 	mov.w	ip, #107	; 0x6b
 80061ba:	216a      	movs	r1, #106	; 0x6a
 80061bc:	e9cd 1c1d 	strd	r1, ip, [sp, #116]	; 0x74
 80061c0:	f04f 0e69 	mov.w	lr, #105	; 0x69
 80061c4:	2168      	movs	r1, #104	; 0x68
 80061c6:	e9cd 1e1f 	strd	r1, lr, [sp, #124]	; 0x7c
 80061ca:	f04f 0867 	mov.w	r8, #103	; 0x67
 80061ce:	2166      	movs	r1, #102	; 0x66
 80061d0:	e9cd 1821 	strd	r1, r8, [sp, #132]	; 0x84
 80061d4:	f04f 0965 	mov.w	r9, #101	; 0x65
 80061d8:	2164      	movs	r1, #100	; 0x64
 80061da:	e9cd 1923 	strd	r1, r9, [sp, #140]	; 0x8c
 80061de:	2163      	movs	r1, #99	; 0x63
 80061e0:	910c      	str	r1, [sp, #48]	; 0x30
 80061e2:	2162      	movs	r1, #98	; 0x62
 80061e4:	9131      	str	r1, [sp, #196]	; 0xc4
 80061e6:	2461      	movs	r4, #97	; 0x61
 80061e8:	2160      	movs	r1, #96	; 0x60
 80061ea:	e9cd 412f 	strd	r4, r1, [sp, #188]	; 0xbc
 80061ee:	215f      	movs	r1, #95	; 0x5f
 80061f0:	9106      	str	r1, [sp, #24]
 80061f2:	215e      	movs	r1, #94	; 0x5e
 80061f4:	910d      	str	r1, [sp, #52]	; 0x34
 80061f6:	215d      	movs	r1, #93	; 0x5d
 80061f8:	9107      	str	r1, [sp, #28]
 80061fa:	215c      	movs	r1, #92	; 0x5c
 80061fc:	910e      	str	r1, [sp, #56]	; 0x38
 80061fe:	215b      	movs	r1, #91	; 0x5b
 8006200:	9108      	str	r1, [sp, #32]
 8006202:	215a      	movs	r1, #90	; 0x5a
 8006204:	910f      	str	r1, [sp, #60]	; 0x3c
 8006206:	2159      	movs	r1, #89	; 0x59
 8006208:	9109      	str	r1, [sp, #36]	; 0x24
 800620a:	2158      	movs	r1, #88	; 0x58
 800620c:	9110      	str	r1, [sp, #64]	; 0x40
 800620e:	2157      	movs	r1, #87	; 0x57
 8006210:	910a      	str	r1, [sp, #40]	; 0x28
 8006212:	2156      	movs	r1, #86	; 0x56
 8006214:	9111      	str	r1, [sp, #68]	; 0x44
 8006216:	2155      	movs	r1, #85	; 0x55
 8006218:	910b      	str	r1, [sp, #44]	; 0x2c
 800621a:	2154      	movs	r1, #84	; 0x54
 800621c:	9112      	str	r1, [sp, #72]	; 0x48
 800621e:	2753      	movs	r7, #83	; 0x53
 8006220:	2152      	movs	r1, #82	; 0x52
 8006222:	e9cd 712d 	strd	r7, r1, [sp, #180]	; 0xb4
 8006226:	f04f 0c51 	mov.w	ip, #81	; 0x51
 800622a:	2150      	movs	r1, #80	; 0x50
 800622c:	e9cd c12b 	strd	ip, r1, [sp, #172]	; 0xac
 8006230:	f04f 0e4f 	mov.w	lr, #79	; 0x4f
 8006234:	214e      	movs	r1, #78	; 0x4e
 8006236:	f04f 084d 	mov.w	r8, #77	; 0x4d
 800623a:	e9cd e129 	strd	lr, r1, [sp, #164]	; 0xa4
 800623e:	214c      	movs	r1, #76	; 0x4c
 8006240:	e9cd 8127 	strd	r8, r1, [sp, #156]	; 0x9c
 8006244:	f04f 094b 	mov.w	r9, #75	; 0x4b
 8006248:	214a      	movs	r1, #74	; 0x4a
 800624a:	e9cd 9125 	strd	r9, r1, [sp, #148]	; 0x94
 800624e:	2149      	movs	r1, #73	; 0x49
 8006250:	9113      	str	r1, [sp, #76]	; 0x4c
 8006252:	2148      	movs	r1, #72	; 0x48
 8006254:	9101      	str	r1, [sp, #4]
 8006256:	2147      	movs	r1, #71	; 0x47
 8006258:	9135      	str	r1, [sp, #212]	; 0xd4
 800625a:	2146      	movs	r1, #70	; 0x46
 800625c:	913a      	str	r1, [sp, #232]	; 0xe8
 800625e:	2145      	movs	r1, #69	; 0x45
 8006260:	9134      	str	r1, [sp, #208]	; 0xd0
 8006262:	2144      	movs	r1, #68	; 0x44
 8006264:	9139      	str	r1, [sp, #228]	; 0xe4
 8006266:	2143      	movs	r1, #67	; 0x43
 8006268:	9133      	str	r1, [sp, #204]	; 0xcc
 800626a:	2142      	movs	r1, #66	; 0x42
 800626c:	9138      	str	r1, [sp, #224]	; 0xe0
 800626e:	2141      	movs	r1, #65	; 0x41
 8006270:	9132      	str	r1, [sp, #200]	; 0xc8
 8006272:	f04f 0940 	mov.w	r9, #64	; 0x40
 8006276:	213f      	movs	r1, #63	; 0x3f
 8006278:	e9cd 1936 	strd	r1, r9, [sp, #216]	; 0xd8
 800627c:	213e      	movs	r1, #62	; 0x3e
 800627e:	9116      	str	r1, [sp, #88]	; 0x58
 8006280:	213d      	movs	r1, #61	; 0x3d
 8006282:	9105      	str	r1, [sp, #20]
 8006284:	213c      	movs	r1, #60	; 0x3c
 8006286:	9115      	str	r1, [sp, #84]	; 0x54
 8006288:	213b      	movs	r1, #59	; 0x3b
 800628a:	9104      	str	r1, [sp, #16]
 800628c:	213a      	movs	r1, #58	; 0x3a
 800628e:	9114      	str	r1, [sp, #80]	; 0x50
 8006290:	2139      	movs	r1, #57	; 0x39
 8006292:	9103      	str	r1, [sp, #12]
 8006294:	2137      	movs	r1, #55	; 0x37
 8006296:	f04f 0a38 	mov.w	sl, #56	; 0x38
 800629a:	9102      	str	r1, [sp, #8]
 800629c:	f04f 0836 	mov.w	r8, #54	; 0x36
 80062a0:	2735      	movs	r7, #53	; 0x35
 80062a2:	2034      	movs	r0, #52	; 0x34
 80062a4:	e51b      	b.n	8005cde <USBD_AUDIO_Init_Microphone_Descriptor+0x2ea>
 80062a6:	2770      	movs	r7, #112	; 0x70
 80062a8:	216f      	movs	r1, #111	; 0x6f
 80062aa:	e9cd 7117 	strd	r7, r1, [sp, #92]	; 0x5c
 80062ae:	f04f 0c6e 	mov.w	ip, #110	; 0x6e
 80062b2:	216d      	movs	r1, #109	; 0x6d
 80062b4:	e9cd 1c19 	strd	r1, ip, [sp, #100]	; 0x64
 80062b8:	f04f 0e6c 	mov.w	lr, #108	; 0x6c
 80062bc:	216b      	movs	r1, #107	; 0x6b
 80062be:	e9cd 1e1b 	strd	r1, lr, [sp, #108]	; 0x6c
 80062c2:	f04f 086a 	mov.w	r8, #106	; 0x6a
 80062c6:	2169      	movs	r1, #105	; 0x69
 80062c8:	e9cd 181d 	strd	r1, r8, [sp, #116]	; 0x74
 80062cc:	f04f 0968 	mov.w	r9, #104	; 0x68
 80062d0:	2167      	movs	r1, #103	; 0x67
 80062d2:	e9cd 191f 	strd	r1, r9, [sp, #124]	; 0x7c
 80062d6:	f04f 0a66 	mov.w	sl, #102	; 0x66
 80062da:	2165      	movs	r1, #101	; 0x65
 80062dc:	e9cd 1a21 	strd	r1, sl, [sp, #132]	; 0x84
 80062e0:	2064      	movs	r0, #100	; 0x64
 80062e2:	2163      	movs	r1, #99	; 0x63
 80062e4:	e9cd 1023 	strd	r1, r0, [sp, #140]	; 0x8c
 80062e8:	2162      	movs	r1, #98	; 0x62
 80062ea:	910c      	str	r1, [sp, #48]	; 0x30
 80062ec:	2161      	movs	r1, #97	; 0x61
 80062ee:	9131      	str	r1, [sp, #196]	; 0xc4
 80062f0:	2660      	movs	r6, #96	; 0x60
 80062f2:	215f      	movs	r1, #95	; 0x5f
 80062f4:	e9cd 612f 	strd	r6, r1, [sp, #188]	; 0xbc
 80062f8:	215e      	movs	r1, #94	; 0x5e
 80062fa:	9106      	str	r1, [sp, #24]
 80062fc:	215d      	movs	r1, #93	; 0x5d
 80062fe:	910d      	str	r1, [sp, #52]	; 0x34
 8006300:	215c      	movs	r1, #92	; 0x5c
 8006302:	9107      	str	r1, [sp, #28]
 8006304:	215b      	movs	r1, #91	; 0x5b
 8006306:	910e      	str	r1, [sp, #56]	; 0x38
 8006308:	215a      	movs	r1, #90	; 0x5a
 800630a:	9108      	str	r1, [sp, #32]
 800630c:	2159      	movs	r1, #89	; 0x59
 800630e:	910f      	str	r1, [sp, #60]	; 0x3c
 8006310:	2158      	movs	r1, #88	; 0x58
 8006312:	9109      	str	r1, [sp, #36]	; 0x24
 8006314:	2157      	movs	r1, #87	; 0x57
 8006316:	9110      	str	r1, [sp, #64]	; 0x40
 8006318:	2156      	movs	r1, #86	; 0x56
 800631a:	910a      	str	r1, [sp, #40]	; 0x28
 800631c:	2155      	movs	r1, #85	; 0x55
 800631e:	9111      	str	r1, [sp, #68]	; 0x44
 8006320:	2154      	movs	r1, #84	; 0x54
 8006322:	910b      	str	r1, [sp, #44]	; 0x2c
 8006324:	2153      	movs	r1, #83	; 0x53
 8006326:	9112      	str	r1, [sp, #72]	; 0x48
 8006328:	f04f 0e52 	mov.w	lr, #82	; 0x52
 800632c:	2151      	movs	r1, #81	; 0x51
 800632e:	e9cd e12d 	strd	lr, r1, [sp, #180]	; 0xb4
 8006332:	f04f 0850 	mov.w	r8, #80	; 0x50
 8006336:	214f      	movs	r1, #79	; 0x4f
 8006338:	e9cd 812b 	strd	r8, r1, [sp, #172]	; 0xac
 800633c:	f04f 094e 	mov.w	r9, #78	; 0x4e
 8006340:	214d      	movs	r1, #77	; 0x4d
 8006342:	f04f 0a4c 	mov.w	sl, #76	; 0x4c
 8006346:	e9cd 9129 	strd	r9, r1, [sp, #164]	; 0xa4
 800634a:	214b      	movs	r1, #75	; 0x4b
 800634c:	e9cd a127 	strd	sl, r1, [sp, #156]	; 0x9c
 8006350:	204a      	movs	r0, #74	; 0x4a
 8006352:	2149      	movs	r1, #73	; 0x49
 8006354:	e9cd 0125 	strd	r0, r1, [sp, #148]	; 0x94
 8006358:	2148      	movs	r1, #72	; 0x48
 800635a:	9113      	str	r1, [sp, #76]	; 0x4c
 800635c:	2147      	movs	r1, #71	; 0x47
 800635e:	9101      	str	r1, [sp, #4]
 8006360:	2146      	movs	r1, #70	; 0x46
 8006362:	9135      	str	r1, [sp, #212]	; 0xd4
 8006364:	2145      	movs	r1, #69	; 0x45
 8006366:	913a      	str	r1, [sp, #232]	; 0xe8
 8006368:	2144      	movs	r1, #68	; 0x44
 800636a:	9134      	str	r1, [sp, #208]	; 0xd0
 800636c:	2143      	movs	r1, #67	; 0x43
 800636e:	9139      	str	r1, [sp, #228]	; 0xe4
 8006370:	2142      	movs	r1, #66	; 0x42
 8006372:	9133      	str	r1, [sp, #204]	; 0xcc
 8006374:	2141      	movs	r1, #65	; 0x41
 8006376:	9138      	str	r1, [sp, #224]	; 0xe0
 8006378:	2140      	movs	r1, #64	; 0x40
 800637a:	203f      	movs	r0, #63	; 0x3f
 800637c:	9132      	str	r1, [sp, #200]	; 0xc8
 800637e:	213e      	movs	r1, #62	; 0x3e
 8006380:	e9cd 1036 	strd	r1, r0, [sp, #216]	; 0xd8
 8006384:	213d      	movs	r1, #61	; 0x3d
 8006386:	9116      	str	r1, [sp, #88]	; 0x58
 8006388:	213c      	movs	r1, #60	; 0x3c
 800638a:	9105      	str	r1, [sp, #20]
 800638c:	213b      	movs	r1, #59	; 0x3b
 800638e:	9115      	str	r1, [sp, #84]	; 0x54
 8006390:	213a      	movs	r1, #58	; 0x3a
 8006392:	9104      	str	r1, [sp, #16]
 8006394:	2139      	movs	r1, #57	; 0x39
 8006396:	9114      	str	r1, [sp, #80]	; 0x50
 8006398:	2138      	movs	r1, #56	; 0x38
 800639a:	9103      	str	r1, [sp, #12]
 800639c:	2136      	movs	r1, #54	; 0x36
 800639e:	f04f 0a37 	mov.w	sl, #55	; 0x37
 80063a2:	9102      	str	r1, [sp, #8]
 80063a4:	f04f 0835 	mov.w	r8, #53	; 0x35
 80063a8:	2734      	movs	r7, #52	; 0x34
 80063aa:	2033      	movs	r0, #51	; 0x33
 80063ac:	e497      	b.n	8005cde <USBD_AUDIO_Init_Microphone_Descriptor+0x2ea>
 80063ae:	216e      	movs	r1, #110	; 0x6e
 80063b0:	f04f 0e6f 	mov.w	lr, #111	; 0x6f
 80063b4:	e9cd e117 	strd	lr, r1, [sp, #92]	; 0x5c
 80063b8:	f04f 086d 	mov.w	r8, #109	; 0x6d
 80063bc:	216c      	movs	r1, #108	; 0x6c
 80063be:	e9cd 1819 	strd	r1, r8, [sp, #100]	; 0x64
 80063c2:	f04f 096b 	mov.w	r9, #107	; 0x6b
 80063c6:	216a      	movs	r1, #106	; 0x6a
 80063c8:	e9cd 191b 	strd	r1, r9, [sp, #108]	; 0x6c
 80063cc:	f04f 0a69 	mov.w	sl, #105	; 0x69
 80063d0:	2168      	movs	r1, #104	; 0x68
 80063d2:	e9cd 1a1d 	strd	r1, sl, [sp, #116]	; 0x74
 80063d6:	2067      	movs	r0, #103	; 0x67
 80063d8:	2166      	movs	r1, #102	; 0x66
 80063da:	e9cd 101f 	strd	r1, r0, [sp, #124]	; 0x7c
 80063de:	2465      	movs	r4, #101	; 0x65
 80063e0:	2164      	movs	r1, #100	; 0x64
 80063e2:	e9cd 1421 	strd	r1, r4, [sp, #132]	; 0x84
 80063e6:	2563      	movs	r5, #99	; 0x63
 80063e8:	2162      	movs	r1, #98	; 0x62
 80063ea:	e9cd 1523 	strd	r1, r5, [sp, #140]	; 0x8c
 80063ee:	2161      	movs	r1, #97	; 0x61
 80063f0:	910c      	str	r1, [sp, #48]	; 0x30
 80063f2:	2160      	movs	r1, #96	; 0x60
 80063f4:	9131      	str	r1, [sp, #196]	; 0xc4
 80063f6:	f04f 0c5f 	mov.w	ip, #95	; 0x5f
 80063fa:	215e      	movs	r1, #94	; 0x5e
 80063fc:	e9cd c12f 	strd	ip, r1, [sp, #188]	; 0xbc
 8006400:	215d      	movs	r1, #93	; 0x5d
 8006402:	9106      	str	r1, [sp, #24]
 8006404:	215c      	movs	r1, #92	; 0x5c
 8006406:	910d      	str	r1, [sp, #52]	; 0x34
 8006408:	215b      	movs	r1, #91	; 0x5b
 800640a:	9107      	str	r1, [sp, #28]
 800640c:	215a      	movs	r1, #90	; 0x5a
 800640e:	910e      	str	r1, [sp, #56]	; 0x38
 8006410:	2159      	movs	r1, #89	; 0x59
 8006412:	9108      	str	r1, [sp, #32]
 8006414:	2158      	movs	r1, #88	; 0x58
 8006416:	910f      	str	r1, [sp, #60]	; 0x3c
 8006418:	2157      	movs	r1, #87	; 0x57
 800641a:	9109      	str	r1, [sp, #36]	; 0x24
 800641c:	2156      	movs	r1, #86	; 0x56
 800641e:	9110      	str	r1, [sp, #64]	; 0x40
 8006420:	2155      	movs	r1, #85	; 0x55
 8006422:	910a      	str	r1, [sp, #40]	; 0x28
 8006424:	2154      	movs	r1, #84	; 0x54
 8006426:	9111      	str	r1, [sp, #68]	; 0x44
 8006428:	2153      	movs	r1, #83	; 0x53
 800642a:	910b      	str	r1, [sp, #44]	; 0x2c
 800642c:	2152      	movs	r1, #82	; 0x52
 800642e:	9112      	str	r1, [sp, #72]	; 0x48
 8006430:	f04f 0951 	mov.w	r9, #81	; 0x51
 8006434:	2150      	movs	r1, #80	; 0x50
 8006436:	e9cd 912d 	strd	r9, r1, [sp, #180]	; 0xb4
 800643a:	f04f 0a4f 	mov.w	sl, #79	; 0x4f
 800643e:	214e      	movs	r1, #78	; 0x4e
 8006440:	e9cd a12b 	strd	sl, r1, [sp, #172]	; 0xac
 8006444:	204d      	movs	r0, #77	; 0x4d
 8006446:	214c      	movs	r1, #76	; 0x4c
 8006448:	e9cd 0129 	strd	r0, r1, [sp, #164]	; 0xa4
 800644c:	244b      	movs	r4, #75	; 0x4b
 800644e:	214a      	movs	r1, #74	; 0x4a
 8006450:	2549      	movs	r5, #73	; 0x49
 8006452:	e9cd 4127 	strd	r4, r1, [sp, #156]	; 0x9c
 8006456:	2148      	movs	r1, #72	; 0x48
 8006458:	e9cd 5125 	strd	r5, r1, [sp, #148]	; 0x94
 800645c:	2147      	movs	r1, #71	; 0x47
 800645e:	9113      	str	r1, [sp, #76]	; 0x4c
 8006460:	2146      	movs	r1, #70	; 0x46
 8006462:	9101      	str	r1, [sp, #4]
 8006464:	2145      	movs	r1, #69	; 0x45
 8006466:	9135      	str	r1, [sp, #212]	; 0xd4
 8006468:	2144      	movs	r1, #68	; 0x44
 800646a:	913a      	str	r1, [sp, #232]	; 0xe8
 800646c:	2143      	movs	r1, #67	; 0x43
 800646e:	9134      	str	r1, [sp, #208]	; 0xd0
 8006470:	2142      	movs	r1, #66	; 0x42
 8006472:	9139      	str	r1, [sp, #228]	; 0xe4
 8006474:	2141      	movs	r1, #65	; 0x41
 8006476:	9133      	str	r1, [sp, #204]	; 0xcc
 8006478:	2140      	movs	r1, #64	; 0x40
 800647a:	9138      	str	r1, [sp, #224]	; 0xe0
 800647c:	213f      	movs	r1, #63	; 0x3f
 800647e:	9132      	str	r1, [sp, #200]	; 0xc8
 8006480:	253e      	movs	r5, #62	; 0x3e
 8006482:	213d      	movs	r1, #61	; 0x3d
 8006484:	e9cd 1536 	strd	r1, r5, [sp, #216]	; 0xd8
 8006488:	213c      	movs	r1, #60	; 0x3c
 800648a:	9116      	str	r1, [sp, #88]	; 0x58
 800648c:	213b      	movs	r1, #59	; 0x3b
 800648e:	9105      	str	r1, [sp, #20]
 8006490:	213a      	movs	r1, #58	; 0x3a
 8006492:	9115      	str	r1, [sp, #84]	; 0x54
 8006494:	2139      	movs	r1, #57	; 0x39
 8006496:	9104      	str	r1, [sp, #16]
 8006498:	2138      	movs	r1, #56	; 0x38
 800649a:	9114      	str	r1, [sp, #80]	; 0x50
 800649c:	2137      	movs	r1, #55	; 0x37
 800649e:	9103      	str	r1, [sp, #12]
 80064a0:	2135      	movs	r1, #53	; 0x35
 80064a2:	f04f 0a36 	mov.w	sl, #54	; 0x36
 80064a6:	9102      	str	r1, [sp, #8]
 80064a8:	f04f 0834 	mov.w	r8, #52	; 0x34
 80064ac:	2733      	movs	r7, #51	; 0x33
 80064ae:	2032      	movs	r0, #50	; 0x32
 80064b0:	e415      	b.n	8005cde <USBD_AUDIO_Init_Microphone_Descriptor+0x2ea>
 80064b2:	bf00      	nop

080064b4 <USBD_Init>:
                             USBD_DescriptorsTypeDef *pdesc, uint8_t id)
{
  USBD_StatusTypeDef ret;

  /* Check whether the USB Host handle is valid */
  if (pdev == NULL)
 80064b4:	b178      	cbz	r0, 80064d6 <USBD_Init+0x22>
    pdev->NumClasses = 0;
    pdev->classId = 0;
  }
#else
  /* Unlink previous class*/
  pdev->pClass[0] = NULL;
 80064b6:	2300      	movs	r3, #0
 80064b8:	f8c0 32b8 	str.w	r3, [r0, #696]	; 0x2b8
  pdev->pUserData[0] = NULL;
 80064bc:	f8c0 32c4 	str.w	r3, [r0, #708]	; 0x2c4
#endif /* USE_USBD_COMPOSITE */

  pdev->pConfDesc = NULL;
 80064c0:	f8c0 32d0 	str.w	r3, [r0, #720]	; 0x2d0

  /* Assign USBD Descriptors */
  if (pdesc != NULL)
 80064c4:	b109      	cbz	r1, 80064ca <USBD_Init+0x16>
  {
    pdev->pDesc = pdesc;
 80064c6:	f8c0 12b4 	str.w	r1, [r0, #692]	; 0x2b4
  }

  /* Set Device initial State */
  pdev->dev_state = USBD_STATE_DEFAULT;
 80064ca:	2301      	movs	r3, #1
 80064cc:	f880 329c 	strb.w	r3, [r0, #668]	; 0x29c
  pdev->id = id;
 80064d0:	7002      	strb	r2, [r0, #0]

  /* Initialize low level driver */
  ret = USBD_LL_Init(pdev);
 80064d2:	f7fb b8f9 	b.w	80016c8 <USBD_LL_Init>

  return ret;
}
 80064d6:	2003      	movs	r0, #3
 80064d8:	4770      	bx	lr
 80064da:	bf00      	nop

080064dc <USBD_RegisterClass>:
  * @param  pDevice : Device Handle
  * @param  pclass: Class handle
  * @retval USBD Status
  */
USBD_StatusTypeDef USBD_RegisterClass(USBD_HandleTypeDef *pdev, USBD_ClassTypeDef *pclass)
{
 80064dc:	b510      	push	{r4, lr}
 80064de:	b082      	sub	sp, #8
  uint16_t len = 0U;
 80064e0:	2300      	movs	r3, #0
 80064e2:	f8ad 3006 	strh.w	r3, [sp, #6]

  if (pclass == NULL)
 80064e6:	b189      	cbz	r1, 800650c <USBD_RegisterClass+0x30>
  if (pdev->pClass[pdev->classId]->GetHSConfigDescriptor != NULL)
  {
    pdev->pConfDesc = (void *)pdev->pClass[pdev->classId]->GetHSConfigDescriptor(&len);
  }
#else /* Default USE_USB_FS */
  if (pdev->pClass[pdev->classId]->GetFSConfigDescriptor != NULL)
 80064e8:	6acb      	ldr	r3, [r1, #44]	; 0x2c
  pdev->pClass[0] = pclass;
 80064ea:	f8c0 12b8 	str.w	r1, [r0, #696]	; 0x2b8
  if (pdev->pClass[pdev->classId]->GetFSConfigDescriptor != NULL)
 80064ee:	4604      	mov	r4, r0
 80064f0:	b123      	cbz	r3, 80064fc <USBD_RegisterClass+0x20>
  {
    pdev->pConfDesc = (void *)pdev->pClass[pdev->classId]->GetFSConfigDescriptor(&len);
 80064f2:	f10d 0006 	add.w	r0, sp, #6
 80064f6:	4798      	blx	r3
 80064f8:	f8c4 02d0 	str.w	r0, [r4, #720]	; 0x2d0
  }
#endif /* USE_USB_FS */

  /* Increment the NumClasses */
  pdev->NumClasses ++;
 80064fc:	f8d4 32d8 	ldr.w	r3, [r4, #728]	; 0x2d8

  return USBD_OK;
 8006500:	2000      	movs	r0, #0
  pdev->NumClasses ++;
 8006502:	3301      	adds	r3, #1
 8006504:	f8c4 32d8 	str.w	r3, [r4, #728]	; 0x2d8
}
 8006508:	b002      	add	sp, #8
 800650a:	bd10      	pop	{r4, pc}
    return USBD_FAIL;
 800650c:	2003      	movs	r0, #3
}
 800650e:	b002      	add	sp, #8
 8006510:	bd10      	pop	{r4, pc}
 8006512:	bf00      	nop

08006514 <USBD_Start>:
#ifdef USE_USBD_COMPOSITE
  pdev->classId = 0U;
#endif /* USE_USBD_COMPOSITE */

  /* Start the low level driver  */
  return USBD_LL_Start(pdev);
 8006514:	f7fb b908 	b.w	8001728 <USBD_LL_Start>

08006518 <USBD_SetClassConfig>:
        }
      }
    }
  }
#else
  if (pdev->pClass[0] != NULL)
 8006518:	f8d0 32b8 	ldr.w	r3, [r0, #696]	; 0x2b8
 800651c:	b10b      	cbz	r3, 8006522 <USBD_SetClassConfig+0xa>
  {
    /* Set configuration and Start the Class */
    ret = (USBD_StatusTypeDef)pdev->pClass[0]->Init(pdev, cfgidx);
 800651e:	681b      	ldr	r3, [r3, #0]
 8006520:	4718      	bx	r3
  }
#endif /* USE_USBD_COMPOSITE */

  return ret;
}
 8006522:	4618      	mov	r0, r3
 8006524:	4770      	bx	lr
 8006526:	bf00      	nop

08006528 <USBD_ClrClassConfig>:
  * @param  pdev: device instance
  * @param  cfgidx: configuration index
  * @retval status: USBD_StatusTypeDef
  */
USBD_StatusTypeDef USBD_ClrClassConfig(USBD_HandleTypeDef *pdev, uint8_t cfgidx)
{
 8006528:	b508      	push	{r3, lr}
      }
    }
  }
#else
  /* Clear configuration  and De-initialize the Class process */
  if (pdev->pClass[0]->DeInit(pdev, cfgidx) != 0U)
 800652a:	f8d0 32b8 	ldr.w	r3, [r0, #696]	; 0x2b8
 800652e:	685b      	ldr	r3, [r3, #4]
 8006530:	4798      	blx	r3
  {
    ret = USBD_FAIL;
 8006532:	2800      	cmp	r0, #0
  }
#endif /* USE_USBD_COMPOSITE */

  return ret;
}
 8006534:	bf18      	it	ne
 8006536:	2003      	movne	r0, #3
 8006538:	bd08      	pop	{r3, pc}
 800653a:	bf00      	nop

0800653c <USBD_LL_SetupStage>:
  *         Handle the setup stage
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_SetupStage(USBD_HandleTypeDef *pdev, uint8_t *psetup)
{
 800653c:	b538      	push	{r3, r4, r5, lr}
 800653e:	4604      	mov	r4, r0
  USBD_StatusTypeDef ret;

  USBD_ParseSetupRequest(&pdev->request, psetup);
 8006540:	f200 25aa 	addw	r5, r0, #682	; 0x2aa
 8006544:	4628      	mov	r0, r5
 8006546:	f000 fbfb 	bl	8006d40 <USBD_ParseSetupRequest>

  pdev->ep0_state = USBD_EP0_SETUP;

  pdev->ep0_data_len = pdev->request.wLength;

  switch (pdev->request.bmRequest & 0x1FU)
 800654a:	f894 12aa 	ldrb.w	r1, [r4, #682]	; 0x2aa
  pdev->ep0_data_len = pdev->request.wLength;
 800654e:	f8b4 22b0 	ldrh.w	r2, [r4, #688]	; 0x2b0
 8006552:	f8c4 2298 	str.w	r2, [r4, #664]	; 0x298
  pdev->ep0_state = USBD_EP0_SETUP;
 8006556:	2301      	movs	r3, #1
 8006558:	f8c4 3294 	str.w	r3, [r4, #660]	; 0x294
  switch (pdev->request.bmRequest & 0x1FU)
 800655c:	f001 031f 	and.w	r3, r1, #31
 8006560:	2b01      	cmp	r3, #1
 8006562:	d009      	beq.n	8006578 <USBD_LL_SetupStage+0x3c>
 8006564:	2b02      	cmp	r3, #2
 8006566:	d013      	beq.n	8006590 <USBD_LL_SetupStage+0x54>
 8006568:	b163      	cbz	r3, 8006584 <USBD_LL_SetupStage+0x48>
    case USB_REQ_RECIPIENT_ENDPOINT:
      ret = USBD_StdEPReq(pdev, &pdev->request);
      break;

    default:
      ret = USBD_LL_StallEP(pdev, (pdev->request.bmRequest & 0x80U));
 800656a:	4620      	mov	r0, r4
 800656c:	f001 0180 	and.w	r1, r1, #128	; 0x80
      break;
  }

  return ret;
}
 8006570:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      ret = USBD_LL_StallEP(pdev, (pdev->request.bmRequest & 0x80U));
 8006574:	f7fb b8fa 	b.w	800176c <USBD_LL_StallEP>
      ret = USBD_StdItfReq(pdev, &pdev->request);
 8006578:	4629      	mov	r1, r5
 800657a:	4620      	mov	r0, r4
}
 800657c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      ret = USBD_StdItfReq(pdev, &pdev->request);
 8006580:	f000 baf8 	b.w	8006b74 <USBD_StdItfReq>
      ret = USBD_StdDevReq(pdev, &pdev->request);
 8006584:	4629      	mov	r1, r5
 8006586:	4620      	mov	r0, r4
}
 8006588:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      ret = USBD_StdDevReq(pdev, &pdev->request);
 800658c:	f000 b938 	b.w	8006800 <USBD_StdDevReq>
      ret = USBD_StdEPReq(pdev, &pdev->request);
 8006590:	4629      	mov	r1, r5
 8006592:	4620      	mov	r0, r4
}
 8006594:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      ret = USBD_StdEPReq(pdev, &pdev->request);
 8006598:	f000 bb26 	b.w	8006be8 <USBD_StdEPReq>

0800659c <USBD_LL_DataOutStage>:
  * @param  pdata: data pointer
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_DataOutStage(USBD_HandleTypeDef *pdev,
                                        uint8_t epnum, uint8_t *pdata)
{
 800659c:	b510      	push	{r4, lr}
 800659e:	4604      	mov	r4, r0
  USBD_EndpointTypeDef *pep;
  USBD_StatusTypeDef ret = USBD_OK;
  uint8_t idx;

  if (epnum == 0U)
 80065a0:	b931      	cbnz	r1, 80065b0 <USBD_LL_DataOutStage+0x14>
 80065a2:	4694      	mov	ip, r2
  {
    pep = &pdev->ep_out[0];

    if (pdev->ep0_state == USBD_EP0_DATA_OUT)
 80065a4:	f8d0 2294 	ldr.w	r2, [r0, #660]	; 0x294
 80065a8:	2a03      	cmp	r2, #3
 80065aa:	d010      	beq.n	80065ce <USBD_LL_DataOutStage+0x32>
      }
    }
  }

  return USBD_OK;
}
 80065ac:	2000      	movs	r0, #0
 80065ae:	bd10      	pop	{r4, pc}
      if (pdev->dev_state == USBD_STATE_CONFIGURED)
 80065b0:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 80065b4:	2b03      	cmp	r3, #3
 80065b6:	d1f9      	bne.n	80065ac <USBD_LL_DataOutStage+0x10>
        if (pdev->pClass[idx]->DataOut != NULL)
 80065b8:	f8d0 32b8 	ldr.w	r3, [r0, #696]	; 0x2b8
 80065bc:	699b      	ldr	r3, [r3, #24]
 80065be:	2b00      	cmp	r3, #0
 80065c0:	d0f4      	beq.n	80065ac <USBD_LL_DataOutStage+0x10>
          pdev->classId = idx;
 80065c2:	2200      	movs	r2, #0
}
 80065c4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
          pdev->classId = idx;
 80065c8:	f8c0 22d4 	str.w	r2, [r0, #724]	; 0x2d4
          ret = (USBD_StatusTypeDef)pdev->pClass[idx]->DataOut(pdev, epnum);
 80065cc:	4718      	bx	r3
 80065ce:	460b      	mov	r3, r1
      if (pep->rem_length > pep->maxpacket)
 80065d0:	e9d0 1257 	ldrd	r1, r2, [r0, #348]	; 0x15c
 80065d4:	4291      	cmp	r1, r2
 80065d6:	d808      	bhi.n	80065ea <USBD_LL_DataOutStage+0x4e>
          if (pdev->dev_state == USBD_STATE_CONFIGURED)
 80065d8:	f890 229c 	ldrb.w	r2, [r0, #668]	; 0x29c
 80065dc:	2a03      	cmp	r2, #3
 80065de:	d00e      	beq.n	80065fe <USBD_LL_DataOutStage+0x62>
        (void)USBD_CtlSendStatus(pdev);
 80065e0:	4620      	mov	r0, r4
 80065e2:	f000 fc1b 	bl	8006e1c <USBD_CtlSendStatus>
}
 80065e6:	2000      	movs	r0, #0
 80065e8:	bd10      	pop	{r4, pc}
        pep->rem_length -= pep->maxpacket;
 80065ea:	1a89      	subs	r1, r1, r2
        (void)USBD_CtlContinueRx(pdev, pdata, MIN(pep->rem_length, pep->maxpacket));
 80065ec:	428a      	cmp	r2, r1
 80065ee:	bf28      	it	cs
 80065f0:	460a      	movcs	r2, r1
        pep->rem_length -= pep->maxpacket;
 80065f2:	f8c0 115c 	str.w	r1, [r0, #348]	; 0x15c
        (void)USBD_CtlContinueRx(pdev, pdata, MIN(pep->rem_length, pep->maxpacket));
 80065f6:	4661      	mov	r1, ip
 80065f8:	f000 fc08 	bl	8006e0c <USBD_CtlContinueRx>
 80065fc:	e7d6      	b.n	80065ac <USBD_LL_DataOutStage+0x10>
            if (pdev->pClass[idx]->EP0_RxReady != NULL)
 80065fe:	f8d0 22b8 	ldr.w	r2, [r0, #696]	; 0x2b8
 8006602:	6912      	ldr	r2, [r2, #16]
 8006604:	2a00      	cmp	r2, #0
 8006606:	d0eb      	beq.n	80065e0 <USBD_LL_DataOutStage+0x44>
              pdev->classId = idx;
 8006608:	f8c0 32d4 	str.w	r3, [r0, #724]	; 0x2d4
              pdev->pClass[idx]->EP0_RxReady(pdev);
 800660c:	4790      	blx	r2
 800660e:	e7e7      	b.n	80065e0 <USBD_LL_DataOutStage+0x44>

08006610 <USBD_LL_DataInStage>:
  * @param  epnum: endpoint index
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_DataInStage(USBD_HandleTypeDef *pdev,
                                       uint8_t epnum, uint8_t *pdata)
{
 8006610:	b570      	push	{r4, r5, r6, lr}
 8006612:	4604      	mov	r4, r0
  USBD_EndpointTypeDef *pep;
  USBD_StatusTypeDef ret;
  uint8_t idx;

  if (epnum == 0U)
 8006614:	b961      	cbnz	r1, 8006630 <USBD_LL_DataInStage+0x20>
 8006616:	4613      	mov	r3, r2
  {
    pep = &pdev->ep_in[0];

    if (pdev->ep0_state == USBD_EP0_DATA_IN)
 8006618:	f8d0 2294 	ldr.w	r2, [r0, #660]	; 0x294
 800661c:	2a02      	cmp	r2, #2
 800661e:	d016      	beq.n	800664e <USBD_LL_DataInStage+0x3e>
        (void)USBD_LL_StallEP(pdev, 0x80U);
      }
#endif
    }

    if (pdev->dev_test_mode != 0U)
 8006620:	f894 32a0 	ldrb.w	r3, [r4, #672]	; 0x2a0
 8006624:	b113      	cbz	r3, 800662c <USBD_LL_DataInStage+0x1c>
    {
      (void)USBD_RunTestMode(pdev);
      pdev->dev_test_mode = 0U;
 8006626:	2300      	movs	r3, #0
 8006628:	f884 32a0 	strb.w	r3, [r4, #672]	; 0x2a0
      }
    }
  }

  return USBD_OK;
}
 800662c:	2000      	movs	r0, #0
 800662e:	bd70      	pop	{r4, r5, r6, pc}
      if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8006630:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 8006634:	2b03      	cmp	r3, #3
 8006636:	d1f9      	bne.n	800662c <USBD_LL_DataInStage+0x1c>
        if (pdev->pClass[idx]->DataIn != NULL)
 8006638:	f8d0 32b8 	ldr.w	r3, [r0, #696]	; 0x2b8
 800663c:	695b      	ldr	r3, [r3, #20]
 800663e:	2b00      	cmp	r3, #0
 8006640:	d0f4      	beq.n	800662c <USBD_LL_DataInStage+0x1c>
          pdev->classId = idx;
 8006642:	2200      	movs	r2, #0
}
 8006644:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
          pdev->classId = idx;
 8006648:	f8c0 22d4 	str.w	r2, [r0, #724]	; 0x2d4
          ret = (USBD_StatusTypeDef)pdev->pClass[idx]->DataIn(pdev, epnum);
 800664c:	4718      	bx	r3
      if (pep->rem_length > pep->maxpacket)
 800664e:	e9d0 2607 	ldrd	r2, r6, [r0, #28]
 8006652:	42b2      	cmp	r2, r6
 8006654:	460d      	mov	r5, r1
 8006656:	d810      	bhi.n	800667a <USBD_LL_DataInStage+0x6a>
        if ((pep->maxpacket == pep->rem_length) &&
 8006658:	d01b      	beq.n	8006692 <USBD_LL_DataInStage+0x82>
          if (pdev->dev_state == USBD_STATE_CONFIGURED)
 800665a:	f894 329c 	ldrb.w	r3, [r4, #668]	; 0x29c
 800665e:	2b03      	cmp	r3, #3
 8006660:	d024      	beq.n	80066ac <USBD_LL_DataInStage+0x9c>
          (void)USBD_LL_StallEP(pdev, 0x80U);
 8006662:	2180      	movs	r1, #128	; 0x80
 8006664:	4620      	mov	r0, r4
 8006666:	f7fb f881 	bl	800176c <USBD_LL_StallEP>
          (void)USBD_CtlReceiveStatus(pdev);
 800666a:	4620      	mov	r0, r4
 800666c:	f000 fbe2 	bl	8006e34 <USBD_CtlReceiveStatus>
    if (pdev->dev_test_mode != 0U)
 8006670:	f894 32a0 	ldrb.w	r3, [r4, #672]	; 0x2a0
 8006674:	2b00      	cmp	r3, #0
 8006676:	d0d9      	beq.n	800662c <USBD_LL_DataInStage+0x1c>
 8006678:	e7d5      	b.n	8006626 <USBD_LL_DataInStage+0x16>
        pep->rem_length -= pep->maxpacket;
 800667a:	1b92      	subs	r2, r2, r6
 800667c:	61c2      	str	r2, [r0, #28]
        (void)USBD_CtlContinueSendData(pdev, pdata, pep->rem_length);
 800667e:	4619      	mov	r1, r3
 8006680:	f000 fbae 	bl	8006de0 <USBD_CtlContinueSendData>
          (void)USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
 8006684:	462b      	mov	r3, r5
 8006686:	462a      	mov	r2, r5
 8006688:	4629      	mov	r1, r5
 800668a:	4620      	mov	r0, r4
 800668c:	f7fb f8a2 	bl	80017d4 <USBD_LL_PrepareReceive>
 8006690:	e7c6      	b.n	8006620 <USBD_LL_DataInStage+0x10>
            (pep->total_length >= pep->maxpacket) &&
 8006692:	6983      	ldr	r3, [r0, #24]
        if ((pep->maxpacket == pep->rem_length) &&
 8006694:	429a      	cmp	r2, r3
 8006696:	d8e0      	bhi.n	800665a <USBD_LL_DataInStage+0x4a>
            (pep->total_length >= pep->maxpacket) &&
 8006698:	f8d0 2298 	ldr.w	r2, [r0, #664]	; 0x298
 800669c:	4293      	cmp	r3, r2
 800669e:	d2dc      	bcs.n	800665a <USBD_LL_DataInStage+0x4a>
          (void)USBD_CtlContinueSendData(pdev, NULL, 0U);
 80066a0:	460a      	mov	r2, r1
 80066a2:	f000 fb9d 	bl	8006de0 <USBD_CtlContinueSendData>
          pdev->ep0_data_len = 0U;
 80066a6:	f8c4 5298 	str.w	r5, [r4, #664]	; 0x298
 80066aa:	e7eb      	b.n	8006684 <USBD_LL_DataInStage+0x74>
            if (pdev->pClass[0]->EP0_TxSent != NULL)
 80066ac:	f8d4 32b8 	ldr.w	r3, [r4, #696]	; 0x2b8
 80066b0:	68db      	ldr	r3, [r3, #12]
 80066b2:	2b00      	cmp	r3, #0
 80066b4:	d0d5      	beq.n	8006662 <USBD_LL_DataInStage+0x52>
              pdev->classId = 0U;
 80066b6:	2200      	movs	r2, #0
 80066b8:	f8c4 22d4 	str.w	r2, [r4, #724]	; 0x2d4
              pdev->pClass[0]->EP0_TxSent(pdev);
 80066bc:	4620      	mov	r0, r4
 80066be:	4798      	blx	r3
 80066c0:	e7cf      	b.n	8006662 <USBD_LL_DataInStage+0x52>
 80066c2:	bf00      	nop

080066c4 <USBD_LL_Reset>:
  * @param  pdev: device instance
  * @retval status
  */

USBD_StatusTypeDef USBD_LL_Reset(USBD_HandleTypeDef *pdev)
{
 80066c4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
      }
    }
  }
#else

  if (pdev->pClass[0] != NULL)
 80066c6:	f8d0 32b8 	ldr.w	r3, [r0, #696]	; 0x2b8
  pdev->ep0_state = USBD_EP0_IDLE;
 80066ca:	2100      	movs	r1, #0
  pdev->dev_state = USBD_STATE_DEFAULT;
 80066cc:	2201      	movs	r2, #1
 80066ce:	f880 229c 	strb.w	r2, [r0, #668]	; 0x29c
{
 80066d2:	4604      	mov	r4, r0
  pdev->dev_config = 0U;
 80066d4:	6041      	str	r1, [r0, #4]
  pdev->ep0_state = USBD_EP0_IDLE;
 80066d6:	f8c0 1294 	str.w	r1, [r0, #660]	; 0x294
  pdev->dev_remote_wakeup = 0U;
 80066da:	f8c0 12a4 	str.w	r1, [r0, #676]	; 0x2a4
  pdev->dev_test_mode = 0U;
 80066de:	f880 12a0 	strb.w	r1, [r0, #672]	; 0x2a0
  if (pdev->pClass[0] != NULL)
 80066e2:	b11b      	cbz	r3, 80066ec <USBD_LL_Reset+0x28>
  {
    if (pdev->pClass[0]->DeInit != NULL)
 80066e4:	685b      	ldr	r3, [r3, #4]
 80066e6:	b10b      	cbz	r3, 80066ec <USBD_LL_Reset+0x28>
    {
      if (pdev->pClass[0]->DeInit(pdev, (uint8_t)pdev->dev_config) != USBD_OK)
 80066e8:	4798      	blx	r3
 80066ea:	b9b0      	cbnz	r0, 800671a <USBD_LL_Reset+0x56>
  USBD_StatusTypeDef ret = USBD_OK;
 80066ec:	2700      	movs	r7, #0
    }
  }
#endif /* USE_USBD_COMPOSITE */

  /* Open EP0 OUT */
  (void)USBD_LL_OpenEP(pdev, 0x00U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 80066ee:	2200      	movs	r2, #0
 80066f0:	2340      	movs	r3, #64	; 0x40
  pdev->ep_out[0x00U & 0xFU].is_used = 1U;

  pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
 80066f2:	461d      	mov	r5, r3
  (void)USBD_LL_OpenEP(pdev, 0x00U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 80066f4:	4611      	mov	r1, r2
  pdev->ep_out[0x00U & 0xFU].is_used = 1U;
 80066f6:	2601      	movs	r6, #1
  (void)USBD_LL_OpenEP(pdev, 0x00U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 80066f8:	4620      	mov	r0, r4
 80066fa:	f7fb f81d 	bl	8001738 <USBD_LL_OpenEP>
  pdev->ep_out[0x00U & 0xFU].is_used = 1U;
 80066fe:	f8a4 6164 	strh.w	r6, [r4, #356]	; 0x164
  pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
 8006702:	f8c4 5160 	str.w	r5, [r4, #352]	; 0x160

  /* Open EP0 IN */
  (void)USBD_LL_OpenEP(pdev, 0x80U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 8006706:	462b      	mov	r3, r5
 8006708:	2200      	movs	r2, #0
 800670a:	2180      	movs	r1, #128	; 0x80
 800670c:	4620      	mov	r0, r4
 800670e:	f7fb f813 	bl	8001738 <USBD_LL_OpenEP>
  pdev->ep_in[0x80U & 0xFU].is_used = 1U;
 8006712:	84a6      	strh	r6, [r4, #36]	; 0x24

  pdev->ep_in[0].maxpacket = USB_MAX_EP0_SIZE;
 8006714:	6225      	str	r5, [r4, #32]

  return ret;
}
 8006716:	4638      	mov	r0, r7
 8006718:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        ret = USBD_FAIL;
 800671a:	2703      	movs	r7, #3
 800671c:	e7e7      	b.n	80066ee <USBD_LL_Reset+0x2a>
 800671e:	bf00      	nop

08006720 <USBD_LL_SetSpeed>:
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_SetSpeed(USBD_HandleTypeDef *pdev,
                                    USBD_SpeedTypeDef speed)
{
  pdev->dev_speed = speed;
 8006720:	7401      	strb	r1, [r0, #16]

  return USBD_OK;
}
 8006722:	2000      	movs	r0, #0
 8006724:	4770      	bx	lr
 8006726:	bf00      	nop

08006728 <USBD_LL_Suspend>:
  * @retval status
  */

USBD_StatusTypeDef USBD_LL_Suspend(USBD_HandleTypeDef *pdev)
{
  pdev->dev_old_state = pdev->dev_state;
 8006728:	f890 229c 	ldrb.w	r2, [r0, #668]	; 0x29c
{
 800672c:	4603      	mov	r3, r0
  pdev->dev_state = USBD_STATE_SUSPENDED;
 800672e:	2104      	movs	r1, #4
  pdev->dev_old_state = pdev->dev_state;
 8006730:	b2d2      	uxtb	r2, r2
 8006732:	f883 229d 	strb.w	r2, [r3, #669]	; 0x29d

  return USBD_OK;
}
 8006736:	2000      	movs	r0, #0
  pdev->dev_state = USBD_STATE_SUSPENDED;
 8006738:	f883 129c 	strb.w	r1, [r3, #668]	; 0x29c
}
 800673c:	4770      	bx	lr
 800673e:	bf00      	nop

08006740 <USBD_LL_Resume>:
  * @retval status
  */

USBD_StatusTypeDef USBD_LL_Resume(USBD_HandleTypeDef *pdev)
{
  if (pdev->dev_state == USBD_STATE_SUSPENDED)
 8006740:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 8006744:	2b04      	cmp	r3, #4
 8006746:	d104      	bne.n	8006752 <USBD_LL_Resume+0x12>
  {
    pdev->dev_state = pdev->dev_old_state;
 8006748:	f890 329d 	ldrb.w	r3, [r0, #669]	; 0x29d
 800674c:	b2db      	uxtb	r3, r3
 800674e:	f880 329c 	strb.w	r3, [r0, #668]	; 0x29c
  }

  return USBD_OK;
}
 8006752:	2000      	movs	r0, #0
 8006754:	4770      	bx	lr
 8006756:	bf00      	nop

08006758 <USBD_LL_SOF>:
  */

USBD_StatusTypeDef USBD_LL_SOF(USBD_HandleTypeDef *pdev)
{
  /* The SOF event can be distributed for all classes that support it */
  if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8006758:	f890 229c 	ldrb.w	r2, [r0, #668]	; 0x29c
 800675c:	2a03      	cmp	r2, #3
 800675e:	d001      	beq.n	8006764 <USBD_LL_SOF+0xc>
    }
#endif /* USE_USBD_COMPOSITE */
  }

  return USBD_OK;
}
 8006760:	2000      	movs	r0, #0
 8006762:	4770      	bx	lr
{
 8006764:	b508      	push	{r3, lr}
    if (pdev->pClass[0] != NULL)
 8006766:	f8d0 32b8 	ldr.w	r3, [r0, #696]	; 0x2b8
 800676a:	b113      	cbz	r3, 8006772 <USBD_LL_SOF+0x1a>
      if (pdev->pClass[0]->SOF != NULL)
 800676c:	69db      	ldr	r3, [r3, #28]
 800676e:	b103      	cbz	r3, 8006772 <USBD_LL_SOF+0x1a>
        (void)pdev->pClass[0]->SOF(pdev);
 8006770:	4798      	blx	r3
}
 8006772:	2000      	movs	r0, #0
 8006774:	bd08      	pop	{r3, pc}
 8006776:	bf00      	nop

08006778 <USBD_LL_IsoINIncomplete>:
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_IsoINIncomplete(USBD_HandleTypeDef *pdev,
                                           uint8_t epnum)
{
  if (pdev->pClass[pdev->classId] == NULL)
 8006778:	f8d0 22d4 	ldr.w	r2, [r0, #724]	; 0x2d4
 800677c:	32ae      	adds	r2, #174	; 0xae
 800677e:	f850 2022 	ldr.w	r2, [r0, r2, lsl #2]
 8006782:	b15a      	cbz	r2, 800679c <USBD_LL_IsoINIncomplete+0x24>
{
 8006784:	b508      	push	{r3, lr}
  {
    return USBD_FAIL;
  }

  if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8006786:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 800678a:	2b03      	cmp	r3, #3
 800678c:	d001      	beq.n	8006792 <USBD_LL_IsoINIncomplete+0x1a>
    {
      (void)pdev->pClass[pdev->classId]->IsoINIncomplete(pdev, epnum);
    }
  }

  return USBD_OK;
 800678e:	2000      	movs	r0, #0
}
 8006790:	bd08      	pop	{r3, pc}
    if (pdev->pClass[pdev->classId]->IsoINIncomplete != NULL)
 8006792:	6a13      	ldr	r3, [r2, #32]
 8006794:	b123      	cbz	r3, 80067a0 <USBD_LL_IsoINIncomplete+0x28>
      (void)pdev->pClass[pdev->classId]->IsoINIncomplete(pdev, epnum);
 8006796:	4798      	blx	r3
  return USBD_OK;
 8006798:	2000      	movs	r0, #0
}
 800679a:	bd08      	pop	{r3, pc}
    return USBD_FAIL;
 800679c:	2003      	movs	r0, #3
}
 800679e:	4770      	bx	lr
  return USBD_OK;
 80067a0:	4618      	mov	r0, r3
}
 80067a2:	bd08      	pop	{r3, pc}

080067a4 <USBD_LL_IsoOUTIncomplete>:
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_IsoOUTIncomplete(USBD_HandleTypeDef *pdev,
                                            uint8_t epnum)
{
  if (pdev->pClass[pdev->classId] == NULL)
 80067a4:	f8d0 22d4 	ldr.w	r2, [r0, #724]	; 0x2d4
 80067a8:	32ae      	adds	r2, #174	; 0xae
 80067aa:	f850 2022 	ldr.w	r2, [r0, r2, lsl #2]
 80067ae:	b15a      	cbz	r2, 80067c8 <USBD_LL_IsoOUTIncomplete+0x24>
{
 80067b0:	b508      	push	{r3, lr}
  {
    return USBD_FAIL;
  }

  if (pdev->dev_state == USBD_STATE_CONFIGURED)
 80067b2:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 80067b6:	2b03      	cmp	r3, #3
 80067b8:	d001      	beq.n	80067be <USBD_LL_IsoOUTIncomplete+0x1a>
    {
      (void)pdev->pClass[pdev->classId]->IsoOUTIncomplete(pdev, epnum);
    }
  }

  return USBD_OK;
 80067ba:	2000      	movs	r0, #0
}
 80067bc:	bd08      	pop	{r3, pc}
    if (pdev->pClass[pdev->classId]->IsoOUTIncomplete != NULL)
 80067be:	6a53      	ldr	r3, [r2, #36]	; 0x24
 80067c0:	b123      	cbz	r3, 80067cc <USBD_LL_IsoOUTIncomplete+0x28>
      (void)pdev->pClass[pdev->classId]->IsoOUTIncomplete(pdev, epnum);
 80067c2:	4798      	blx	r3
  return USBD_OK;
 80067c4:	2000      	movs	r0, #0
}
 80067c6:	bd08      	pop	{r3, pc}
    return USBD_FAIL;
 80067c8:	2003      	movs	r0, #3
}
 80067ca:	4770      	bx	lr
  return USBD_OK;
 80067cc:	4618      	mov	r0, r3
}
 80067ce:	bd08      	pop	{r3, pc}

080067d0 <USBD_LL_DevConnected>:
 80067d0:	2000      	movs	r0, #0
 80067d2:	4770      	bx	lr

080067d4 <USBD_LL_DevDisconnected>:
        }
      }
    }
  }
#else
  if (pdev->pClass[0] != NULL)
 80067d4:	f8d0 22b8 	ldr.w	r2, [r0, #696]	; 0x2b8
  pdev->dev_state = USBD_STATE_DEFAULT;
 80067d8:	2101      	movs	r1, #1
 80067da:	f880 129c 	strb.w	r1, [r0, #668]	; 0x29c
  if (pdev->pClass[0] != NULL)
 80067de:	b142      	cbz	r2, 80067f2 <USBD_LL_DevDisconnected+0x1e>
{
 80067e0:	b508      	push	{r3, lr}
  {
    if (pdev->pClass[0]->DeInit(pdev, (uint8_t)pdev->dev_config) != 0U)
 80067e2:	6852      	ldr	r2, [r2, #4]
 80067e4:	7901      	ldrb	r1, [r0, #4]
 80067e6:	4790      	blx	r2
 80067e8:	b908      	cbnz	r0, 80067ee <USBD_LL_DevDisconnected+0x1a>
  USBD_StatusTypeDef   ret = USBD_OK;
 80067ea:	2000      	movs	r0, #0
    }
  }
#endif /* USE_USBD_COMPOSITE */

  return ret;
}
 80067ec:	bd08      	pop	{r3, pc}
      ret = USBD_FAIL;
 80067ee:	2003      	movs	r0, #3
}
 80067f0:	bd08      	pop	{r3, pc}
  USBD_StatusTypeDef   ret = USBD_OK;
 80067f2:	2000      	movs	r0, #0
}
 80067f4:	4770      	bx	lr
 80067f6:	bf00      	nop

080067f8 <USBD_CoreFindIF>:
  UNUSED(pdev);
  UNUSED(index);

  return 0x00U;
#endif /* USE_USBD_COMPOSITE */
}
 80067f8:	2000      	movs	r0, #0
 80067fa:	4770      	bx	lr

080067fc <USBD_CoreFindEP>:
 80067fc:	2000      	movs	r0, #0
 80067fe:	4770      	bx	lr

08006800 <USBD_StdDevReq>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval status
  */
USBD_StatusTypeDef USBD_StdDevReq(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 8006800:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8006804:	780c      	ldrb	r4, [r1, #0]
 8006806:	f004 0460 	and.w	r4, r4, #96	; 0x60
  USBD_StatusTypeDef ret = USBD_OK;

  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 800680a:	2c20      	cmp	r4, #32
{
 800680c:	b082      	sub	sp, #8
 800680e:	460e      	mov	r6, r1
 8006810:	4605      	mov	r5, r0
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8006812:	d00f      	beq.n	8006834 <USBD_StdDevReq+0x34>
 8006814:	2c40      	cmp	r4, #64	; 0x40
 8006816:	d00d      	beq.n	8006834 <USBD_StdDevReq+0x34>
 8006818:	b1c4      	cbz	r4, 800684c <USBD_StdDevReq+0x4c>
  */
void USBD_CtlError(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
  UNUSED(req);

  (void)USBD_LL_StallEP(pdev, 0x80U);
 800681a:	2180      	movs	r1, #128	; 0x80
 800681c:	4628      	mov	r0, r5
 800681e:	f7fa ffa5 	bl	800176c <USBD_LL_StallEP>
  (void)USBD_LL_StallEP(pdev, 0U);
 8006822:	2100      	movs	r1, #0
 8006824:	4628      	mov	r0, r5
 8006826:	f7fa ffa1 	bl	800176c <USBD_LL_StallEP>
  USBD_StatusTypeDef ret = USBD_OK;
 800682a:	2400      	movs	r4, #0
}
 800682c:	4620      	mov	r0, r4
 800682e:	b002      	add	sp, #8
 8006830:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      ret = (USBD_StatusTypeDef)pdev->pClass[pdev->classId]->Setup(pdev, req);
 8006834:	f8d5 32d4 	ldr.w	r3, [r5, #724]	; 0x2d4
 8006838:	33ae      	adds	r3, #174	; 0xae
 800683a:	4631      	mov	r1, r6
 800683c:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
 8006840:	689b      	ldr	r3, [r3, #8]
 8006842:	4628      	mov	r0, r5
}
 8006844:	b002      	add	sp, #8
 8006846:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
      ret = (USBD_StatusTypeDef)pdev->pClass[pdev->classId]->Setup(pdev, req);
 800684a:	4718      	bx	r3
      switch (req->bRequest)
 800684c:	784f      	ldrb	r7, [r1, #1]
 800684e:	2f09      	cmp	r7, #9
 8006850:	d8e3      	bhi.n	800681a <USBD_StdDevReq+0x1a>
 8006852:	a301      	add	r3, pc, #4	; (adr r3, 8006858 <USBD_StdDevReq+0x58>)
 8006854:	f853 f027 	ldr.w	pc, [r3, r7, lsl #2]
 8006858:	080068bd 	.word	0x080068bd
 800685c:	080068eb 	.word	0x080068eb
 8006860:	0800681b 	.word	0x0800681b
 8006864:	08006909 	.word	0x08006909
 8006868:	0800681b 	.word	0x0800681b
 800686c:	0800692d 	.word	0x0800692d
 8006870:	08006965 	.word	0x08006965
 8006874:	0800681b 	.word	0x0800681b
 8006878:	08006999 	.word	0x08006999
 800687c:	08006881 	.word	0x08006881
  cfgidx = (uint8_t)(req->wValue);
 8006880:	788e      	ldrb	r6, [r1, #2]
 8006882:	4fb1      	ldr	r7, [pc, #708]	; (8006b48 <USBD_StdDevReq+0x348>)
  if (cfgidx > USBD_MAX_NUM_CONFIGURATION)
 8006884:	2e01      	cmp	r6, #1
  cfgidx = (uint8_t)(req->wValue);
 8006886:	703e      	strb	r6, [r7, #0]
  if (cfgidx > USBD_MAX_NUM_CONFIGURATION)
 8006888:	f200 8149 	bhi.w	8006b1e <USBD_StdDevReq+0x31e>
  switch (pdev->dev_state)
 800688c:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 8006890:	2b02      	cmp	r3, #2
 8006892:	fa5f f883 	uxtb.w	r8, r3
 8006896:	f000 8104 	beq.w	8006aa2 <USBD_StdDevReq+0x2a2>
 800689a:	f1b8 0f03 	cmp.w	r8, #3
 800689e:	f000 8115 	beq.w	8006acc <USBD_StdDevReq+0x2cc>
  (void)USBD_LL_StallEP(pdev, 0x80U);
 80068a2:	2180      	movs	r1, #128	; 0x80
 80068a4:	f7fa ff62 	bl	800176c <USBD_LL_StallEP>
  (void)USBD_LL_StallEP(pdev, 0U);
 80068a8:	2100      	movs	r1, #0
 80068aa:	4628      	mov	r0, r5
 80068ac:	f7fa ff5e 	bl	800176c <USBD_LL_StallEP>
      (void)USBD_ClrClassConfig(pdev, cfgidx);
 80068b0:	7839      	ldrb	r1, [r7, #0]
 80068b2:	4628      	mov	r0, r5
 80068b4:	f7ff fe38 	bl	8006528 <USBD_ClrClassConfig>
      ret = USBD_FAIL;
 80068b8:	2403      	movs	r4, #3
      break;
 80068ba:	e7b7      	b.n	800682c <USBD_StdDevReq+0x2c>
  switch (pdev->dev_state)
 80068bc:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 80068c0:	3b01      	subs	r3, #1
 80068c2:	2b02      	cmp	r3, #2
 80068c4:	d826      	bhi.n	8006914 <USBD_StdDevReq+0x114>
      if (req->wLength != 0x2U)
 80068c6:	88cb      	ldrh	r3, [r1, #6]
 80068c8:	2b02      	cmp	r3, #2
 80068ca:	d123      	bne.n	8006914 <USBD_StdDevReq+0x114>
      if (pdev->dev_remote_wakeup != 0U)
 80068cc:	f8d0 32a4 	ldr.w	r3, [r0, #676]	; 0x2a4
      pdev->dev_config_status = USB_CONFIG_SELF_POWERED;
 80068d0:	2201      	movs	r2, #1
 80068d2:	60c2      	str	r2, [r0, #12]
      if (pdev->dev_remote_wakeup != 0U)
 80068d4:	b10b      	cbz	r3, 80068da <USBD_StdDevReq+0xda>
        pdev->dev_config_status |= USB_CONFIG_REMOTE_WAKEUP;
 80068d6:	2303      	movs	r3, #3
 80068d8:	60c3      	str	r3, [r0, #12]
      (void)USBD_CtlSendData(pdev, (uint8_t *)&pdev->dev_config_status, 2U);
 80068da:	2202      	movs	r2, #2
 80068dc:	f105 010c 	add.w	r1, r5, #12
 80068e0:	4628      	mov	r0, r5
 80068e2:	f000 fa6f 	bl	8006dc4 <USBD_CtlSendData>
  USBD_StatusTypeDef ret = USBD_OK;
 80068e6:	463c      	mov	r4, r7
      break;
 80068e8:	e7a0      	b.n	800682c <USBD_StdDevReq+0x2c>
  switch (pdev->dev_state)
 80068ea:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 80068ee:	3b01      	subs	r3, #1
 80068f0:	2b02      	cmp	r3, #2
 80068f2:	d80f      	bhi.n	8006914 <USBD_StdDevReq+0x114>
      if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
 80068f4:	884b      	ldrh	r3, [r1, #2]
 80068f6:	2b01      	cmp	r3, #1
 80068f8:	d198      	bne.n	800682c <USBD_StdDevReq+0x2c>
        pdev->dev_remote_wakeup = 0U;
 80068fa:	2300      	movs	r3, #0
 80068fc:	f8c5 32a4 	str.w	r3, [r5, #676]	; 0x2a4
        (void)USBD_CtlSendStatus(pdev);
 8006900:	4628      	mov	r0, r5
 8006902:	f000 fa8b 	bl	8006e1c <USBD_CtlSendStatus>
 8006906:	e791      	b.n	800682c <USBD_StdDevReq+0x2c>
  if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
 8006908:	884b      	ldrh	r3, [r1, #2]
 800690a:	2b01      	cmp	r3, #1
 800690c:	d0f6      	beq.n	80068fc <USBD_StdDevReq+0xfc>
  else if (req->wValue == USB_FEATURE_TEST_MODE)
 800690e:	2b02      	cmp	r3, #2
 8006910:	f000 80fe 	beq.w	8006b10 <USBD_StdDevReq+0x310>
  (void)USBD_LL_StallEP(pdev, 0x80U);
 8006914:	2180      	movs	r1, #128	; 0x80
 8006916:	4628      	mov	r0, r5
 8006918:	f7fa ff28 	bl	800176c <USBD_LL_StallEP>
  (void)USBD_LL_StallEP(pdev, 0U);
 800691c:	2100      	movs	r1, #0
 800691e:	4628      	mov	r0, r5
 8006920:	f7fa ff24 	bl	800176c <USBD_LL_StallEP>
}
 8006924:	4620      	mov	r0, r4
 8006926:	b002      	add	sp, #8
 8006928:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if ((req->wIndex == 0U) && (req->wLength == 0U) && (req->wValue < 128U))
 800692c:	888b      	ldrh	r3, [r1, #4]
 800692e:	2b00      	cmp	r3, #0
 8006930:	d1f0      	bne.n	8006914 <USBD_StdDevReq+0x114>
 8006932:	88cb      	ldrh	r3, [r1, #6]
 8006934:	2b00      	cmp	r3, #0
 8006936:	d1ed      	bne.n	8006914 <USBD_StdDevReq+0x114>
 8006938:	884e      	ldrh	r6, [r1, #2]
 800693a:	2e7f      	cmp	r6, #127	; 0x7f
 800693c:	d8ea      	bhi.n	8006914 <USBD_StdDevReq+0x114>
    if (pdev->dev_state == USBD_STATE_CONFIGURED)
 800693e:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 8006942:	2b03      	cmp	r3, #3
 8006944:	d0e6      	beq.n	8006914 <USBD_StdDevReq+0x114>
    dev_addr = (uint8_t)(req->wValue) & 0x7FU;
 8006946:	b2f1      	uxtb	r1, r6
      pdev->dev_address = dev_addr;
 8006948:	f880 129e 	strb.w	r1, [r0, #670]	; 0x29e
      (void)USBD_LL_SetUSBAddress(pdev, dev_addr);
 800694c:	f7fa ff32 	bl	80017b4 <USBD_LL_SetUSBAddress>
      (void)USBD_CtlSendStatus(pdev);
 8006950:	4628      	mov	r0, r5
 8006952:	f000 fa63 	bl	8006e1c <USBD_CtlSendStatus>
      if (dev_addr != 0U)
 8006956:	2e00      	cmp	r6, #0
 8006958:	f000 8108 	beq.w	8006b6c <USBD_StdDevReq+0x36c>
        pdev->dev_state = USBD_STATE_ADDRESSED;
 800695c:	2302      	movs	r3, #2
 800695e:	f885 329c 	strb.w	r3, [r5, #668]	; 0x29c
 8006962:	e763      	b.n	800682c <USBD_StdDevReq+0x2c>
  switch (req->wValue >> 8)
 8006964:	884a      	ldrh	r2, [r1, #2]
  uint16_t len = 0U;
 8006966:	2300      	movs	r3, #0
 8006968:	f8ad 3006 	strh.w	r3, [sp, #6]
  switch (req->wValue >> 8)
 800696c:	0a13      	lsrs	r3, r2, #8
 800696e:	3b01      	subs	r3, #1
 8006970:	2b06      	cmp	r3, #6
 8006972:	d8cf      	bhi.n	8006914 <USBD_StdDevReq+0x114>
 8006974:	a101      	add	r1, pc, #4	; (adr r1, 800697c <USBD_StdDevReq+0x17c>)
 8006976:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
 800697a:	bf00      	nop
 800697c:	08006a33 	.word	0x08006a33
 8006980:	08006a19 	.word	0x08006a19
 8006984:	08006a09 	.word	0x08006a09
 8006988:	08006915 	.word	0x08006915
 800698c:	08006915 	.word	0x08006915
 8006990:	080069f5 	.word	0x080069f5
 8006994:	080069bd 	.word	0x080069bd
  if (req->wLength != 1U)
 8006998:	88ca      	ldrh	r2, [r1, #6]
 800699a:	2a01      	cmp	r2, #1
 800699c:	d1ba      	bne.n	8006914 <USBD_StdDevReq+0x114>
    switch (pdev->dev_state)
 800699e:	f890 129c 	ldrb.w	r1, [r0, #668]	; 0x29c
 80069a2:	2902      	cmp	r1, #2
 80069a4:	b2cb      	uxtb	r3, r1
 80069a6:	d875      	bhi.n	8006a94 <USBD_StdDevReq+0x294>
 80069a8:	2b00      	cmp	r3, #0
 80069aa:	f43f af36 	beq.w	800681a <USBD_StdDevReq+0x1a>
        pdev->dev_default_config = 0U;
 80069ae:	4601      	mov	r1, r0
 80069b0:	2300      	movs	r3, #0
 80069b2:	f841 3f08 	str.w	r3, [r1, #8]!
        (void)USBD_CtlSendData(pdev, (uint8_t *)&pdev->dev_default_config, 1U);
 80069b6:	f000 fa05 	bl	8006dc4 <USBD_CtlSendData>
        break;
 80069ba:	e737      	b.n	800682c <USBD_StdDevReq+0x2c>
      if (pdev->dev_speed == USBD_SPEED_HIGH)
 80069bc:	7c03      	ldrb	r3, [r0, #16]
 80069be:	2b00      	cmp	r3, #0
 80069c0:	d1a8      	bne.n	8006914 <USBD_StdDevReq+0x114>
          pbuf = (uint8_t *)pdev->pClass[0]->GetOtherSpeedConfigDescriptor(&len);
 80069c2:	f8d0 32b8 	ldr.w	r3, [r0, #696]	; 0x2b8
 80069c6:	f10d 0006 	add.w	r0, sp, #6
 80069ca:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80069cc:	4798      	blx	r3
        pbuf[1] = USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION;
 80069ce:	2307      	movs	r3, #7
 80069d0:	7043      	strb	r3, [r0, #1]
  if (req->wLength != 0U)
 80069d2:	88f2      	ldrh	r2, [r6, #6]
 80069d4:	2a00      	cmp	r2, #0
 80069d6:	d093      	beq.n	8006900 <USBD_StdDevReq+0x100>
    if (len != 0U)
 80069d8:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 80069dc:	2b00      	cmp	r3, #0
 80069de:	d099      	beq.n	8006914 <USBD_StdDevReq+0x114>
      len = MIN(len, req->wLength);
 80069e0:	429a      	cmp	r2, r3
 80069e2:	bf28      	it	cs
 80069e4:	461a      	movcs	r2, r3
      (void)USBD_CtlSendData(pdev, pbuf, len);
 80069e6:	4601      	mov	r1, r0
 80069e8:	4628      	mov	r0, r5
      len = MIN(len, req->wLength);
 80069ea:	f8ad 2006 	strh.w	r2, [sp, #6]
      (void)USBD_CtlSendData(pdev, pbuf, len);
 80069ee:	f000 f9e9 	bl	8006dc4 <USBD_CtlSendData>
 80069f2:	e71b      	b.n	800682c <USBD_StdDevReq+0x2c>
      if (pdev->dev_speed == USBD_SPEED_HIGH)
 80069f4:	7c03      	ldrb	r3, [r0, #16]
 80069f6:	2b00      	cmp	r3, #0
 80069f8:	d18c      	bne.n	8006914 <USBD_StdDevReq+0x114>
          pbuf = (uint8_t *)pdev->pClass[0]->GetDeviceQualifierDescriptor(&len);
 80069fa:	f8d0 32b8 	ldr.w	r3, [r0, #696]	; 0x2b8
 80069fe:	f10d 0006 	add.w	r0, sp, #6
 8006a02:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8006a04:	4798      	blx	r3
  if (err != 0U)
 8006a06:	e7e4      	b.n	80069d2 <USBD_StdDevReq+0x1d2>
      switch ((uint8_t)(req->wValue))
 8006a08:	b2d2      	uxtb	r2, r2
 8006a0a:	2a05      	cmp	r2, #5
 8006a0c:	d882      	bhi.n	8006914 <USBD_StdDevReq+0x114>
 8006a0e:	e8df f002 	tbb	[pc, r2]
 8006a12:	353b      	.short	0x353b
 8006a14:	1823292f 	.word	0x1823292f
      if (pdev->dev_speed == USBD_SPEED_HIGH)
 8006a18:	7c03      	ldrb	r3, [r0, #16]
 8006a1a:	2b00      	cmp	r3, #0
 8006a1c:	f040 8096 	bne.w	8006b4c <USBD_StdDevReq+0x34c>
          pbuf = (uint8_t *)pdev->pClass[0]->GetHSConfigDescriptor(&len);
 8006a20:	f8d0 32b8 	ldr.w	r3, [r0, #696]	; 0x2b8
 8006a24:	f10d 0006 	add.w	r0, sp, #6
 8006a28:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8006a2a:	4798      	blx	r3
        pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
 8006a2c:	2302      	movs	r3, #2
 8006a2e:	7043      	strb	r3, [r0, #1]
  if (err != 0U)
 8006a30:	e7cf      	b.n	80069d2 <USBD_StdDevReq+0x1d2>
      pbuf = pdev->pDesc->GetDeviceDescriptor(pdev->dev_speed, &len);
 8006a32:	f8d0 32b4 	ldr.w	r3, [r0, #692]	; 0x2b4
 8006a36:	7c00      	ldrb	r0, [r0, #16]
 8006a38:	681b      	ldr	r3, [r3, #0]
 8006a3a:	f10d 0106 	add.w	r1, sp, #6
 8006a3e:	4798      	blx	r3
  if (err != 0U)
 8006a40:	e7c7      	b.n	80069d2 <USBD_StdDevReq+0x1d2>
          if (pdev->pDesc->GetInterfaceStrDescriptor != NULL)
 8006a42:	f8d0 32b4 	ldr.w	r3, [r0, #692]	; 0x2b4
 8006a46:	699b      	ldr	r3, [r3, #24]
 8006a48:	2b00      	cmp	r3, #0
 8006a4a:	f43f af63 	beq.w	8006914 <USBD_StdDevReq+0x114>
            pbuf = pdev->pDesc->GetInterfaceStrDescriptor(pdev->dev_speed, &len);
 8006a4e:	7c28      	ldrb	r0, [r5, #16]
 8006a50:	f10d 0106 	add.w	r1, sp, #6
 8006a54:	4798      	blx	r3
  if (err != 0U)
 8006a56:	e7bc      	b.n	80069d2 <USBD_StdDevReq+0x1d2>
          if (pdev->pDesc->GetConfigurationStrDescriptor != NULL)
 8006a58:	f8d0 32b4 	ldr.w	r3, [r0, #692]	; 0x2b4
 8006a5c:	695b      	ldr	r3, [r3, #20]
 8006a5e:	2b00      	cmp	r3, #0
 8006a60:	d1f5      	bne.n	8006a4e <USBD_StdDevReq+0x24e>
 8006a62:	e757      	b.n	8006914 <USBD_StdDevReq+0x114>
          if (pdev->pDesc->GetSerialStrDescriptor != NULL)
 8006a64:	f8d0 32b4 	ldr.w	r3, [r0, #692]	; 0x2b4
 8006a68:	691b      	ldr	r3, [r3, #16]
 8006a6a:	2b00      	cmp	r3, #0
 8006a6c:	d1ef      	bne.n	8006a4e <USBD_StdDevReq+0x24e>
 8006a6e:	e751      	b.n	8006914 <USBD_StdDevReq+0x114>
          if (pdev->pDesc->GetProductStrDescriptor != NULL)
 8006a70:	f8d0 32b4 	ldr.w	r3, [r0, #692]	; 0x2b4
 8006a74:	68db      	ldr	r3, [r3, #12]
 8006a76:	2b00      	cmp	r3, #0
 8006a78:	d1e9      	bne.n	8006a4e <USBD_StdDevReq+0x24e>
 8006a7a:	e74b      	b.n	8006914 <USBD_StdDevReq+0x114>
          if (pdev->pDesc->GetManufacturerStrDescriptor != NULL)
 8006a7c:	f8d0 32b4 	ldr.w	r3, [r0, #692]	; 0x2b4
 8006a80:	689b      	ldr	r3, [r3, #8]
 8006a82:	2b00      	cmp	r3, #0
 8006a84:	d1e3      	bne.n	8006a4e <USBD_StdDevReq+0x24e>
 8006a86:	e745      	b.n	8006914 <USBD_StdDevReq+0x114>
          if (pdev->pDesc->GetLangIDStrDescriptor != NULL)
 8006a88:	f8d0 32b4 	ldr.w	r3, [r0, #692]	; 0x2b4
 8006a8c:	685b      	ldr	r3, [r3, #4]
 8006a8e:	2b00      	cmp	r3, #0
 8006a90:	d1dd      	bne.n	8006a4e <USBD_StdDevReq+0x24e>
 8006a92:	e73f      	b.n	8006914 <USBD_StdDevReq+0x114>
    switch (pdev->dev_state)
 8006a94:	2b03      	cmp	r3, #3
 8006a96:	f47f aec0 	bne.w	800681a <USBD_StdDevReq+0x1a>
        (void)USBD_CtlSendData(pdev, (uint8_t *)&pdev->dev_config, 1U);
 8006a9a:	1d01      	adds	r1, r0, #4
 8006a9c:	f000 f992 	bl	8006dc4 <USBD_CtlSendData>
        break;
 8006aa0:	e6c4      	b.n	800682c <USBD_StdDevReq+0x2c>
      if (cfgidx != 0U)
 8006aa2:	2e00      	cmp	r6, #0
 8006aa4:	f43f af2c 	beq.w	8006900 <USBD_StdDevReq+0x100>
        pdev->dev_config = cfgidx;
 8006aa8:	2101      	movs	r1, #1
 8006aaa:	6041      	str	r1, [r0, #4]
        ret = USBD_SetClassConfig(pdev, cfgidx);
 8006aac:	f7ff fd34 	bl	8006518 <USBD_SetClassConfig>
        if (ret != USBD_OK)
 8006ab0:	4604      	mov	r4, r0
 8006ab2:	2800      	cmp	r0, #0
 8006ab4:	d053      	beq.n	8006b5e <USBD_StdDevReq+0x35e>
  (void)USBD_LL_StallEP(pdev, 0x80U);
 8006ab6:	2180      	movs	r1, #128	; 0x80
 8006ab8:	4628      	mov	r0, r5
 8006aba:	f7fa fe57 	bl	800176c <USBD_LL_StallEP>
  (void)USBD_LL_StallEP(pdev, 0U);
 8006abe:	2100      	movs	r1, #0
 8006ac0:	4628      	mov	r0, r5
 8006ac2:	f7fa fe53 	bl	800176c <USBD_LL_StallEP>
          pdev->dev_state = USBD_STATE_ADDRESSED;
 8006ac6:	f885 829c 	strb.w	r8, [r5, #668]	; 0x29c
 8006aca:	e6af      	b.n	800682c <USBD_StdDevReq+0x2c>
      if (cfgidx == 0U)
 8006acc:	b386      	cbz	r6, 8006b30 <USBD_StdDevReq+0x330>
      else if (cfgidx != pdev->dev_config)
 8006ace:	6841      	ldr	r1, [r0, #4]
 8006ad0:	2901      	cmp	r1, #1
 8006ad2:	f43f af15 	beq.w	8006900 <USBD_StdDevReq+0x100>
        (void)USBD_ClrClassConfig(pdev, (uint8_t)pdev->dev_config);
 8006ad6:	b2c9      	uxtb	r1, r1
 8006ad8:	f7ff fd26 	bl	8006528 <USBD_ClrClassConfig>
        pdev->dev_config = cfgidx;
 8006adc:	7839      	ldrb	r1, [r7, #0]
 8006ade:	6069      	str	r1, [r5, #4]
        ret = USBD_SetClassConfig(pdev, cfgidx);
 8006ae0:	4628      	mov	r0, r5
 8006ae2:	f7ff fd19 	bl	8006518 <USBD_SetClassConfig>
        if (ret != USBD_OK)
 8006ae6:	4606      	mov	r6, r0
 8006ae8:	2800      	cmp	r0, #0
 8006aea:	f43f af09 	beq.w	8006900 <USBD_StdDevReq+0x100>
  (void)USBD_LL_StallEP(pdev, 0x80U);
 8006aee:	2180      	movs	r1, #128	; 0x80
 8006af0:	4628      	mov	r0, r5
 8006af2:	f7fa fe3b 	bl	800176c <USBD_LL_StallEP>
  (void)USBD_LL_StallEP(pdev, 0U);
 8006af6:	2100      	movs	r1, #0
 8006af8:	4628      	mov	r0, r5
 8006afa:	f7fa fe37 	bl	800176c <USBD_LL_StallEP>
          (void)USBD_ClrClassConfig(pdev, (uint8_t)pdev->dev_config);
 8006afe:	7929      	ldrb	r1, [r5, #4]
 8006b00:	4628      	mov	r0, r5
 8006b02:	f7ff fd11 	bl	8006528 <USBD_ClrClassConfig>
          pdev->dev_state = USBD_STATE_ADDRESSED;
 8006b06:	2302      	movs	r3, #2
 8006b08:	f885 329c 	strb.w	r3, [r5, #668]	; 0x29c
 8006b0c:	4634      	mov	r4, r6
 8006b0e:	e68d      	b.n	800682c <USBD_StdDevReq+0x2c>
    pdev->dev_test_mode = req->wIndex >> 8;
 8006b10:	888b      	ldrh	r3, [r1, #4]
 8006b12:	0a1b      	lsrs	r3, r3, #8
 8006b14:	f880 32a0 	strb.w	r3, [r0, #672]	; 0x2a0
    (void)USBD_CtlSendStatus(pdev);
 8006b18:	f000 f980 	bl	8006e1c <USBD_CtlSendStatus>
 8006b1c:	e686      	b.n	800682c <USBD_StdDevReq+0x2c>
  (void)USBD_LL_StallEP(pdev, 0x80U);
 8006b1e:	2180      	movs	r1, #128	; 0x80
 8006b20:	f7fa fe24 	bl	800176c <USBD_LL_StallEP>
  (void)USBD_LL_StallEP(pdev, 0U);
 8006b24:	2100      	movs	r1, #0
 8006b26:	4628      	mov	r0, r5
 8006b28:	f7fa fe20 	bl	800176c <USBD_LL_StallEP>
    return USBD_FAIL;
 8006b2c:	2403      	movs	r4, #3
 8006b2e:	e67d      	b.n	800682c <USBD_StdDevReq+0x2c>
        pdev->dev_state = USBD_STATE_ADDRESSED;
 8006b30:	2302      	movs	r3, #2
        (void)USBD_ClrClassConfig(pdev, cfgidx);
 8006b32:	4631      	mov	r1, r6
        pdev->dev_state = USBD_STATE_ADDRESSED;
 8006b34:	f880 329c 	strb.w	r3, [r0, #668]	; 0x29c
        pdev->dev_config = cfgidx;
 8006b38:	6046      	str	r6, [r0, #4]
        (void)USBD_ClrClassConfig(pdev, cfgidx);
 8006b3a:	f7ff fcf5 	bl	8006528 <USBD_ClrClassConfig>
        (void)USBD_CtlSendStatus(pdev);
 8006b3e:	4628      	mov	r0, r5
 8006b40:	f000 f96c 	bl	8006e1c <USBD_CtlSendStatus>
  USBD_StatusTypeDef ret = USBD_OK;
 8006b44:	4634      	mov	r4, r6
 8006b46:	e671      	b.n	800682c <USBD_StdDevReq+0x2c>
 8006b48:	200028dc 	.word	0x200028dc
          pbuf   = (uint8_t *)pdev->pClass[0]->GetFSConfigDescriptor(&len);
 8006b4c:	f8d0 32b8 	ldr.w	r3, [r0, #696]	; 0x2b8
 8006b50:	f10d 0006 	add.w	r0, sp, #6
 8006b54:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8006b56:	4798      	blx	r3
        pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
 8006b58:	2302      	movs	r3, #2
 8006b5a:	7043      	strb	r3, [r0, #1]
  if (err != 0U)
 8006b5c:	e739      	b.n	80069d2 <USBD_StdDevReq+0x1d2>
          (void)USBD_CtlSendStatus(pdev);
 8006b5e:	4628      	mov	r0, r5
 8006b60:	f000 f95c 	bl	8006e1c <USBD_CtlSendStatus>
          pdev->dev_state = USBD_STATE_CONFIGURED;
 8006b64:	2303      	movs	r3, #3
 8006b66:	f885 329c 	strb.w	r3, [r5, #668]	; 0x29c
 8006b6a:	e65f      	b.n	800682c <USBD_StdDevReq+0x2c>
        pdev->dev_state = USBD_STATE_DEFAULT;
 8006b6c:	2301      	movs	r3, #1
 8006b6e:	f885 329c 	strb.w	r3, [r5, #668]	; 0x29c
 8006b72:	e65b      	b.n	800682c <USBD_StdDevReq+0x2c>

08006b74 <USBD_StdItfReq>:
{
 8006b74:	b538      	push	{r3, r4, r5, lr}
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8006b76:	780b      	ldrb	r3, [r1, #0]
 8006b78:	f003 0260 	and.w	r2, r3, #96	; 0x60
 8006b7c:	2a40      	cmp	r2, #64	; 0x40
{
 8006b7e:	460d      	mov	r5, r1
 8006b80:	4604      	mov	r4, r0
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8006b82:	d00b      	beq.n	8006b9c <USBD_StdItfReq+0x28>
 8006b84:	065b      	lsls	r3, r3, #25
 8006b86:	d509      	bpl.n	8006b9c <USBD_StdItfReq+0x28>
  (void)USBD_LL_StallEP(pdev, 0x80U);
 8006b88:	2180      	movs	r1, #128	; 0x80
 8006b8a:	f7fa fdef 	bl	800176c <USBD_LL_StallEP>
  (void)USBD_LL_StallEP(pdev, 0U);
 8006b8e:	2100      	movs	r1, #0
 8006b90:	4620      	mov	r0, r4
 8006b92:	f7fa fdeb 	bl	800176c <USBD_LL_StallEP>
  USBD_StatusTypeDef ret = USBD_OK;
 8006b96:	2500      	movs	r5, #0
}
 8006b98:	4628      	mov	r0, r5
 8006b9a:	bd38      	pop	{r3, r4, r5, pc}
      switch (pdev->dev_state)
 8006b9c:	f894 329c 	ldrb.w	r3, [r4, #668]	; 0x29c
 8006ba0:	3b01      	subs	r3, #1
 8006ba2:	2b02      	cmp	r3, #2
 8006ba4:	d819      	bhi.n	8006bda <USBD_StdItfReq+0x66>
          if (LOBYTE(req->wIndex) <= USBD_MAX_NUM_INTERFACES)
 8006ba6:	7929      	ldrb	r1, [r5, #4]
 8006ba8:	2902      	cmp	r1, #2
 8006baa:	d816      	bhi.n	8006bda <USBD_StdItfReq+0x66>
            idx = USBD_CoreFindIF(pdev, LOBYTE(req->wIndex));
 8006bac:	4620      	mov	r0, r4
 8006bae:	f7ff fe23 	bl	80067f8 <USBD_CoreFindIF>
            if (((uint8_t)idx != 0xFFU) && (idx < USBD_MAX_SUPPORTED_CLASS))
 8006bb2:	b9a8      	cbnz	r0, 8006be0 <USBD_StdItfReq+0x6c>
              if (pdev->pClass[idx]->Setup != NULL)
 8006bb4:	f8d4 32b8 	ldr.w	r3, [r4, #696]	; 0x2b8
 8006bb8:	689b      	ldr	r3, [r3, #8]
 8006bba:	b18b      	cbz	r3, 8006be0 <USBD_StdItfReq+0x6c>
                pdev->classId = idx;
 8006bbc:	f8c4 02d4 	str.w	r0, [r4, #724]	; 0x2d4
                ret = (USBD_StatusTypeDef)(pdev->pClass[idx]->Setup(pdev, req));
 8006bc0:	4629      	mov	r1, r5
 8006bc2:	4620      	mov	r0, r4
 8006bc4:	4798      	blx	r3
            if ((req->wLength == 0U) && (ret == USBD_OK))
 8006bc6:	88eb      	ldrh	r3, [r5, #6]
                ret = (USBD_StatusTypeDef)(pdev->pClass[idx]->Setup(pdev, req));
 8006bc8:	4605      	mov	r5, r0
            if ((req->wLength == 0U) && (ret == USBD_OK))
 8006bca:	2b00      	cmp	r3, #0
 8006bcc:	d1e4      	bne.n	8006b98 <USBD_StdItfReq+0x24>
 8006bce:	2800      	cmp	r0, #0
 8006bd0:	d1e2      	bne.n	8006b98 <USBD_StdItfReq+0x24>
              (void)USBD_CtlSendStatus(pdev);
 8006bd2:	4620      	mov	r0, r4
 8006bd4:	f000 f922 	bl	8006e1c <USBD_CtlSendStatus>
 8006bd8:	e7de      	b.n	8006b98 <USBD_StdItfReq+0x24>
  (void)USBD_LL_StallEP(pdev, 0x80U);
 8006bda:	2180      	movs	r1, #128	; 0x80
 8006bdc:	4620      	mov	r0, r4
 8006bde:	e7d4      	b.n	8006b8a <USBD_StdItfReq+0x16>
              ret = USBD_FAIL;
 8006be0:	2503      	movs	r5, #3
}
 8006be2:	4628      	mov	r0, r5
 8006be4:	bd38      	pop	{r3, r4, r5, pc}
 8006be6:	bf00      	nop

08006be8 <USBD_StdEPReq>:
{
 8006be8:	b530      	push	{r4, r5, lr}
 8006bea:	460c      	mov	r4, r1
  ep_addr = LOBYTE(req->wIndex);
 8006bec:	888a      	ldrh	r2, [r1, #4]
 8006bee:	7823      	ldrb	r3, [r4, #0]
 8006bf0:	f003 0360 	and.w	r3, r3, #96	; 0x60
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8006bf4:	2b20      	cmp	r3, #32
{
 8006bf6:	b083      	sub	sp, #12
 8006bf8:	4605      	mov	r5, r0
  ep_addr = LOBYTE(req->wIndex);
 8006bfa:	b2d1      	uxtb	r1, r2
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8006bfc:	d01e      	beq.n	8006c3c <USBD_StdEPReq+0x54>
 8006bfe:	2b40      	cmp	r3, #64	; 0x40
 8006c00:	d01c      	beq.n	8006c3c <USBD_StdEPReq+0x54>
 8006c02:	b36b      	cbz	r3, 8006c60 <USBD_StdEPReq+0x78>
  (void)USBD_LL_StallEP(pdev, 0x80U);
 8006c04:	2180      	movs	r1, #128	; 0x80
 8006c06:	4628      	mov	r0, r5
 8006c08:	f7fa fdb0 	bl	800176c <USBD_LL_StallEP>
  (void)USBD_LL_StallEP(pdev, 0U);
 8006c0c:	2100      	movs	r1, #0
 8006c0e:	4628      	mov	r0, r5
 8006c10:	f7fa fdac 	bl	800176c <USBD_LL_StallEP>
}
 8006c14:	2000      	movs	r0, #0
 8006c16:	b003      	add	sp, #12
 8006c18:	bd30      	pop	{r4, r5, pc}
          switch (pdev->dev_state)
 8006c1a:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 8006c1e:	2b02      	cmp	r3, #2
 8006c20:	b2da      	uxtb	r2, r3
 8006c22:	d05d      	beq.n	8006ce0 <USBD_StdEPReq+0xf8>
 8006c24:	2a03      	cmp	r2, #3
 8006c26:	d1ed      	bne.n	8006c04 <USBD_StdEPReq+0x1c>
              if (req->wValue == USB_FEATURE_EP_HALT)
 8006c28:	8863      	ldrh	r3, [r4, #2]
 8006c2a:	2b00      	cmp	r3, #0
 8006c2c:	d1f2      	bne.n	8006c14 <USBD_StdEPReq+0x2c>
                if ((ep_addr & 0x7FU) != 0x00U)
 8006c2e:	064b      	lsls	r3, r1, #25
 8006c30:	d17a      	bne.n	8006d28 <USBD_StdEPReq+0x140>
                (void)USBD_CtlSendStatus(pdev);
 8006c32:	4628      	mov	r0, r5
 8006c34:	9101      	str	r1, [sp, #4]
 8006c36:	f000 f8f1 	bl	8006e1c <USBD_CtlSendStatus>
                idx = USBD_CoreFindEP(pdev, ep_addr);
 8006c3a:	9901      	ldr	r1, [sp, #4]
 8006c3c:	4628      	mov	r0, r5
 8006c3e:	f7ff fddd 	bl	80067fc <USBD_CoreFindEP>
                if (((uint8_t)idx != 0xFFU) && (idx < USBD_MAX_SUPPORTED_CLASS))
 8006c42:	2800      	cmp	r0, #0
 8006c44:	d1e6      	bne.n	8006c14 <USBD_StdEPReq+0x2c>
                  if (pdev->pClass[idx]->Setup != NULL)
 8006c46:	f8d5 32b8 	ldr.w	r3, [r5, #696]	; 0x2b8
                  pdev->classId = idx;
 8006c4a:	f8c5 02d4 	str.w	r0, [r5, #724]	; 0x2d4
                  if (pdev->pClass[idx]->Setup != NULL)
 8006c4e:	689b      	ldr	r3, [r3, #8]
 8006c50:	2b00      	cmp	r3, #0
 8006c52:	d0df      	beq.n	8006c14 <USBD_StdEPReq+0x2c>
                    ret = (USBD_StatusTypeDef)(pdev->pClass[idx]->Setup(pdev, req));
 8006c54:	4621      	mov	r1, r4
 8006c56:	4628      	mov	r0, r5
}
 8006c58:	b003      	add	sp, #12
 8006c5a:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
                    ret = (USBD_StatusTypeDef)(pdev->pClass[idx]->Setup(pdev, req));
 8006c5e:	4718      	bx	r3
      switch (req->bRequest)
 8006c60:	7863      	ldrb	r3, [r4, #1]
 8006c62:	2b01      	cmp	r3, #1
 8006c64:	d0d9      	beq.n	8006c1a <USBD_StdEPReq+0x32>
 8006c66:	2b03      	cmp	r3, #3
 8006c68:	d029      	beq.n	8006cbe <USBD_StdEPReq+0xd6>
 8006c6a:	2b00      	cmp	r3, #0
 8006c6c:	d1ca      	bne.n	8006c04 <USBD_StdEPReq+0x1c>
          switch (pdev->dev_state)
 8006c6e:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 8006c72:	2b02      	cmp	r3, #2
 8006c74:	b2d8      	uxtb	r0, r3
 8006c76:	d03c      	beq.n	8006cf2 <USBD_StdEPReq+0x10a>
 8006c78:	2803      	cmp	r0, #3
 8006c7a:	d1c3      	bne.n	8006c04 <USBD_StdEPReq+0x1c>
                if (pdev->ep_in[ep_addr & 0xFU].is_used == 0U)
 8006c7c:	f001 030f 	and.w	r3, r1, #15
 8006c80:	eb03 0383 	add.w	r3, r3, r3, lsl #2
              if ((ep_addr & 0x80U) == 0x80U)
 8006c84:	0612      	lsls	r2, r2, #24
                if (pdev->ep_in[ep_addr & 0xFU].is_used == 0U)
 8006c86:	eb05 0383 	add.w	r3, r5, r3, lsl #2
              if ((ep_addr & 0x80U) == 0x80U)
 8006c8a:	d441      	bmi.n	8006d10 <USBD_StdEPReq+0x128>
                if (pdev->ep_out[ep_addr & 0xFU].is_used == 0U)
 8006c8c:	f8b3 3164 	ldrh.w	r3, [r3, #356]	; 0x164
 8006c90:	2b00      	cmp	r3, #0
 8006c92:	d0b7      	beq.n	8006c04 <USBD_StdEPReq+0x1c>
              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 8006c94:	f001 037f 	and.w	r3, r1, #127	; 0x7f
 8006c98:	2414      	movs	r4, #20
 8006c9a:	fb04 5403 	mla	r4, r4, r3, r5
 8006c9e:	f504 74aa 	add.w	r4, r4, #340	; 0x154
              if ((ep_addr == 0x00U) || (ep_addr == 0x80U))
 8006ca2:	b12b      	cbz	r3, 8006cb0 <USBD_StdEPReq+0xc8>
              else if (USBD_LL_IsStallEP(pdev, ep_addr) != 0U)
 8006ca4:	4628      	mov	r0, r5
 8006ca6:	f7fa fd71 	bl	800178c <USBD_LL_IsStallEP>
 8006caa:	2800      	cmp	r0, #0
 8006cac:	d041      	beq.n	8006d32 <USBD_StdEPReq+0x14a>
                pep->status = 0x0001U;
 8006cae:	2301      	movs	r3, #1
 8006cb0:	6023      	str	r3, [r4, #0]
              (void)USBD_CtlSendData(pdev, (uint8_t *)&pep->status, 2U);
 8006cb2:	2202      	movs	r2, #2
 8006cb4:	4621      	mov	r1, r4
 8006cb6:	4628      	mov	r0, r5
 8006cb8:	f000 f884 	bl	8006dc4 <USBD_CtlSendData>
              break;
 8006cbc:	e7aa      	b.n	8006c14 <USBD_StdEPReq+0x2c>
          switch (pdev->dev_state)
 8006cbe:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 8006cc2:	2b02      	cmp	r3, #2
 8006cc4:	b2da      	uxtb	r2, r3
 8006cc6:	d00b      	beq.n	8006ce0 <USBD_StdEPReq+0xf8>
 8006cc8:	2a03      	cmp	r2, #3
 8006cca:	d19b      	bne.n	8006c04 <USBD_StdEPReq+0x1c>
              if (req->wValue == USB_FEATURE_EP_HALT)
 8006ccc:	8863      	ldrh	r3, [r4, #2]
 8006cce:	b91b      	cbnz	r3, 8006cd8 <USBD_StdEPReq+0xf0>
                if ((ep_addr != 0x00U) && (ep_addr != 0x80U) && (req->wLength == 0x00U))
 8006cd0:	0648      	lsls	r0, r1, #25
 8006cd2:	d001      	beq.n	8006cd8 <USBD_StdEPReq+0xf0>
 8006cd4:	88e3      	ldrh	r3, [r4, #6]
 8006cd6:	b373      	cbz	r3, 8006d36 <USBD_StdEPReq+0x14e>
              (void)USBD_CtlSendStatus(pdev);
 8006cd8:	4628      	mov	r0, r5
 8006cda:	f000 f89f 	bl	8006e1c <USBD_CtlSendStatus>
              break;
 8006cde:	e799      	b.n	8006c14 <USBD_StdEPReq+0x2c>
              if ((ep_addr != 0x00U) && (ep_addr != 0x80U))
 8006ce0:	064a      	lsls	r2, r1, #25
 8006ce2:	d08f      	beq.n	8006c04 <USBD_StdEPReq+0x1c>
                (void)USBD_LL_StallEP(pdev, ep_addr);
 8006ce4:	f7fa fd42 	bl	800176c <USBD_LL_StallEP>
                (void)USBD_LL_StallEP(pdev, 0x80U);
 8006ce8:	2180      	movs	r1, #128	; 0x80
 8006cea:	4628      	mov	r0, r5
 8006cec:	f7fa fd3e 	bl	800176c <USBD_LL_StallEP>
 8006cf0:	e790      	b.n	8006c14 <USBD_StdEPReq+0x2c>
              if ((ep_addr != 0x00U) && (ep_addr != 0x80U))
 8006cf2:	0648      	lsls	r0, r1, #25
 8006cf4:	d186      	bne.n	8006c04 <USBD_StdEPReq+0x1c>
              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 8006cf6:	0611      	lsls	r1, r2, #24
 8006cf8:	bf4c      	ite	mi
 8006cfa:	f105 0114 	addmi.w	r1, r5, #20
 8006cfe:	f505 71aa 	addpl.w	r1, r5, #340	; 0x154
              pep->status = 0x0000U;
 8006d02:	2300      	movs	r3, #0
 8006d04:	600b      	str	r3, [r1, #0]
              (void)USBD_CtlSendData(pdev, (uint8_t *)&pep->status, 2U);
 8006d06:	2202      	movs	r2, #2
 8006d08:	4628      	mov	r0, r5
 8006d0a:	f000 f85b 	bl	8006dc4 <USBD_CtlSendData>
              break;
 8006d0e:	e781      	b.n	8006c14 <USBD_StdEPReq+0x2c>
                if (pdev->ep_in[ep_addr & 0xFU].is_used == 0U)
 8006d10:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 8006d12:	2b00      	cmp	r3, #0
 8006d14:	f43f af76 	beq.w	8006c04 <USBD_StdEPReq+0x1c>
              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 8006d18:	f001 037f 	and.w	r3, r1, #127	; 0x7f
 8006d1c:	1c5c      	adds	r4, r3, #1
 8006d1e:	eb04 0484 	add.w	r4, r4, r4, lsl #2
 8006d22:	eb05 0484 	add.w	r4, r5, r4, lsl #2
 8006d26:	e7bc      	b.n	8006ca2 <USBD_StdEPReq+0xba>
                  (void)USBD_LL_ClearStallEP(pdev, ep_addr);
 8006d28:	9101      	str	r1, [sp, #4]
 8006d2a:	f7fa fd27 	bl	800177c <USBD_LL_ClearStallEP>
 8006d2e:	9901      	ldr	r1, [sp, #4]
 8006d30:	e77f      	b.n	8006c32 <USBD_StdEPReq+0x4a>
                pep->status = 0x0000U;
 8006d32:	6020      	str	r0, [r4, #0]
 8006d34:	e7bd      	b.n	8006cb2 <USBD_StdEPReq+0xca>
                  (void)USBD_LL_StallEP(pdev, ep_addr);
 8006d36:	4628      	mov	r0, r5
 8006d38:	f7fa fd18 	bl	800176c <USBD_LL_StallEP>
 8006d3c:	e7cc      	b.n	8006cd8 <USBD_StdEPReq+0xf0>
 8006d3e:	bf00      	nop

08006d40 <USBD_ParseSetupRequest>:
  req->bmRequest = *(uint8_t *)(pbuff);
 8006d40:	780b      	ldrb	r3, [r1, #0]
 8006d42:	7003      	strb	r3, [r0, #0]
  req->bRequest = *(uint8_t *)(pbuff);
 8006d44:	784b      	ldrb	r3, [r1, #1]
 8006d46:	7043      	strb	r3, [r0, #1]
  uint16_t _SwapVal, _Byte1, _Byte2;
  uint8_t *_pbuff = addr;

  _Byte1 = *(uint8_t *)_pbuff;
  _pbuff++;
  _Byte2 = *(uint8_t *)_pbuff;
 8006d48:	884b      	ldrh	r3, [r1, #2]
  req->wValue = SWAPBYTE(pbuff);
 8006d4a:	8043      	strh	r3, [r0, #2]
 8006d4c:	888b      	ldrh	r3, [r1, #4]
  req->wIndex = SWAPBYTE(pbuff);
 8006d4e:	8083      	strh	r3, [r0, #4]
 8006d50:	88cb      	ldrh	r3, [r1, #6]
  req->wLength = SWAPBYTE(pbuff);
 8006d52:	80c3      	strh	r3, [r0, #6]
}
 8006d54:	4770      	bx	lr
 8006d56:	bf00      	nop

08006d58 <USBD_CtlError>:
{
 8006d58:	b510      	push	{r4, lr}
  (void)USBD_LL_StallEP(pdev, 0x80U);
 8006d5a:	2180      	movs	r1, #128	; 0x80
{
 8006d5c:	4604      	mov	r4, r0
  (void)USBD_LL_StallEP(pdev, 0x80U);
 8006d5e:	f7fa fd05 	bl	800176c <USBD_LL_StallEP>
  (void)USBD_LL_StallEP(pdev, 0U);
 8006d62:	4620      	mov	r0, r4
 8006d64:	2100      	movs	r1, #0
}
 8006d66:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  (void)USBD_LL_StallEP(pdev, 0U);
 8006d6a:	f7fa bcff 	b.w	800176c <USBD_LL_StallEP>
 8006d6e:	bf00      	nop

08006d70 <USBD_GetString>:
void USBD_GetString(uint8_t *desc, uint8_t *unicode, uint16_t *len)
{
  uint8_t idx = 0U;
  uint8_t *pdesc;

  if (desc == NULL)
 8006d70:	b318      	cbz	r0, 8006dba <USBD_GetString+0x4a>
static uint8_t USBD_GetLen(uint8_t *buf)
{
  uint8_t  len = 0U;
  uint8_t *pbuff = buf;

  while (*pbuff != (uint8_t)'\0')
 8006d72:	7803      	ldrb	r3, [r0, #0]
{
 8006d74:	b430      	push	{r4, r5}
  while (*pbuff != (uint8_t)'\0')
 8006d76:	b30b      	cbz	r3, 8006dbc <USBD_GetString+0x4c>
 8006d78:	4604      	mov	r4, r0
 8006d7a:	f1c0 0c01 	rsb	ip, r0, #1
  {
    len++;
 8006d7e:	eb04 030c 	add.w	r3, r4, ip
  while (*pbuff != (uint8_t)'\0')
 8006d82:	f814 5f01 	ldrb.w	r5, [r4, #1]!
 8006d86:	b2db      	uxtb	r3, r3
 8006d88:	2d00      	cmp	r5, #0
 8006d8a:	d1f8      	bne.n	8006d7e <USBD_GetString+0xe>
  *len = ((uint16_t)USBD_GetLen(pdesc) * 2U) + 2U;
 8006d8c:	3301      	adds	r3, #1
 8006d8e:	005b      	lsls	r3, r3, #1
 8006d90:	b2dc      	uxtb	r4, r3
 8006d92:	8013      	strh	r3, [r2, #0]
  unicode[idx] = USB_DESC_TYPE_STRING;
 8006d94:	2303      	movs	r3, #3
  unicode[idx] = *(uint8_t *)len;
 8006d96:	700c      	strb	r4, [r1, #0]
  unicode[idx] = USB_DESC_TYPE_STRING;
 8006d98:	704b      	strb	r3, [r1, #1]
  while (*pdesc != (uint8_t)'\0')
 8006d9a:	7804      	ldrb	r4, [r0, #0]
 8006d9c:	b15c      	cbz	r4, 8006db6 <USBD_GetString+0x46>
  idx++;
 8006d9e:	2302      	movs	r3, #2
    unicode[idx] = 0U;
 8006da0:	2500      	movs	r5, #0
    idx++;
 8006da2:	1c5a      	adds	r2, r3, #1
    unicode[idx] = 0U;
 8006da4:	b2d2      	uxtb	r2, r2
    unicode[idx] = *pdesc;
 8006da6:	54cc      	strb	r4, [r1, r3]
    unicode[idx] = 0U;
 8006da8:	548d      	strb	r5, [r1, r2]
  while (*pdesc != (uint8_t)'\0')
 8006daa:	f810 4f01 	ldrb.w	r4, [r0, #1]!
    idx++;
 8006dae:	3302      	adds	r3, #2
 8006db0:	b2db      	uxtb	r3, r3
  while (*pdesc != (uint8_t)'\0')
 8006db2:	2c00      	cmp	r4, #0
 8006db4:	d1f5      	bne.n	8006da2 <USBD_GetString+0x32>
}
 8006db6:	bc30      	pop	{r4, r5}
 8006db8:	4770      	bx	lr
 8006dba:	4770      	bx	lr
  while (*pbuff != (uint8_t)'\0')
 8006dbc:	2402      	movs	r4, #2
 8006dbe:	4623      	mov	r3, r4
 8006dc0:	e7e7      	b.n	8006d92 <USBD_GetString+0x22>
 8006dc2:	bf00      	nop

08006dc4 <USBD_CtlSendData>:
  * @param  len: length of data to be sent
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlSendData(USBD_HandleTypeDef *pdev,
                                    uint8_t *pbuf, uint32_t len)
{
 8006dc4:	b508      	push	{r3, lr}
 8006dc6:	4613      	mov	r3, r2
 8006dc8:	460a      	mov	r2, r1
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_DATA_IN;
 8006dca:	2102      	movs	r1, #2
  pdev->ep_in[0].total_length = len;

#ifdef USBD_AVOID_PACKET_SPLIT_MPS
  pdev->ep_in[0].rem_length = 0U;
#else
  pdev->ep_in[0].rem_length = len;
 8006dcc:	e9c0 3306 	strd	r3, r3, [r0, #24]
  pdev->ep0_state = USBD_EP0_DATA_IN;
 8006dd0:	f8c0 1294 	str.w	r1, [r0, #660]	; 0x294
#endif /* USBD_AVOID_PACKET_SPLIT_MPS */

  /* Start the transfer */
  (void)USBD_LL_Transmit(pdev, 0x00U, pbuf, len);
 8006dd4:	2100      	movs	r1, #0
 8006dd6:	f7fa fcf5 	bl	80017c4 <USBD_LL_Transmit>

  return USBD_OK;
}
 8006dda:	2000      	movs	r0, #0
 8006ddc:	bd08      	pop	{r3, pc}
 8006dde:	bf00      	nop

08006de0 <USBD_CtlContinueSendData>:
  * @param  len: length of data to be sent
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlContinueSendData(USBD_HandleTypeDef *pdev,
                                            uint8_t *pbuf, uint32_t len)
{
 8006de0:	b508      	push	{r3, lr}
 8006de2:	4613      	mov	r3, r2
  /* Start the next transfer */
  (void)USBD_LL_Transmit(pdev, 0x00U, pbuf, len);
 8006de4:	460a      	mov	r2, r1
 8006de6:	2100      	movs	r1, #0
 8006de8:	f7fa fcec 	bl	80017c4 <USBD_LL_Transmit>

  return USBD_OK;
}
 8006dec:	2000      	movs	r0, #0
 8006dee:	bd08      	pop	{r3, pc}

08006df0 <USBD_CtlPrepareRx>:
  * @param  len: length of data to be received
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlPrepareRx(USBD_HandleTypeDef *pdev,
                                     uint8_t *pbuf, uint32_t len)
{
 8006df0:	b508      	push	{r3, lr}
 8006df2:	4613      	mov	r3, r2
 8006df4:	460a      	mov	r2, r1
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_DATA_OUT;
 8006df6:	2103      	movs	r1, #3
  pdev->ep_out[0].total_length = len;

#ifdef USBD_AVOID_PACKET_SPLIT_MPS
  pdev->ep_out[0].rem_length = 0U;
#else
  pdev->ep_out[0].rem_length = len;
 8006df8:	e9c0 3356 	strd	r3, r3, [r0, #344]	; 0x158
  pdev->ep0_state = USBD_EP0_DATA_OUT;
 8006dfc:	f8c0 1294 	str.w	r1, [r0, #660]	; 0x294
#endif /* USBD_AVOID_PACKET_SPLIT_MPS */

  /* Start the transfer */
  (void)USBD_LL_PrepareReceive(pdev, 0U, pbuf, len);
 8006e00:	2100      	movs	r1, #0
 8006e02:	f7fa fce7 	bl	80017d4 <USBD_LL_PrepareReceive>

  return USBD_OK;
}
 8006e06:	2000      	movs	r0, #0
 8006e08:	bd08      	pop	{r3, pc}
 8006e0a:	bf00      	nop

08006e0c <USBD_CtlContinueRx>:
  * @param  len: length of data to be received
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlContinueRx(USBD_HandleTypeDef *pdev,
                                      uint8_t *pbuf, uint32_t len)
{
 8006e0c:	b508      	push	{r3, lr}
 8006e0e:	4613      	mov	r3, r2
  (void)USBD_LL_PrepareReceive(pdev, 0U, pbuf, len);
 8006e10:	460a      	mov	r2, r1
 8006e12:	2100      	movs	r1, #0
 8006e14:	f7fa fcde 	bl	80017d4 <USBD_LL_PrepareReceive>

  return USBD_OK;
}
 8006e18:	2000      	movs	r0, #0
 8006e1a:	bd08      	pop	{r3, pc}

08006e1c <USBD_CtlSendStatus>:
  *         send zero lzngth packet on the ctl pipe
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlSendStatus(USBD_HandleTypeDef *pdev)
{
 8006e1c:	b508      	push	{r3, lr}
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_IN;
 8006e1e:	2104      	movs	r1, #4

  /* Start the transfer */
  (void)USBD_LL_Transmit(pdev, 0x00U, NULL, 0U);
 8006e20:	2300      	movs	r3, #0
  pdev->ep0_state = USBD_EP0_STATUS_IN;
 8006e22:	f8c0 1294 	str.w	r1, [r0, #660]	; 0x294
  (void)USBD_LL_Transmit(pdev, 0x00U, NULL, 0U);
 8006e26:	461a      	mov	r2, r3
 8006e28:	4619      	mov	r1, r3
 8006e2a:	f7fa fccb 	bl	80017c4 <USBD_LL_Transmit>

  return USBD_OK;
}
 8006e2e:	2000      	movs	r0, #0
 8006e30:	bd08      	pop	{r3, pc}
 8006e32:	bf00      	nop

08006e34 <USBD_CtlReceiveStatus>:
  *         receive zero lzngth packet on the ctl pipe
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlReceiveStatus(USBD_HandleTypeDef *pdev)
{
 8006e34:	b508      	push	{r3, lr}
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_OUT;
 8006e36:	2105      	movs	r1, #5

  /* Start the transfer */
  (void)USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
 8006e38:	2300      	movs	r3, #0
  pdev->ep0_state = USBD_EP0_STATUS_OUT;
 8006e3a:	f8c0 1294 	str.w	r1, [r0, #660]	; 0x294
  (void)USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
 8006e3e:	461a      	mov	r2, r3
 8006e40:	4619      	mov	r1, r3
 8006e42:	f7fa fcc7 	bl	80017d4 <USBD_LL_PrepareReceive>

  return USBD_OK;
}
 8006e46:	2000      	movs	r0, #0
 8006e48:	bd08      	pop	{r3, pc}
 8006e4a:	bf00      	nop

08006e4c <D16_GENERIC>:
 8006e4c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8006e50:	b089      	sub	sp, #36	; 0x24
 8006e52:	68d4      	ldr	r4, [r2, #12]
 8006e54:	8cd5      	ldrh	r5, [r2, #38]	; 0x26
 8006e56:	6993      	ldr	r3, [r2, #24]
 8006e58:	9407      	str	r4, [sp, #28]
 8006e5a:	6b14      	ldr	r4, [r2, #48]	; 0x30
 8006e5c:	9306      	str	r3, [sp, #24]
 8006e5e:	9402      	str	r4, [sp, #8]
 8006e60:	f8d2 a010 	ldr.w	sl, [r2, #16]
 8006e64:	f8d2 b014 	ldr.w	fp, [r2, #20]
 8006e68:	69d3      	ldr	r3, [r2, #28]
 8006e6a:	6896      	ldr	r6, [r2, #8]
 8006e6c:	6b54      	ldr	r4, [r2, #52]	; 0x34
 8006e6e:	9103      	str	r1, [sp, #12]
 8006e70:	2d00      	cmp	r5, #0
 8006e72:	d066      	beq.n	8006f42 <D16_GENERIC+0xf6>
 8006e74:	f004 0510 	and.w	r5, r4, #16
 8006e78:	f004 0420 	and.w	r4, r4, #32
 8006e7c:	9504      	str	r5, [sp, #16]
 8006e7e:	4938      	ldr	r1, [pc, #224]	; (8006f60 <D16_GENERIC+0x114>)
 8006e80:	9405      	str	r4, [sp, #20]
 8006e82:	f04f 0e00 	mov.w	lr, #0
 8006e86:	4635      	mov	r5, r6
 8006e88:	e04f      	b.n	8006f2a <D16_GENERIC+0xde>
 8006e8a:	5d87      	ldrb	r7, [r0, r6]
 8006e8c:	7804      	ldrb	r4, [r0, #0]
 8006e8e:	eb00 0046 	add.w	r0, r0, r6, lsl #1
 8006e92:	eb04 2407 	add.w	r4, r4, r7, lsl #8
 8006e96:	b2e6      	uxtb	r6, r4
 8006e98:	f3c4 2407 	ubfx	r4, r4, #8, #8
 8006e9c:	f851 6026 	ldr.w	r6, [r1, r6, lsl #2]
 8006ea0:	f851 4024 	ldr.w	r4, [r1, r4, lsl #2]
 8006ea4:	4433      	add	r3, r6
 8006ea6:	eb04 2493 	add.w	r4, r4, r3, lsr #10
 8006eaa:	f3c4 0609 	ubfx	r6, r4, #0, #10
 8006eae:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8006eb2:	ea46 4603 	orr.w	r6, r6, r3, lsl #16
 8006eb6:	0aa3      	lsrs	r3, r4, #10
 8006eb8:	4c2a      	ldr	r4, [pc, #168]	; (8006f64 <D16_GENERIC+0x118>)
 8006eba:	fb26 5404 	smlad	r4, r6, r4, r5
 8006ebe:	4d2a      	ldr	r5, [pc, #168]	; (8006f68 <D16_GENERIC+0x11c>)
 8006ec0:	fb26 f505 	smuad	r5, r6, r5
 8006ec4:	f5a4 6400 	sub.w	r4, r4, #2048	; 0x800
 8006ec8:	eb04 080a 	add.w	r8, r4, sl
 8006ecc:	eba8 080b 	sub.w	r8, r8, fp
 8006ed0:	4646      	mov	r6, r8
 8006ed2:	17f7      	asrs	r7, r6, #31
 8006ed4:	e9cd 6700 	strd	r6, r7, [sp]
 8006ed8:	9e04      	ldr	r6, [sp, #16]
 8006eda:	f10e 0c01 	add.w	ip, lr, #1
 8006ede:	b16e      	cbz	r6, 8006efc <D16_GENERIC+0xb0>
 8006ee0:	6a16      	ldr	r6, [r2, #32]
 8006ee2:	9f01      	ldr	r7, [sp, #4]
 8006ee4:	fba8 8906 	umull	r8, r9, r8, r6
 8006ee8:	fb06 9907 	mla	r9, r6, r7, r9
 8006eec:	f118 4800 	adds.w	r8, r8, #2147483648	; 0x80000000
 8006ef0:	f149 0900 	adc.w	r9, r9, #0
 8006ef4:	ea4f 0a49 	mov.w	sl, r9, lsl #1
 8006ef8:	46a3      	mov	fp, r4
 8006efa:	4654      	mov	r4, sl
 8006efc:	8d16      	ldrh	r6, [r2, #40]	; 0x28
 8006efe:	9f02      	ldr	r7, [sp, #8]
 8006f00:	0424      	lsls	r4, r4, #16
 8006f02:	f04f 4800 	mov.w	r8, #2147483648	; 0x80000000
 8006f06:	f04f 0900 	mov.w	r9, #0
 8006f0a:	fb0e fe06 	mul.w	lr, lr, r6
 8006f0e:	fbc7 8904 	smlal	r8, r9, r7, r4
 8006f12:	9e03      	ldr	r6, [sp, #12]
 8006f14:	464f      	mov	r7, r9
 8006f16:	10bc      	asrs	r4, r7, #2
 8006f18:	f304 040f 	ssat	r4, #16, r4
 8006f1c:	f826 401e 	strh.w	r4, [r6, lr, lsl #1]
 8006f20:	8cd4      	ldrh	r4, [r2, #38]	; 0x26
 8006f22:	fa1f fe8c 	uxth.w	lr, ip
 8006f26:	4574      	cmp	r4, lr
 8006f28:	d90a      	bls.n	8006f40 <D16_GENERIC+0xf4>
 8006f2a:	8d54      	ldrh	r4, [r2, #42]	; 0x2a
 8006f2c:	2c01      	cmp	r4, #1
 8006f2e:	b2e6      	uxtb	r6, r4
 8006f30:	d1ab      	bne.n	8006e8a <D16_GENERIC+0x3e>
 8006f32:	9e05      	ldr	r6, [sp, #20]
 8006f34:	f850 4b02 	ldr.w	r4, [r0], #2
 8006f38:	2e00      	cmp	r6, #0
 8006f3a:	d0ac      	beq.n	8006e96 <D16_GENERIC+0x4a>
 8006f3c:	ba64      	rev16	r4, r4
 8006f3e:	e7aa      	b.n	8006e96 <D16_GENERIC+0x4a>
 8006f40:	462e      	mov	r6, r5
 8006f42:	9907      	ldr	r1, [sp, #28]
 8006f44:	61d3      	str	r3, [r2, #28]
 8006f46:	9b06      	ldr	r3, [sp, #24]
 8006f48:	6096      	str	r6, [r2, #8]
 8006f4a:	2000      	movs	r0, #0
 8006f4c:	60d1      	str	r1, [r2, #12]
 8006f4e:	f8c2 a010 	str.w	sl, [r2, #16]
 8006f52:	f8c2 b014 	str.w	fp, [r2, #20]
 8006f56:	6193      	str	r3, [r2, #24]
 8006f58:	b009      	add	sp, #36	; 0x24
 8006f5a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8006f5e:	bf00      	nop
 8006f60:	200000c8 	.word	0x200000c8
 8006f64:	00030001 	.word	0x00030001
 8006f68:	00010003 	.word	0x00010003

08006f6c <D24_GENERIC>:
 8006f6c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8006f70:	8cd6      	ldrh	r6, [r2, #38]	; 0x26
 8006f72:	6993      	ldr	r3, [r2, #24]
 8006f74:	6b15      	ldr	r5, [r2, #48]	; 0x30
 8006f76:	f8d2 a010 	ldr.w	sl, [r2, #16]
 8006f7a:	f8d2 9014 	ldr.w	r9, [r2, #20]
 8006f7e:	6894      	ldr	r4, [r2, #8]
 8006f80:	f8d2 b00c 	ldr.w	fp, [r2, #12]
 8006f84:	b089      	sub	sp, #36	; 0x24
 8006f86:	9307      	str	r3, [sp, #28]
 8006f88:	9503      	str	r5, [sp, #12]
 8006f8a:	69d3      	ldr	r3, [r2, #28]
 8006f8c:	6b55      	ldr	r5, [r2, #52]	; 0x34
 8006f8e:	9104      	str	r1, [sp, #16]
 8006f90:	2e00      	cmp	r6, #0
 8006f92:	f000 8096 	beq.w	80070c2 <D24_GENERIC+0x156>
 8006f96:	f005 0610 	and.w	r6, r5, #16
 8006f9a:	f005 0520 	and.w	r5, r5, #32
 8006f9e:	4954      	ldr	r1, [pc, #336]	; (80070f0 <D24_GENERIC+0x184>)
 8006fa0:	9605      	str	r6, [sp, #20]
 8006fa2:	9506      	str	r5, [sp, #24]
 8006fa4:	f04f 0e00 	mov.w	lr, #0
 8006fa8:	f8cd 9008 	str.w	r9, [sp, #8]
 8006fac:	e06a      	b.n	8007084 <D24_GENERIC+0x118>
 8006fae:	f810 5016 	ldrb.w	r5, [r0, r6, lsl #1]
 8006fb2:	f810 8007 	ldrb.w	r8, [r0, r7]
 8006fb6:	f890 c000 	ldrb.w	ip, [r0]
 8006fba:	042d      	lsls	r5, r5, #16
 8006fbc:	eb00 0046 	add.w	r0, r0, r6, lsl #1
 8006fc0:	eb05 2508 	add.w	r5, r5, r8, lsl #8
 8006fc4:	44ac      	add	ip, r5
 8006fc6:	4438      	add	r0, r7
 8006fc8:	fa5f f68c 	uxtb.w	r6, ip
 8006fcc:	f3cc 2507 	ubfx	r5, ip, #8, #8
 8006fd0:	f851 6026 	ldr.w	r6, [r1, r6, lsl #2]
 8006fd4:	f851 7025 	ldr.w	r7, [r1, r5, lsl #2]
 8006fd8:	ea4f 4c1c 	mov.w	ip, ip, lsr #16
 8006fdc:	eb06 2693 	add.w	r6, r6, r3, lsr #10
 8006fe0:	eb07 2796 	add.w	r7, r7, r6, lsr #10
 8006fe4:	f851 302c 	ldr.w	r3, [r1, ip, lsl #2]
 8006fe8:	f3c7 0509 	ubfx	r5, r7, #0, #10
 8006fec:	f3c6 0609 	ubfx	r6, r6, #0, #10
 8006ff0:	ea45 4606 	orr.w	r6, r5, r6, lsl #16
 8006ff4:	eb03 2397 	add.w	r3, r3, r7, lsr #10
 8006ff8:	4d3e      	ldr	r5, [pc, #248]	; (80070f4 <D24_GENERIC+0x188>)
 8006ffa:	fb26 b705 	smlad	r7, r6, r5, fp
 8006ffe:	4d3e      	ldr	r5, [pc, #248]	; (80070f8 <D24_GENERIC+0x18c>)
 8007000:	fb26 4b05 	smlad	fp, r6, r5, r4
 8007004:	f3c3 0409 	ubfx	r4, r3, #0, #10
 8007008:	eb04 0844 	add.w	r8, r4, r4, lsl #1
 800700c:	eb0b 0b48 	add.w	fp, fp, r8, lsl #1
 8007010:	2401      	movs	r4, #1
 8007012:	fb26 f604 	smuad	r6, r6, r4
 8007016:	f5a7 55d8 	sub.w	r5, r7, #6912	; 0x1b00
 800701a:	9f02      	ldr	r7, [sp, #8]
 800701c:	eb0e 0c04 	add.w	ip, lr, r4
 8007020:	eb08 0406 	add.w	r4, r8, r6
 8007024:	eb05 060a 	add.w	r6, r5, sl
 8007028:	1bf6      	subs	r6, r6, r7
 800702a:	4637      	mov	r7, r6
 800702c:	ea4f 78e6 	mov.w	r8, r6, asr #31
 8007030:	e9cd 7800 	strd	r7, r8, [sp]
 8007034:	9f05      	ldr	r7, [sp, #20]
 8007036:	b177      	cbz	r7, 8007056 <D24_GENERIC+0xea>
 8007038:	f8d2 8020 	ldr.w	r8, [r2, #32]
 800703c:	9502      	str	r5, [sp, #8]
 800703e:	fba6 9a08 	umull	r9, sl, r6, r8
 8007042:	9e01      	ldr	r6, [sp, #4]
 8007044:	fb08 aa06 	mla	sl, r8, r6, sl
 8007048:	f119 4600 	adds.w	r6, r9, #2147483648	; 0x80000000
 800704c:	f14a 0700 	adc.w	r7, sl, #0
 8007050:	ea4f 0a47 	mov.w	sl, r7, lsl #1
 8007054:	4655      	mov	r5, sl
 8007056:	8d16      	ldrh	r6, [r2, #40]	; 0x28
 8007058:	9f03      	ldr	r7, [sp, #12]
 800705a:	03ad      	lsls	r5, r5, #14
 800705c:	f04f 4800 	mov.w	r8, #2147483648	; 0x80000000
 8007060:	f04f 0900 	mov.w	r9, #0
 8007064:	fb0e fe06 	mul.w	lr, lr, r6
 8007068:	fbc7 8905 	smlal	r8, r9, r7, r5
 800706c:	9e04      	ldr	r6, [sp, #16]
 800706e:	464f      	mov	r7, r9
 8007070:	10bd      	asrs	r5, r7, #2
 8007072:	f305 050f 	ssat	r5, #16, r5
 8007076:	f826 501e 	strh.w	r5, [r6, lr, lsl #1]
 800707a:	8cd5      	ldrh	r5, [r2, #38]	; 0x26
 800707c:	fa1f fe8c 	uxth.w	lr, ip
 8007080:	4575      	cmp	r5, lr
 8007082:	d91c      	bls.n	80070be <D24_GENERIC+0x152>
 8007084:	8d55      	ldrh	r5, [r2, #42]	; 0x2a
 8007086:	b2ef      	uxtb	r7, r5
 8007088:	2d01      	cmp	r5, #1
 800708a:	b23e      	sxth	r6, r7
 800708c:	d18f      	bne.n	8006fae <D24_GENERIC+0x42>
 800708e:	9d06      	ldr	r5, [sp, #24]
 8007090:	b15d      	cbz	r5, 80070aa <D24_GENERIC+0x13e>
 8007092:	f01e 0f01 	tst.w	lr, #1
 8007096:	d122      	bne.n	80070de <D24_GENERIC+0x172>
 8007098:	7805      	ldrb	r5, [r0, #0]
 800709a:	78c7      	ldrb	r7, [r0, #3]
 800709c:	7846      	ldrb	r6, [r0, #1]
 800709e:	022d      	lsls	r5, r5, #8
 80070a0:	eb05 4c07 	add.w	ip, r5, r7, lsl #16
 80070a4:	44b4      	add	ip, r6
 80070a6:	3002      	adds	r0, #2
 80070a8:	e78e      	b.n	8006fc8 <D24_GENERIC+0x5c>
 80070aa:	7846      	ldrb	r6, [r0, #1]
 80070ac:	f890 c002 	ldrb.w	ip, [r0, #2]
 80070b0:	f810 5b03 	ldrb.w	r5, [r0], #3
 80070b4:	0236      	lsls	r6, r6, #8
 80070b6:	eb06 4c0c 	add.w	ip, r6, ip, lsl #16
 80070ba:	44ac      	add	ip, r5
 80070bc:	e784      	b.n	8006fc8 <D24_GENERIC+0x5c>
 80070be:	f8dd 9008 	ldr.w	r9, [sp, #8]
 80070c2:	61d3      	str	r3, [r2, #28]
 80070c4:	9b07      	ldr	r3, [sp, #28]
 80070c6:	6094      	str	r4, [r2, #8]
 80070c8:	2000      	movs	r0, #0
 80070ca:	f8c2 b00c 	str.w	fp, [r2, #12]
 80070ce:	f8c2 a010 	str.w	sl, [r2, #16]
 80070d2:	f8c2 9014 	str.w	r9, [r2, #20]
 80070d6:	6193      	str	r3, [r2, #24]
 80070d8:	b009      	add	sp, #36	; 0x24
 80070da:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80070de:	78c5      	ldrb	r5, [r0, #3]
 80070e0:	7887      	ldrb	r7, [r0, #2]
 80070e2:	f810 6b04 	ldrb.w	r6, [r0], #4
 80070e6:	022d      	lsls	r5, r5, #8
 80070e8:	eb05 4c07 	add.w	ip, r5, r7, lsl #16
 80070ec:	44b4      	add	ip, r6
 80070ee:	e76b      	b.n	8006fc8 <D24_GENERIC+0x5c>
 80070f0:	200000c8 	.word	0x200000c8
 80070f4:	00030001 	.word	0x00030001
 80070f8:	00060007 	.word	0x00060007

080070fc <D32_GENERIC>:
 80070fc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8007100:	8cd5      	ldrh	r5, [r2, #38]	; 0x26
 8007102:	6993      	ldr	r3, [r2, #24]
 8007104:	6b14      	ldr	r4, [r2, #48]	; 0x30
 8007106:	f8d2 a010 	ldr.w	sl, [r2, #16]
 800710a:	f8d2 9014 	ldr.w	r9, [r2, #20]
 800710e:	69d6      	ldr	r6, [r2, #28]
 8007110:	f8d2 b00c 	ldr.w	fp, [r2, #12]
 8007114:	b089      	sub	sp, #36	; 0x24
 8007116:	9307      	str	r3, [sp, #28]
 8007118:	9403      	str	r4, [sp, #12]
 800711a:	6893      	ldr	r3, [r2, #8]
 800711c:	6b54      	ldr	r4, [r2, #52]	; 0x34
 800711e:	9104      	str	r1, [sp, #16]
 8007120:	2d00      	cmp	r5, #0
 8007122:	f000 809f 	beq.w	8007264 <D32_GENERIC+0x168>
 8007126:	f004 0510 	and.w	r5, r4, #16
 800712a:	f004 0420 	and.w	r4, r4, #32
 800712e:	9505      	str	r5, [sp, #20]
 8007130:	4953      	ldr	r1, [pc, #332]	; (8007280 <D32_GENERIC+0x184>)
 8007132:	9406      	str	r4, [sp, #24]
 8007134:	f04f 0c00 	mov.w	ip, #0
 8007138:	f8cd 9008 	str.w	r9, [sp, #8]
 800713c:	461d      	mov	r5, r3
 800713e:	4617      	mov	r7, r2
 8007140:	e077      	b.n	8007232 <D32_GENERIC+0x136>
 8007142:	f818 3003 	ldrb.w	r3, [r8, r3]
 8007146:	f810 800e 	ldrb.w	r8, [r0, lr]
 800714a:	f810 e002 	ldrb.w	lr, [r0, r2]
 800714e:	7800      	ldrb	r0, [r0, #0]
 8007150:	041b      	lsls	r3, r3, #16
 8007152:	eb03 6308 	add.w	r3, r3, r8, lsl #24
 8007156:	eb03 230e 	add.w	r3, r3, lr, lsl #8
 800715a:	4403      	add	r3, r0
 800715c:	eb04 0042 	add.w	r0, r4, r2, lsl #1
 8007160:	b2dc      	uxtb	r4, r3
 8007162:	f3c3 2207 	ubfx	r2, r3, #8, #8
 8007166:	f3c3 4807 	ubfx	r8, r3, #16, #8
 800716a:	f851 4024 	ldr.w	r4, [r1, r4, lsl #2]
 800716e:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
 8007172:	0e1b      	lsrs	r3, r3, #24
 8007174:	eb04 2496 	add.w	r4, r4, r6, lsr #10
 8007178:	f851 6028 	ldr.w	r6, [r1, r8, lsl #2]
 800717c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8007180:	eb02 2294 	add.w	r2, r2, r4, lsr #10
 8007184:	eb06 2e92 	add.w	lr, r6, r2, lsr #10
 8007188:	eb03 269e 	add.w	r6, r3, lr, lsr #10
 800718c:	f3c6 0309 	ubfx	r3, r6, #0, #10
 8007190:	f3c4 0409 	ubfx	r4, r4, #0, #10
 8007194:	f3c2 0209 	ubfx	r2, r2, #0, #10
 8007198:	f3ce 0e09 	ubfx	lr, lr, #0, #10
 800719c:	ea43 4e0e 	orr.w	lr, r3, lr, lsl #16
 80071a0:	ea42 4204 	orr.w	r2, r2, r4, lsl #16
 80071a4:	4b37      	ldr	r3, [pc, #220]	; (8007284 <D32_GENERIC+0x188>)
 80071a6:	fb22 b403 	smlad	r4, r2, r3, fp
 80071aa:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 80071ae:	fb2e 4803 	smlad	r8, lr, r3, r4
 80071b2:	4b35      	ldr	r3, [pc, #212]	; (8007288 <D32_GENERIC+0x18c>)
 80071b4:	fb22 5503 	smlad	r5, r2, r3, r5
 80071b8:	4b34      	ldr	r3, [pc, #208]	; (800728c <D32_GENERIC+0x190>)
 80071ba:	fb2e 5b03 	smlad	fp, lr, r3, r5
 80071be:	2301      	movs	r3, #1
 80071c0:	fb22 f203 	smuad	r2, r2, r3
 80071c4:	4b32      	ldr	r3, [pc, #200]	; (8007290 <D32_GENERIC+0x194>)
 80071c6:	fb2e 2503 	smlad	r5, lr, r3, r2
 80071ca:	9b02      	ldr	r3, [sp, #8]
 80071cc:	f5a8 4480 	sub.w	r4, r8, #16384	; 0x4000
 80071d0:	eb04 080a 	add.w	r8, r4, sl
 80071d4:	eba8 0803 	sub.w	r8, r8, r3
 80071d8:	4642      	mov	r2, r8
 80071da:	17d3      	asrs	r3, r2, #31
 80071dc:	e9cd 2300 	strd	r2, r3, [sp]
 80071e0:	9b05      	ldr	r3, [sp, #20]
 80071e2:	f10c 0e01 	add.w	lr, ip, #1
 80071e6:	b16b      	cbz	r3, 8007204 <D32_GENERIC+0x108>
 80071e8:	6a3a      	ldr	r2, [r7, #32]
 80071ea:	9b01      	ldr	r3, [sp, #4]
 80071ec:	9402      	str	r4, [sp, #8]
 80071ee:	fba8 8902 	umull	r8, r9, r8, r2
 80071f2:	fb02 9903 	mla	r9, r2, r3, r9
 80071f6:	f118 4800 	adds.w	r8, r8, #2147483648	; 0x80000000
 80071fa:	f149 0900 	adc.w	r9, r9, #0
 80071fe:	ea4f 0a49 	mov.w	sl, r9, lsl #1
 8007202:	4654      	mov	r4, sl
 8007204:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 8007206:	9a04      	ldr	r2, [sp, #16]
 8007208:	fb0c fc03 	mul.w	ip, ip, r3
 800720c:	9b03      	ldr	r3, [sp, #12]
 800720e:	0364      	lsls	r4, r4, #13
 8007210:	f04f 4800 	mov.w	r8, #2147483648	; 0x80000000
 8007214:	f04f 0900 	mov.w	r9, #0
 8007218:	fbc3 8904 	smlal	r8, r9, r3, r4
 800721c:	464b      	mov	r3, r9
 800721e:	109b      	asrs	r3, r3, #2
 8007220:	f303 030f 	ssat	r3, #16, r3
 8007224:	f822 301c 	strh.w	r3, [r2, ip, lsl #1]
 8007228:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 800722a:	fa1f fc8e 	uxth.w	ip, lr
 800722e:	4563      	cmp	r3, ip
 8007230:	d914      	bls.n	800725c <D32_GENERIC+0x160>
 8007232:	8d7c      	ldrh	r4, [r7, #42]	; 0x2a
 8007234:	b2e2      	uxtb	r2, r4
 8007236:	eb02 0e42 	add.w	lr, r2, r2, lsl #1
 800723a:	eb00 080e 	add.w	r8, r0, lr
 800723e:	4253      	negs	r3, r2
 8007240:	2c01      	cmp	r4, #1
 8007242:	eb08 0403 	add.w	r4, r8, r3
 8007246:	f47f af7c 	bne.w	8007142 <D32_GENERIC+0x46>
 800724a:	1d02      	adds	r2, r0, #4
 800724c:	6803      	ldr	r3, [r0, #0]
 800724e:	9806      	ldr	r0, [sp, #24]
 8007250:	b110      	cbz	r0, 8007258 <D32_GENERIC+0x15c>
 8007252:	ba5b      	rev16	r3, r3
 8007254:	4610      	mov	r0, r2
 8007256:	e783      	b.n	8007160 <D32_GENERIC+0x64>
 8007258:	4610      	mov	r0, r2
 800725a:	e781      	b.n	8007160 <D32_GENERIC+0x64>
 800725c:	f8dd 9008 	ldr.w	r9, [sp, #8]
 8007260:	462b      	mov	r3, r5
 8007262:	463a      	mov	r2, r7
 8007264:	6093      	str	r3, [r2, #8]
 8007266:	9b07      	ldr	r3, [sp, #28]
 8007268:	f8c2 b00c 	str.w	fp, [r2, #12]
 800726c:	2000      	movs	r0, #0
 800726e:	61d6      	str	r6, [r2, #28]
 8007270:	f8c2 a010 	str.w	sl, [r2, #16]
 8007274:	f8c2 9014 	str.w	r9, [r2, #20]
 8007278:	6193      	str	r3, [r2, #24]
 800727a:	b009      	add	sp, #36	; 0x24
 800727c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8007280:	200000c8 	.word	0x200000c8
 8007284:	00060003 	.word	0x00060003
 8007288:	000a000c 	.word	0x000a000c
 800728c:	000c000a 	.word	0x000c000a
 8007290:	00030006 	.word	0x00030006

08007294 <D48_GENERIC>:
 8007294:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8007298:	b089      	sub	sp, #36	; 0x24
 800729a:	6953      	ldr	r3, [r2, #20]
 800729c:	68d4      	ldr	r4, [r2, #12]
 800729e:	8cd5      	ldrh	r5, [r2, #38]	; 0x26
 80072a0:	9302      	str	r3, [sp, #8]
 80072a2:	9400      	str	r4, [sp, #0]
 80072a4:	6993      	ldr	r3, [r2, #24]
 80072a6:	6b14      	ldr	r4, [r2, #48]	; 0x30
 80072a8:	9307      	str	r3, [sp, #28]
 80072aa:	9403      	str	r4, [sp, #12]
 80072ac:	f8d2 a010 	ldr.w	sl, [r2, #16]
 80072b0:	69d6      	ldr	r6, [r2, #28]
 80072b2:	6893      	ldr	r3, [r2, #8]
 80072b4:	6b54      	ldr	r4, [r2, #52]	; 0x34
 80072b6:	9104      	str	r1, [sp, #16]
 80072b8:	2d00      	cmp	r5, #0
 80072ba:	f000 80c5 	beq.w	8007448 <D48_GENERIC+0x1b4>
 80072be:	f004 0510 	and.w	r5, r4, #16
 80072c2:	f004 0420 	and.w	r4, r4, #32
 80072c6:	4967      	ldr	r1, [pc, #412]	; (8007464 <D48_GENERIC+0x1d0>)
 80072c8:	9505      	str	r5, [sp, #20]
 80072ca:	9406      	str	r4, [sp, #24]
 80072cc:	f04f 0c00 	mov.w	ip, #0
 80072d0:	4657      	mov	r7, sl
 80072d2:	9301      	str	r3, [sp, #4]
 80072d4:	e09c      	b.n	8007410 <D48_GENERIC+0x17c>
 80072d6:	f81b 4005 	ldrb.w	r4, [fp, r5]
 80072da:	f810 b009 	ldrb.w	fp, [r0, r9]
 80072de:	f81a 9009 	ldrb.w	r9, [sl, r9]
 80072e2:	f810 a00e 	ldrb.w	sl, [r0, lr]
 80072e6:	7800      	ldrb	r0, [r0, #0]
 80072e8:	0424      	lsls	r4, r4, #16
 80072ea:	eb04 6b0b 	add.w	fp, r4, fp, lsl #24
 80072ee:	f818 4005 	ldrb.w	r4, [r8, r5]
 80072f2:	eb0b 2b0a 	add.w	fp, fp, sl, lsl #8
 80072f6:	44a8      	add	r8, r5
 80072f8:	eb04 2409 	add.w	r4, r4, r9, lsl #8
 80072fc:	eb0b 0500 	add.w	r5, fp, r0
 8007300:	eb08 004e 	add.w	r0, r8, lr, lsl #1
 8007304:	fa5f f885 	uxtb.w	r8, r5
 8007308:	f3c5 2e07 	ubfx	lr, r5, #8, #8
 800730c:	f851 a028 	ldr.w	sl, [r1, r8, lsl #2]
 8007310:	f851 902e 	ldr.w	r9, [r1, lr, lsl #2]
 8007314:	f3c5 4e07 	ubfx	lr, r5, #16, #8
 8007318:	0e2d      	lsrs	r5, r5, #24
 800731a:	eb0a 2a96 	add.w	sl, sl, r6, lsr #10
 800731e:	f851 802e 	ldr.w	r8, [r1, lr, lsl #2]
 8007322:	f851 e025 	ldr.w	lr, [r1, r5, lsl #2]
 8007326:	b2e6      	uxtb	r6, r4
 8007328:	eb09 259a 	add.w	r5, r9, sl, lsr #10
 800732c:	f3c4 2407 	ubfx	r4, r4, #8, #8
 8007330:	eb08 2895 	add.w	r8, r8, r5, lsr #10
 8007334:	f851 6026 	ldr.w	r6, [r1, r6, lsl #2]
 8007338:	f851 9024 	ldr.w	r9, [r1, r4, lsl #2]
 800733c:	eb0e 2498 	add.w	r4, lr, r8, lsr #10
 8007340:	eb06 2e94 	add.w	lr, r6, r4, lsr #10
 8007344:	eb09 269e 	add.w	r6, r9, lr, lsr #10
 8007348:	f3c5 0509 	ubfx	r5, r5, #0, #10
 800734c:	f3c4 0409 	ubfx	r4, r4, #0, #10
 8007350:	f3c6 0909 	ubfx	r9, r6, #0, #10
 8007354:	f3ca 0a09 	ubfx	sl, sl, #0, #10
 8007358:	f3c8 0809 	ubfx	r8, r8, #0, #10
 800735c:	f3ce 0e09 	ubfx	lr, lr, #0, #10
 8007360:	ea45 4a0a 	orr.w	sl, r5, sl, lsl #16
 8007364:	ea44 4808 	orr.w	r8, r4, r8, lsl #16
 8007368:	ea49 4e0e 	orr.w	lr, r9, lr, lsl #16
 800736c:	4c3e      	ldr	r4, [pc, #248]	; (8007468 <D48_GENERIC+0x1d4>)
 800736e:	9d00      	ldr	r5, [sp, #0]
 8007370:	fb2a 5404 	smlad	r4, sl, r4, r5
 8007374:	4d3d      	ldr	r5, [pc, #244]	; (800746c <D48_GENERIC+0x1d8>)
 8007376:	fb28 4405 	smlad	r4, r8, r5, r4
 800737a:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800737e:	fb2e 4b03 	smlad	fp, lr, r3, r4
 8007382:	4c3b      	ldr	r4, [pc, #236]	; (8007470 <D48_GENERIC+0x1dc>)
 8007384:	9b01      	ldr	r3, [sp, #4]
 8007386:	fb2a 3304 	smlad	r3, sl, r4, r3
 800738a:	f04f 141b 	mov.w	r4, #1769499	; 0x1b001b
 800738e:	fb28 3304 	smlad	r3, r8, r4, r3
 8007392:	4c38      	ldr	r4, [pc, #224]	; (8007474 <D48_GENERIC+0x1e0>)
 8007394:	fb2e 3304 	smlad	r3, lr, r4, r3
 8007398:	2501      	movs	r5, #1
 800739a:	9300      	str	r3, [sp, #0]
 800739c:	fb2a fa05 	smuad	sl, sl, r5
 80073a0:	4b35      	ldr	r3, [pc, #212]	; (8007478 <D48_GENERIC+0x1e4>)
 80073a2:	fb28 a803 	smlad	r8, r8, r3, sl
 80073a6:	4b35      	ldr	r3, [pc, #212]	; (800747c <D48_GENERIC+0x1e8>)
 80073a8:	fb2e 8303 	smlad	r3, lr, r3, r8
 80073ac:	f5ab 4458 	sub.w	r4, fp, #55296	; 0xd800
 80073b0:	9301      	str	r3, [sp, #4]
 80073b2:	9b02      	ldr	r3, [sp, #8]
 80073b4:	eb04 0807 	add.w	r8, r4, r7
 80073b8:	eba8 0803 	sub.w	r8, r8, r3
 80073bc:	9b05      	ldr	r3, [sp, #20]
 80073be:	4465      	add	r5, ip
 80073c0:	ea4f 7be8 	mov.w	fp, r8, asr #31
 80073c4:	b163      	cbz	r3, 80073e0 <D48_GENERIC+0x14c>
 80073c6:	6a17      	ldr	r7, [r2, #32]
 80073c8:	9402      	str	r4, [sp, #8]
 80073ca:	fba8 8907 	umull	r8, r9, r8, r7
 80073ce:	fb07 990b 	mla	r9, r7, fp, r9
 80073d2:	f118 4800 	adds.w	r8, r8, #2147483648	; 0x80000000
 80073d6:	f149 0900 	adc.w	r9, r9, #0
 80073da:	ea4f 0749 	mov.w	r7, r9, lsl #1
 80073de:	463c      	mov	r4, r7
 80073e0:	f8b2 e028 	ldrh.w	lr, [r2, #40]	; 0x28
 80073e4:	9b03      	ldr	r3, [sp, #12]
 80073e6:	02e4      	lsls	r4, r4, #11
 80073e8:	f04f 4800 	mov.w	r8, #2147483648	; 0x80000000
 80073ec:	f04f 0900 	mov.w	r9, #0
 80073f0:	fb0c fc0e 	mul.w	ip, ip, lr
 80073f4:	fbc3 8904 	smlal	r8, r9, r3, r4
 80073f8:	9b04      	ldr	r3, [sp, #16]
 80073fa:	ea4f 04a9 	mov.w	r4, r9, asr #2
 80073fe:	f304 040f 	ssat	r4, #16, r4
 8007402:	f823 401c 	strh.w	r4, [r3, ip, lsl #1]
 8007406:	8cd4      	ldrh	r4, [r2, #38]	; 0x26
 8007408:	fa1f fc85 	uxth.w	ip, r5
 800740c:	4564      	cmp	r4, ip
 800740e:	d919      	bls.n	8007444 <D48_GENERIC+0x1b0>
 8007410:	8d54      	ldrh	r4, [r2, #42]	; 0x2a
 8007412:	fa5f fe84 	uxtb.w	lr, r4
 8007416:	eb0e 094e 	add.w	r9, lr, lr, lsl #1
 800741a:	f1ce 0500 	rsb	r5, lr, #0
 800741e:	eb00 0b09 	add.w	fp, r0, r9
 8007422:	eb0b 0a05 	add.w	sl, fp, r5
 8007426:	2c01      	cmp	r4, #1
 8007428:	eb0a 0809 	add.w	r8, sl, r9
 800742c:	f47f af53 	bne.w	80072d6 <D48_GENERIC+0x42>
 8007430:	9b06      	ldr	r3, [sp, #24]
 8007432:	6805      	ldr	r5, [r0, #0]
 8007434:	6844      	ldr	r4, [r0, #4]
 8007436:	3006      	adds	r0, #6
 8007438:	2b00      	cmp	r3, #0
 800743a:	f43f af63 	beq.w	8007304 <D48_GENERIC+0x70>
 800743e:	ba6d      	rev16	r5, r5
 8007440:	ba64      	rev16	r4, r4
 8007442:	e75f      	b.n	8007304 <D48_GENERIC+0x70>
 8007444:	9b01      	ldr	r3, [sp, #4]
 8007446:	46ba      	mov	sl, r7
 8007448:	6093      	str	r3, [r2, #8]
 800744a:	9b00      	ldr	r3, [sp, #0]
 800744c:	60d3      	str	r3, [r2, #12]
 800744e:	9b02      	ldr	r3, [sp, #8]
 8007450:	6153      	str	r3, [r2, #20]
 8007452:	9b07      	ldr	r3, [sp, #28]
 8007454:	61d6      	str	r6, [r2, #28]
 8007456:	2000      	movs	r0, #0
 8007458:	f8c2 a010 	str.w	sl, [r2, #16]
 800745c:	6193      	str	r3, [r2, #24]
 800745e:	b009      	add	sp, #36	; 0x24
 8007460:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8007464:	200000c8 	.word	0x200000c8
 8007468:	000f000a 	.word	0x000f000a
 800746c:	00060003 	.word	0x00060003
 8007470:	00150019 	.word	0x00150019
 8007474:	00190015 	.word	0x00190015
 8007478:	00030006 	.word	0x00030006
 800747c:	000a000f 	.word	0x000a000f

08007480 <D64_GENERIC>:
 8007480:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8007484:	b089      	sub	sp, #36	; 0x24
 8007486:	6913      	ldr	r3, [r2, #16]
 8007488:	6895      	ldr	r5, [r2, #8]
 800748a:	9303      	str	r3, [sp, #12]
 800748c:	9501      	str	r5, [sp, #4]
 800748e:	6953      	ldr	r3, [r2, #20]
 8007490:	68d5      	ldr	r5, [r2, #12]
 8007492:	8cd4      	ldrh	r4, [r2, #38]	; 0x26
 8007494:	9304      	str	r3, [sp, #16]
 8007496:	9500      	str	r5, [sp, #0]
 8007498:	6993      	ldr	r3, [r2, #24]
 800749a:	6b15      	ldr	r5, [r2, #48]	; 0x30
 800749c:	9307      	str	r3, [sp, #28]
 800749e:	9505      	str	r5, [sp, #20]
 80074a0:	69d3      	ldr	r3, [r2, #28]
 80074a2:	9106      	str	r1, [sp, #24]
 80074a4:	2c00      	cmp	r4, #0
 80074a6:	f000 80d9 	beq.w	800765c <D64_GENERIC+0x1dc>
 80074aa:	6a11      	ldr	r1, [r2, #32]
 80074ac:	9102      	str	r1, [sp, #8]
 80074ae:	f8df e1ec 	ldr.w	lr, [pc, #492]	; 800769c <D64_GENERIC+0x21c>
 80074b2:	f04f 0c00 	mov.w	ip, #0
 80074b6:	4681      	mov	r9, r0
 80074b8:	e0c1      	b.n	800763e <D64_GENERIC+0x1be>
 80074ba:	eb06 0846 	add.w	r8, r6, r6, lsl #1
 80074be:	4274      	negs	r4, r6
 80074c0:	eb09 0708 	add.w	r7, r9, r8
 80074c4:	eb07 0a44 	add.w	sl, r7, r4, lsl #1
 80074c8:	eb0a 0548 	add.w	r5, sl, r8, lsl #1
 80074cc:	5d38      	ldrb	r0, [r7, r4]
 80074ce:	5d29      	ldrb	r1, [r5, r4]
 80074d0:	f81a b018 	ldrb.w	fp, [sl, r8, lsl #1]
 80074d4:	f819 a008 	ldrb.w	sl, [r9, r8]
 80074d8:	f817 8014 	ldrb.w	r8, [r7, r4, lsl #1]
 80074dc:	f899 7000 	ldrb.w	r7, [r9]
 80074e0:	f815 9014 	ldrb.w	r9, [r5, r4, lsl #1]
 80074e4:	4425      	add	r5, r4
 80074e6:	0409      	lsls	r1, r1, #16
 80074e8:	0400      	lsls	r0, r0, #16
 80074ea:	eb01 610b 	add.w	r1, r1, fp, lsl #24
 80074ee:	eb00 600a 	add.w	r0, r0, sl, lsl #24
 80074f2:	f815 b014 	ldrb.w	fp, [r5, r4, lsl #1]
 80074f6:	eb01 2109 	add.w	r1, r1, r9, lsl #8
 80074fa:	eb05 0444 	add.w	r4, r5, r4, lsl #1
 80074fe:	eb00 2008 	add.w	r0, r0, r8, lsl #8
 8007502:	4459      	add	r1, fp
 8007504:	eb04 0986 	add.w	r9, r4, r6, lsl #2
 8007508:	4438      	add	r0, r7
 800750a:	b2c5      	uxtb	r5, r0
 800750c:	f3c0 2407 	ubfx	r4, r0, #8, #8
 8007510:	f85e 6025 	ldr.w	r6, [lr, r5, lsl #2]
 8007514:	f85e 5024 	ldr.w	r5, [lr, r4, lsl #2]
 8007518:	f3c0 4407 	ubfx	r4, r0, #16, #8
 800751c:	0e00      	lsrs	r0, r0, #24
 800751e:	eb03 0806 	add.w	r8, r3, r6
 8007522:	f85e 7024 	ldr.w	r7, [lr, r4, lsl #2]
 8007526:	f85e 4020 	ldr.w	r4, [lr, r0, lsl #2]
 800752a:	f3c1 2307 	ubfx	r3, r1, #8, #8
 800752e:	b2c8      	uxtb	r0, r1
 8007530:	eb05 2598 	add.w	r5, r5, r8, lsr #10
 8007534:	eb07 2795 	add.w	r7, r7, r5, lsr #10
 8007538:	f85e 6020 	ldr.w	r6, [lr, r0, lsl #2]
 800753c:	f85e 0023 	ldr.w	r0, [lr, r3, lsl #2]
 8007540:	f3c1 4307 	ubfx	r3, r1, #16, #8
 8007544:	eb04 2497 	add.w	r4, r4, r7, lsr #10
 8007548:	0e09      	lsrs	r1, r1, #24
 800754a:	eb06 2694 	add.w	r6, r6, r4, lsr #10
 800754e:	f85e 3023 	ldr.w	r3, [lr, r3, lsl #2]
 8007552:	f85e 1021 	ldr.w	r1, [lr, r1, lsl #2]
 8007556:	eb00 2096 	add.w	r0, r0, r6, lsr #10
 800755a:	eb03 2a90 	add.w	sl, r3, r0, lsr #10
 800755e:	eb01 219a 	add.w	r1, r1, sl, lsr #10
 8007562:	f3ca 0309 	ubfx	r3, sl, #0, #10
 8007566:	f3c5 0509 	ubfx	r5, r5, #0, #10
 800756a:	f3c4 0409 	ubfx	r4, r4, #0, #10
 800756e:	f3c6 0609 	ubfx	r6, r6, #0, #10
 8007572:	f3c1 0a09 	ubfx	sl, r1, #0, #10
 8007576:	f3c8 0809 	ubfx	r8, r8, #0, #10
 800757a:	f3c7 0709 	ubfx	r7, r7, #0, #10
 800757e:	f3c0 0009 	ubfx	r0, r0, #0, #10
 8007582:	ea44 4707 	orr.w	r7, r4, r7, lsl #16
 8007586:	ea4a 4a03 	orr.w	sl, sl, r3, lsl #16
 800758a:	ea45 4808 	orr.w	r8, r5, r8, lsl #16
 800758e:	0a8b      	lsrs	r3, r1, #10
 8007590:	ea40 4006 	orr.w	r0, r0, r6, lsl #16
 8007594:	4939      	ldr	r1, [pc, #228]	; (800767c <D64_GENERIC+0x1fc>)
 8007596:	9c00      	ldr	r4, [sp, #0]
 8007598:	fb28 4101 	smlad	r1, r8, r1, r4
 800759c:	4c38      	ldr	r4, [pc, #224]	; (8007680 <D64_GENERIC+0x200>)
 800759e:	fb27 1104 	smlad	r1, r7, r4, r1
 80075a2:	4c38      	ldr	r4, [pc, #224]	; (8007684 <D64_GENERIC+0x204>)
 80075a4:	fb20 1104 	smlad	r1, r0, r4, r1
 80075a8:	f44f 3680 	mov.w	r6, #65536	; 0x10000
 80075ac:	fb2a 1106 	smlad	r1, sl, r6, r1
 80075b0:	4c35      	ldr	r4, [pc, #212]	; (8007688 <D64_GENERIC+0x208>)
 80075b2:	9d01      	ldr	r5, [sp, #4]
 80075b4:	fb28 5404 	smlad	r4, r8, r4, r5
 80075b8:	4d33      	ldr	r5, [pc, #204]	; (8007688 <D64_GENERIC+0x208>)
 80075ba:	fb2a 4415 	smladx	r4, sl, r5, r4
 80075be:	4d33      	ldr	r5, [pc, #204]	; (800768c <D64_GENERIC+0x20c>)
 80075c0:	fb27 4405 	smlad	r4, r7, r5, r4
 80075c4:	fb20 4415 	smladx	r4, r0, r5, r4
 80075c8:	2501      	movs	r5, #1
 80075ca:	9400      	str	r4, [sp, #0]
 80075cc:	fb28 f805 	smuad	r8, r8, r5
 80075d0:	4c2f      	ldr	r4, [pc, #188]	; (8007690 <D64_GENERIC+0x210>)
 80075d2:	fb27 8704 	smlad	r7, r7, r4, r8
 80075d6:	4c2f      	ldr	r4, [pc, #188]	; (8007694 <D64_GENERIC+0x214>)
 80075d8:	fb20 7004 	smlad	r0, r0, r4, r7
 80075dc:	4c2e      	ldr	r4, [pc, #184]	; (8007698 <D64_GENERIC+0x218>)
 80075de:	fb2a 0004 	smlad	r0, sl, r4, r0
 80075e2:	f5a1 3600 	sub.w	r6, r1, #131072	; 0x20000
 80075e6:	9902      	ldr	r1, [sp, #8]
 80075e8:	9001      	str	r0, [sp, #4]
 80075ea:	b189      	cbz	r1, 8007610 <D64_GENERIC+0x190>
 80075ec:	9803      	ldr	r0, [sp, #12]
 80075ee:	9c04      	ldr	r4, [sp, #16]
 80075f0:	9604      	str	r6, [sp, #16]
 80075f2:	4430      	add	r0, r6
 80075f4:	1b00      	subs	r0, r0, r4
 80075f6:	17c5      	asrs	r5, r0, #31
 80075f8:	460f      	mov	r7, r1
 80075fa:	fba0 0101 	umull	r0, r1, r0, r1
 80075fe:	fb07 1105 	mla	r1, r7, r5, r1
 8007602:	f110 4000 	adds.w	r0, r0, #2147483648	; 0x80000000
 8007606:	f141 0100 	adc.w	r1, r1, #0
 800760a:	0049      	lsls	r1, r1, #1
 800760c:	9103      	str	r1, [sp, #12]
 800760e:	460e      	mov	r6, r1
 8007610:	8d14      	ldrh	r4, [r2, #40]	; 0x28
 8007612:	9905      	ldr	r1, [sp, #20]
 8007614:	9806      	ldr	r0, [sp, #24]
 8007616:	02b6      	lsls	r6, r6, #10
 8007618:	f04f 4700 	mov.w	r7, #2147483648	; 0x80000000
 800761c:	f04f 0800 	mov.w	r8, #0
 8007620:	fb0c f404 	mul.w	r4, ip, r4
 8007624:	fbc1 7806 	smlal	r7, r8, r1, r6
 8007628:	4641      	mov	r1, r8
 800762a:	1089      	asrs	r1, r1, #2
 800762c:	f301 010f 	ssat	r1, #16, r1
 8007630:	f820 1014 	strh.w	r1, [r0, r4, lsl #1]
 8007634:	8cd1      	ldrh	r1, [r2, #38]	; 0x26
 8007636:	f10c 0c01 	add.w	ip, ip, #1
 800763a:	4561      	cmp	r1, ip
 800763c:	dd0e      	ble.n	800765c <D64_GENERIC+0x1dc>
 800763e:	8d56      	ldrh	r6, [r2, #42]	; 0x2a
 8007640:	2e01      	cmp	r6, #1
 8007642:	f47f af3a 	bne.w	80074ba <D64_GENERIC+0x3a>
 8007646:	6b56      	ldr	r6, [r2, #52]	; 0x34
 8007648:	06b4      	lsls	r4, r6, #26
 800764a:	e899 0003 	ldmia.w	r9, {r0, r1}
 800764e:	f109 0908 	add.w	r9, r9, #8
 8007652:	f57f af5a 	bpl.w	800750a <D64_GENERIC+0x8a>
 8007656:	ba40      	rev16	r0, r0
 8007658:	ba49      	rev16	r1, r1
 800765a:	e756      	b.n	800750a <D64_GENERIC+0x8a>
 800765c:	61d3      	str	r3, [r2, #28]
 800765e:	9b03      	ldr	r3, [sp, #12]
 8007660:	9901      	ldr	r1, [sp, #4]
 8007662:	6113      	str	r3, [r2, #16]
 8007664:	9b04      	ldr	r3, [sp, #16]
 8007666:	6091      	str	r1, [r2, #8]
 8007668:	6153      	str	r3, [r2, #20]
 800766a:	9900      	ldr	r1, [sp, #0]
 800766c:	9b07      	ldr	r3, [sp, #28]
 800766e:	60d1      	str	r1, [r2, #12]
 8007670:	2000      	movs	r0, #0
 8007672:	6193      	str	r3, [r2, #24]
 8007674:	b009      	add	sp, #36	; 0x24
 8007676:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800767a:	bf00      	nop
 800767c:	001c0015 	.word	0x001c0015
 8007680:	000f000a 	.word	0x000f000a
 8007684:	00060003 	.word	0x00060003
 8007688:	0024002a 	.word	0x0024002a
 800768c:	002e0030 	.word	0x002e0030
 8007690:	00030006 	.word	0x00030006
 8007694:	000a000f 	.word	0x000a000f
 8007698:	0015001c 	.word	0x0015001c
 800769c:	200000c8 	.word	0x200000c8

080076a0 <D80_GENERIC>:
 80076a0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80076a4:	b08b      	sub	sp, #44	; 0x2c
 80076a6:	6914      	ldr	r4, [r2, #16]
 80076a8:	9404      	str	r4, [sp, #16]
 80076aa:	6954      	ldr	r4, [r2, #20]
 80076ac:	9405      	str	r4, [sp, #20]
 80076ae:	6994      	ldr	r4, [r2, #24]
 80076b0:	9409      	str	r4, [sp, #36]	; 0x24
 80076b2:	6894      	ldr	r4, [r2, #8]
 80076b4:	9402      	str	r4, [sp, #8]
 80076b6:	8cd3      	ldrh	r3, [r2, #38]	; 0x26
 80076b8:	68d4      	ldr	r4, [r2, #12]
 80076ba:	9401      	str	r4, [sp, #4]
 80076bc:	6b14      	ldr	r4, [r2, #48]	; 0x30
 80076be:	f8d2 b01c 	ldr.w	fp, [r2, #28]
 80076c2:	9406      	str	r4, [sp, #24]
 80076c4:	9107      	str	r1, [sp, #28]
 80076c6:	2b00      	cmp	r3, #0
 80076c8:	f000 810f 	beq.w	80078ea <D80_GENERIC+0x24a>
 80076cc:	6a13      	ldr	r3, [r2, #32]
 80076ce:	9308      	str	r3, [sp, #32]
 80076d0:	2300      	movs	r3, #0
 80076d2:	9200      	str	r2, [sp, #0]
 80076d4:	f8df 9264 	ldr.w	r9, [pc, #612]	; 800793c <D80_GENERIC+0x29c>
 80076d8:	f8cd b00c 	str.w	fp, [sp, #12]
 80076dc:	461a      	mov	r2, r3
 80076de:	e0ed      	b.n	80078bc <D80_GENERIC+0x21c>
 80076e0:	fa5f fc8c 	uxtb.w	ip, ip
 80076e4:	fa0f f48c 	sxth.w	r4, ip
 80076e8:	0066      	lsls	r6, r4, #1
 80076ea:	eb06 0804 	add.w	r8, r6, r4
 80076ee:	f1cc 0500 	rsb	r5, ip, #0
 80076f2:	eb00 0108 	add.w	r1, r0, r8
 80076f6:	eb04 0484 	add.w	r4, r4, r4, lsl #2
 80076fa:	194b      	adds	r3, r1, r5
 80076fc:	5d49      	ldrb	r1, [r1, r5]
 80076fe:	f810 a008 	ldrb.w	sl, [r0, r8]
 8007702:	f813 b004 	ldrb.w	fp, [r3, r4]
 8007706:	f810 c00c 	ldrb.w	ip, [r0, ip]
 800770a:	f890 8000 	ldrb.w	r8, [r0]
 800770e:	eb03 0e04 	add.w	lr, r3, r4
 8007712:	eb0e 0705 	add.w	r7, lr, r5
 8007716:	0409      	lsls	r1, r1, #16
 8007718:	f81e 3005 	ldrb.w	r3, [lr, r5]
 800771c:	f81e e015 	ldrb.w	lr, [lr, r5, lsl #1]
 8007720:	eb01 610a 	add.w	r1, r1, sl, lsl #24
 8007724:	eb07 0a45 	add.w	sl, r7, r5, lsl #1
 8007728:	eb0a 0004 	add.w	r0, sl, r4
 800772c:	041b      	lsls	r3, r3, #16
 800772e:	f81a a004 	ldrb.w	sl, [sl, r4]
 8007732:	f817 7015 	ldrb.w	r7, [r7, r5, lsl #1]
 8007736:	5d44      	ldrb	r4, [r0, r5]
 8007738:	eb03 630b 	add.w	r3, r3, fp, lsl #24
 800773c:	eb01 210c 	add.w	r1, r1, ip, lsl #8
 8007740:	4428      	add	r0, r5
 8007742:	eb03 230e 	add.w	r3, r3, lr, lsl #8
 8007746:	4441      	add	r1, r8
 8007748:	4430      	add	r0, r6
 800774a:	eb04 240a 	add.w	r4, r4, sl, lsl #8
 800774e:	441f      	add	r7, r3
 8007750:	b2cd      	uxtb	r5, r1
 8007752:	f3c1 2307 	ubfx	r3, r1, #8, #8
 8007756:	f859 6025 	ldr.w	r6, [r9, r5, lsl #2]
 800775a:	f859 e023 	ldr.w	lr, [r9, r3, lsl #2]
 800775e:	9b03      	ldr	r3, [sp, #12]
 8007760:	f3c1 4507 	ubfx	r5, r1, #16, #8
 8007764:	0e09      	lsrs	r1, r1, #24
 8007766:	4433      	add	r3, r6
 8007768:	f859 8025 	ldr.w	r8, [r9, r5, lsl #2]
 800776c:	f859 6021 	ldr.w	r6, [r9, r1, lsl #2]
 8007770:	b2fd      	uxtb	r5, r7
 8007772:	eb0e 2193 	add.w	r1, lr, r3, lsr #10
 8007776:	469b      	mov	fp, r3
 8007778:	f3c7 2307 	ubfx	r3, r7, #8, #8
 800777c:	eb08 2891 	add.w	r8, r8, r1, lsr #10
 8007780:	f859 c025 	ldr.w	ip, [r9, r5, lsl #2]
 8007784:	f859 5023 	ldr.w	r5, [r9, r3, lsl #2]
 8007788:	f3c7 4e07 	ubfx	lr, r7, #16, #8
 800778c:	eb06 2698 	add.w	r6, r6, r8, lsr #10
 8007790:	0e3b      	lsrs	r3, r7, #24
 8007792:	eb0c 2c96 	add.w	ip, ip, r6, lsr #10
 8007796:	f859 702e 	ldr.w	r7, [r9, lr, lsl #2]
 800779a:	f859 3023 	ldr.w	r3, [r9, r3, lsl #2]
 800779e:	fa5f fe84 	uxtb.w	lr, r4
 80077a2:	eb05 259c 	add.w	r5, r5, ip, lsr #10
 80077a6:	f3c4 2407 	ubfx	r4, r4, #8, #8
 80077aa:	eb07 2795 	add.w	r7, r7, r5, lsr #10
 80077ae:	f859 e02e 	ldr.w	lr, [r9, lr, lsl #2]
 80077b2:	f859 4024 	ldr.w	r4, [r9, r4, lsl #2]
 80077b6:	eb03 2397 	add.w	r3, r3, r7, lsr #10
 80077ba:	eb0e 2e93 	add.w	lr, lr, r3, lsr #10
 80077be:	eb04 249e 	add.w	r4, r4, lr, lsr #10
 80077c2:	f3c1 0109 	ubfx	r1, r1, #0, #10
 80077c6:	f3c3 0309 	ubfx	r3, r3, #0, #10
 80077ca:	f3cb 0b09 	ubfx	fp, fp, #0, #10
 80077ce:	f3c7 0709 	ubfx	r7, r7, #0, #10
 80077d2:	f3c6 0609 	ubfx	r6, r6, #0, #10
 80077d6:	f3c5 0509 	ubfx	r5, r5, #0, #10
 80077da:	ea41 4b0b 	orr.w	fp, r1, fp, lsl #16
 80077de:	ea43 4707 	orr.w	r7, r3, r7, lsl #16
 80077e2:	f3c4 0109 	ubfx	r1, r4, #0, #10
 80077e6:	0aa3      	lsrs	r3, r4, #10
 80077e8:	f3c8 0809 	ubfx	r8, r8, #0, #10
 80077ec:	f3cc 0c09 	ubfx	ip, ip, #0, #10
 80077f0:	f3ce 0e09 	ubfx	lr, lr, #0, #10
 80077f4:	ea41 4e0e 	orr.w	lr, r1, lr, lsl #16
 80077f8:	9303      	str	r3, [sp, #12]
 80077fa:	ea46 4808 	orr.w	r8, r6, r8, lsl #16
 80077fe:	ea45 4c0c 	orr.w	ip, r5, ip, lsl #16
 8007802:	4b42      	ldr	r3, [pc, #264]	; (800790c <D80_GENERIC+0x26c>)
 8007804:	9901      	ldr	r1, [sp, #4]
 8007806:	fb2b 1303 	smlad	r3, fp, r3, r1
 800780a:	4941      	ldr	r1, [pc, #260]	; (8007910 <D80_GENERIC+0x270>)
 800780c:	fb28 3301 	smlad	r3, r8, r1, r3
 8007810:	4940      	ldr	r1, [pc, #256]	; (8007914 <D80_GENERIC+0x274>)
 8007812:	fb2c 3301 	smlad	r3, ip, r1, r3
 8007816:	4940      	ldr	r1, [pc, #256]	; (8007918 <D80_GENERIC+0x278>)
 8007818:	fb27 3301 	smlad	r3, r7, r1, r3
 800781c:	f44f 3180 	mov.w	r1, #65536	; 0x10000
 8007820:	fb2e 3301 	smlad	r3, lr, r1, r3
 8007824:	493d      	ldr	r1, [pc, #244]	; (800791c <D80_GENERIC+0x27c>)
 8007826:	9c02      	ldr	r4, [sp, #8]
 8007828:	fb2b 4401 	smlad	r4, fp, r1, r4
 800782c:	493c      	ldr	r1, [pc, #240]	; (8007920 <D80_GENERIC+0x280>)
 800782e:	fb28 4401 	smlad	r4, r8, r1, r4
 8007832:	f04f 114b 	mov.w	r1, #4915275	; 0x4b004b
 8007836:	fb2c 4101 	smlad	r1, ip, r1, r4
 800783a:	4c3a      	ldr	r4, [pc, #232]	; (8007924 <D80_GENERIC+0x284>)
 800783c:	fb27 1104 	smlad	r1, r7, r4, r1
 8007840:	4c39      	ldr	r4, [pc, #228]	; (8007928 <D80_GENERIC+0x288>)
 8007842:	fb2e 1104 	smlad	r1, lr, r4, r1
 8007846:	9101      	str	r1, [sp, #4]
 8007848:	2101      	movs	r1, #1
 800784a:	fb2b fb01 	smuad	fp, fp, r1
 800784e:	4937      	ldr	r1, [pc, #220]	; (800792c <D80_GENERIC+0x28c>)
 8007850:	fb28 b801 	smlad	r8, r8, r1, fp
 8007854:	4d36      	ldr	r5, [pc, #216]	; (8007930 <D80_GENERIC+0x290>)
 8007856:	fb2c 8c05 	smlad	ip, ip, r5, r8
 800785a:	4d36      	ldr	r5, [pc, #216]	; (8007934 <D80_GENERIC+0x294>)
 800785c:	fb27 c705 	smlad	r7, r7, r5, ip
 8007860:	4d35      	ldr	r5, [pc, #212]	; (8007938 <D80_GENERIC+0x298>)
 8007862:	fb2e 7105 	smlad	r1, lr, r5, r7
 8007866:	9102      	str	r1, [sp, #8]
 8007868:	9908      	ldr	r1, [sp, #32]
 800786a:	f5a3 337a 	sub.w	r3, r3, #256000	; 0x3e800
 800786e:	b181      	cbz	r1, 8007892 <D80_GENERIC+0x1f2>
 8007870:	9c04      	ldr	r4, [sp, #16]
 8007872:	9d05      	ldr	r5, [sp, #20]
 8007874:	9305      	str	r3, [sp, #20]
 8007876:	441c      	add	r4, r3
 8007878:	1b64      	subs	r4, r4, r5
 800787a:	17e7      	asrs	r7, r4, #31
 800787c:	fba4 4501 	umull	r4, r5, r4, r1
 8007880:	fb01 5507 	mla	r5, r1, r7, r5
 8007884:	f114 4400 	adds.w	r4, r4, #2147483648	; 0x80000000
 8007888:	f145 0500 	adc.w	r5, r5, #0
 800788c:	0069      	lsls	r1, r5, #1
 800788e:	9104      	str	r1, [sp, #16]
 8007890:	460b      	mov	r3, r1
 8007892:	9e00      	ldr	r6, [sp, #0]
 8007894:	9f06      	ldr	r7, [sp, #24]
 8007896:	8d31      	ldrh	r1, [r6, #40]	; 0x28
 8007898:	025b      	lsls	r3, r3, #9
 800789a:	f04f 4400 	mov.w	r4, #2147483648	; 0x80000000
 800789e:	2500      	movs	r5, #0
 80078a0:	fb02 f101 	mul.w	r1, r2, r1
 80078a4:	fbc7 4503 	smlal	r4, r5, r7, r3
 80078a8:	9c07      	ldr	r4, [sp, #28]
 80078aa:	10ab      	asrs	r3, r5, #2
 80078ac:	f303 030f 	ssat	r3, #16, r3
 80078b0:	f824 3011 	strh.w	r3, [r4, r1, lsl #1]
 80078b4:	8cf3      	ldrh	r3, [r6, #38]	; 0x26
 80078b6:	3201      	adds	r2, #1
 80078b8:	4293      	cmp	r3, r2
 80078ba:	dd13      	ble.n	80078e4 <D80_GENERIC+0x244>
 80078bc:	9b00      	ldr	r3, [sp, #0]
 80078be:	f8b3 c02a 	ldrh.w	ip, [r3, #42]	; 0x2a
 80078c2:	f1bc 0f01 	cmp.w	ip, #1
 80078c6:	f47f af0b 	bne.w	80076e0 <D80_GENERIC+0x40>
 80078ca:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80078cc:	6884      	ldr	r4, [r0, #8]
 80078ce:	069b      	lsls	r3, r3, #26
 80078d0:	e890 0082 	ldmia.w	r0, {r1, r7}
 80078d4:	f100 000a 	add.w	r0, r0, #10
 80078d8:	f57f af3a 	bpl.w	8007750 <D80_GENERIC+0xb0>
 80078dc:	ba49      	rev16	r1, r1
 80078de:	ba7f      	rev16	r7, r7
 80078e0:	ba64      	rev16	r4, r4
 80078e2:	e735      	b.n	8007750 <D80_GENERIC+0xb0>
 80078e4:	f8dd b00c 	ldr.w	fp, [sp, #12]
 80078e8:	4632      	mov	r2, r6
 80078ea:	9b02      	ldr	r3, [sp, #8]
 80078ec:	6093      	str	r3, [r2, #8]
 80078ee:	9b01      	ldr	r3, [sp, #4]
 80078f0:	60d3      	str	r3, [r2, #12]
 80078f2:	9b04      	ldr	r3, [sp, #16]
 80078f4:	6113      	str	r3, [r2, #16]
 80078f6:	9b05      	ldr	r3, [sp, #20]
 80078f8:	6153      	str	r3, [r2, #20]
 80078fa:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80078fc:	f8c2 b01c 	str.w	fp, [r2, #28]
 8007900:	2000      	movs	r0, #0
 8007902:	6193      	str	r3, [r2, #24]
 8007904:	b00b      	add	sp, #44	; 0x2c
 8007906:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800790a:	bf00      	nop
 800790c:	002d0024 	.word	0x002d0024
 8007910:	001c0015 	.word	0x001c0015
 8007914:	000f000a 	.word	0x000f000a
 8007918:	00060003 	.word	0x00060003
 800791c:	0037003f 	.word	0x0037003f
 8007920:	00450049 	.word	0x00450049
 8007924:	00490045 	.word	0x00490045
 8007928:	003f0037 	.word	0x003f0037
 800792c:	00030006 	.word	0x00030006
 8007930:	000a000f 	.word	0x000a000f
 8007934:	0015001c 	.word	0x0015001c
 8007938:	0024002d 	.word	0x0024002d
 800793c:	200000c8 	.word	0x200000c8

08007940 <D128_GENERIC>:
 8007940:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8007944:	b093      	sub	sp, #76	; 0x4c
 8007946:	8cd3      	ldrh	r3, [r2, #38]	; 0x26
 8007948:	9005      	str	r0, [sp, #20]
 800794a:	4610      	mov	r0, r2
 800794c:	9201      	str	r2, [sp, #4]
 800794e:	6912      	ldr	r2, [r2, #16]
 8007950:	920c      	str	r2, [sp, #48]	; 0x30
 8007952:	4602      	mov	r2, r0
 8007954:	6940      	ldr	r0, [r0, #20]
 8007956:	900d      	str	r0, [sp, #52]	; 0x34
 8007958:	4610      	mov	r0, r2
 800795a:	4614      	mov	r4, r2
 800795c:	6992      	ldr	r2, [r2, #24]
 800795e:	9211      	str	r2, [sp, #68]	; 0x44
 8007960:	69c2      	ldr	r2, [r0, #28]
 8007962:	9202      	str	r2, [sp, #8]
 8007964:	68e2      	ldr	r2, [r4, #12]
 8007966:	6880      	ldr	r0, [r0, #8]
 8007968:	9203      	str	r2, [sp, #12]
 800796a:	6b22      	ldr	r2, [r4, #48]	; 0x30
 800796c:	9004      	str	r0, [sp, #16]
 800796e:	920e      	str	r2, [sp, #56]	; 0x38
 8007970:	910f      	str	r1, [sp, #60]	; 0x3c
 8007972:	2b00      	cmp	r3, #0
 8007974:	f000 819b 	beq.w	8007cae <D128_GENERIC+0x36e>
 8007978:	6a23      	ldr	r3, [r4, #32]
 800797a:	9310      	str	r3, [sp, #64]	; 0x40
 800797c:	2300      	movs	r3, #0
 800797e:	f8df 93a8 	ldr.w	r9, [pc, #936]	; 8007d28 <D128_GENERIC+0x3e8>
 8007982:	9306      	str	r3, [sp, #24]
 8007984:	e17a      	b.n	8007c7c <D128_GENERIC+0x33c>
 8007986:	b2d2      	uxtb	r2, r2
 8007988:	9d05      	ldr	r5, [sp, #20]
 800798a:	b214      	sxth	r4, r2
 800798c:	eb04 0a44 	add.w	sl, r4, r4, lsl #1
 8007990:	4250      	negs	r0, r2
 8007992:	eb05 010a 	add.w	r1, r5, sl
 8007996:	ea4f 0b84 	mov.w	fp, r4, lsl #2
 800799a:	eb01 0800 	add.w	r8, r1, r0
 800799e:	eb0b 0c04 	add.w	ip, fp, r4
 80079a2:	eb08 070c 	add.w	r7, r8, ip
 80079a6:	183b      	adds	r3, r7, r0
 80079a8:	ebc4 04c4 	rsb	r4, r4, r4, lsl #3
 80079ac:	eb03 0e40 	add.w	lr, r3, r0, lsl #1
 80079b0:	eb0e 0604 	add.w	r6, lr, r4
 80079b4:	9307      	str	r3, [sp, #28]
 80079b6:	1833      	adds	r3, r6, r0
 80079b8:	9305      	str	r3, [sp, #20]
 80079ba:	462b      	mov	r3, r5
 80079bc:	f815 a00a 	ldrb.w	sl, [r5, sl]
 80079c0:	f8cd a020 	str.w	sl, [sp, #32]
 80079c4:	f818 a00c 	ldrb.w	sl, [r8, ip]
 80079c8:	f813 c002 	ldrb.w	ip, [r3, r2]
 80079cc:	f81e 8004 	ldrb.w	r8, [lr, r4]
 80079d0:	5c3a      	ldrb	r2, [r7, r0]
 80079d2:	f817 e010 	ldrb.w	lr, [r7, r0, lsl #1]
 80079d6:	781f      	ldrb	r7, [r3, #0]
 80079d8:	9b07      	ldr	r3, [sp, #28]
 80079da:	9d05      	ldr	r5, [sp, #20]
 80079dc:	f813 3010 	ldrb.w	r3, [r3, r0, lsl #1]
 80079e0:	5c09      	ldrb	r1, [r1, r0]
 80079e2:	9709      	str	r7, [sp, #36]	; 0x24
 80079e4:	9307      	str	r3, [sp, #28]
 80079e6:	f816 7010 	ldrb.w	r7, [r6, r0, lsl #1]
 80079ea:	5c33      	ldrb	r3, [r6, r0]
 80079ec:	0412      	lsls	r2, r2, #16
 80079ee:	eb05 0640 	add.w	r6, r5, r0, lsl #1
 80079f2:	eb02 620a 	add.w	r2, r2, sl, lsl #24
 80079f6:	9d08      	ldr	r5, [sp, #32]
 80079f8:	eb06 0a04 	add.w	sl, r6, r4
 80079fc:	0409      	lsls	r1, r1, #16
 80079fe:	eb01 6105 	add.w	r1, r1, r5, lsl #24
 8007a02:	f81a 5000 	ldrb.w	r5, [sl, r0]
 8007a06:	5d36      	ldrb	r6, [r6, r4]
 8007a08:	9c05      	ldr	r4, [sp, #20]
 8007a0a:	042d      	lsls	r5, r5, #16
 8007a0c:	eb05 6606 	add.w	r6, r5, r6, lsl #24
 8007a10:	eb01 210c 	add.w	r1, r1, ip, lsl #8
 8007a14:	f81a 5010 	ldrb.w	r5, [sl, r0, lsl #1]
 8007a18:	f814 4010 	ldrb.w	r4, [r4, r0, lsl #1]
 8007a1c:	eb0a 0c00 	add.w	ip, sl, r0
 8007a20:	041b      	lsls	r3, r3, #16
 8007a22:	eb03 6308 	add.w	r3, r3, r8, lsl #24
 8007a26:	eb06 2605 	add.w	r6, r6, r5, lsl #8
 8007a2a:	f81c a010 	ldrb.w	sl, [ip, r0, lsl #1]
 8007a2e:	9d07      	ldr	r5, [sp, #28]
 8007a30:	eb03 2307 	add.w	r3, r3, r7, lsl #8
 8007a34:	eb0c 0040 	add.w	r0, ip, r0, lsl #1
 8007a38:	9f09      	ldr	r7, [sp, #36]	; 0x24
 8007a3a:	4458      	add	r0, fp
 8007a3c:	eb02 220e 	add.w	r2, r2, lr, lsl #8
 8007a40:	9005      	str	r0, [sp, #20]
 8007a42:	4439      	add	r1, r7
 8007a44:	442a      	add	r2, r5
 8007a46:	44b2      	add	sl, r6
 8007a48:	1918      	adds	r0, r3, r4
 8007a4a:	b2cb      	uxtb	r3, r1
 8007a4c:	f3c1 2407 	ubfx	r4, r1, #8, #8
 8007a50:	9e02      	ldr	r6, [sp, #8]
 8007a52:	f859 3023 	ldr.w	r3, [r9, r3, lsl #2]
 8007a56:	f859 5024 	ldr.w	r5, [r9, r4, lsl #2]
 8007a5a:	f3c1 4407 	ubfx	r4, r1, #16, #8
 8007a5e:	441e      	add	r6, r3
 8007a60:	0e09      	lsrs	r1, r1, #24
 8007a62:	4633      	mov	r3, r6
 8007a64:	f859 6024 	ldr.w	r6, [r9, r4, lsl #2]
 8007a68:	f859 7021 	ldr.w	r7, [r9, r1, lsl #2]
 8007a6c:	b2d4      	uxtb	r4, r2
 8007a6e:	eb05 2593 	add.w	r5, r5, r3, lsr #10
 8007a72:	f3c2 2107 	ubfx	r1, r2, #8, #8
 8007a76:	eb06 2b95 	add.w	fp, r6, r5, lsr #10
 8007a7a:	f859 6024 	ldr.w	r6, [r9, r4, lsl #2]
 8007a7e:	f859 1021 	ldr.w	r1, [r9, r1, lsl #2]
 8007a82:	f3c2 4407 	ubfx	r4, r2, #16, #8
 8007a86:	0e12      	lsrs	r2, r2, #24
 8007a88:	eb07 279b 	add.w	r7, r7, fp, lsr #10
 8007a8c:	eb06 2897 	add.w	r8, r6, r7, lsr #10
 8007a90:	f859 6024 	ldr.w	r6, [r9, r4, lsl #2]
 8007a94:	f859 4022 	ldr.w	r4, [r9, r2, lsl #2]
 8007a98:	9702      	str	r7, [sp, #8]
 8007a9a:	b2c2      	uxtb	r2, r0
 8007a9c:	eb01 2198 	add.w	r1, r1, r8, lsr #10
 8007aa0:	eb06 2c91 	add.w	ip, r6, r1, lsr #10
 8007aa4:	f859 6022 	ldr.w	r6, [r9, r2, lsl #2]
 8007aa8:	eb04 249c 	add.w	r4, r4, ip, lsr #10
 8007aac:	f3c0 2207 	ubfx	r2, r0, #8, #8
 8007ab0:	eb06 2e94 	add.w	lr, r6, r4, lsr #10
 8007ab4:	f3c0 4607 	ubfx	r6, r0, #16, #8
 8007ab8:	f859 2022 	ldr.w	r2, [r9, r2, lsl #2]
 8007abc:	f859 7026 	ldr.w	r7, [r9, r6, lsl #2]
 8007ac0:	0e00      	lsrs	r0, r0, #24
 8007ac2:	fa5f f68a 	uxtb.w	r6, sl
 8007ac6:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8007aca:	9309      	str	r3, [sp, #36]	; 0x24
 8007acc:	f859 0020 	ldr.w	r0, [r9, r0, lsl #2]
 8007ad0:	f859 6026 	ldr.w	r6, [r9, r6, lsl #2]
 8007ad4:	eb02 229e 	add.w	r2, r2, lr, lsr #10
 8007ad8:	f3ca 2307 	ubfx	r3, sl, #8, #8
 8007adc:	f3c5 0509 	ubfx	r5, r5, #0, #10
 8007ae0:	950a      	str	r5, [sp, #40]	; 0x28
 8007ae2:	eb07 2792 	add.w	r7, r7, r2, lsr #10
 8007ae6:	f3ca 4507 	ubfx	r5, sl, #16, #8
 8007aea:	eb00 2097 	add.w	r0, r0, r7, lsr #10
 8007aee:	f859 3023 	ldr.w	r3, [r9, r3, lsl #2]
 8007af2:	f859 5025 	ldr.w	r5, [r9, r5, lsl #2]
 8007af6:	f3c2 0209 	ubfx	r2, r2, #0, #10
 8007afa:	920b      	str	r2, [sp, #44]	; 0x2c
 8007afc:	eb06 2690 	add.w	r6, r6, r0, lsr #10
 8007b00:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8007b02:	eb03 2396 	add.w	r3, r3, r6, lsr #10
 8007b06:	f3cc 0c09 	ubfx	ip, ip, #0, #10
 8007b0a:	9307      	str	r3, [sp, #28]
 8007b0c:	eb05 2593 	add.w	r5, r5, r3, lsr #10
 8007b10:	ea4f 6a1a 	mov.w	sl, sl, lsr #24
 8007b14:	9b02      	ldr	r3, [sp, #8]
 8007b16:	f8cd c008 	str.w	ip, [sp, #8]
 8007b1a:	4694      	mov	ip, r2
 8007b1c:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8007b1e:	f859 a02a 	ldr.w	sl, [r9, sl, lsl #2]
 8007b22:	ea4c 4c02 	orr.w	ip, ip, r2, lsl #16
 8007b26:	9a02      	ldr	r2, [sp, #8]
 8007b28:	f3c4 0409 	ubfx	r4, r4, #0, #10
 8007b2c:	eb0a 2a95 	add.w	sl, sl, r5, lsr #10
 8007b30:	ea44 4402 	orr.w	r4, r4, r2, lsl #16
 8007b34:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8007b36:	f8cd a020 	str.w	sl, [sp, #32]
 8007b3a:	f3c8 0809 	ubfx	r8, r8, #0, #10
 8007b3e:	f3c3 0a09 	ubfx	sl, r3, #0, #10
 8007b42:	f3ce 0e09 	ubfx	lr, lr, #0, #10
 8007b46:	9b07      	ldr	r3, [sp, #28]
 8007b48:	f3c1 0109 	ubfx	r1, r1, #0, #10
 8007b4c:	ea41 4108 	orr.w	r1, r1, r8, lsl #16
 8007b50:	ea42 480e 	orr.w	r8, r2, lr, lsl #16
 8007b54:	9a08      	ldr	r2, [sp, #32]
 8007b56:	f3c6 0609 	ubfx	r6, r6, #0, #10
 8007b5a:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8007b5e:	f3cb 0b09 	ubfx	fp, fp, #0, #10
 8007b62:	f3c7 0709 	ubfx	r7, r7, #0, #10
 8007b66:	f3c2 0e09 	ubfx	lr, r2, #0, #10
 8007b6a:	ea43 4306 	orr.w	r3, r3, r6, lsl #16
 8007b6e:	f3c0 0009 	ubfx	r0, r0, #0, #10
 8007b72:	0a96      	lsrs	r6, r2, #10
 8007b74:	f3c5 0509 	ubfx	r5, r5, #0, #10
 8007b78:	9602      	str	r6, [sp, #8]
 8007b7a:	ea40 4007 	orr.w	r0, r0, r7, lsl #16
 8007b7e:	ea4a 4a0b 	orr.w	sl, sl, fp, lsl #16
 8007b82:	ea4e 4505 	orr.w	r5, lr, r5, lsl #16
 8007b86:	4e53      	ldr	r6, [pc, #332]	; (8007cd4 <D128_GENERIC+0x394>)
 8007b88:	9f03      	ldr	r7, [sp, #12]
 8007b8a:	fb2c 7606 	smlad	r6, ip, r6, r7
 8007b8e:	4f52      	ldr	r7, [pc, #328]	; (8007cd8 <D128_GENERIC+0x398>)
 8007b90:	fb2a 6607 	smlad	r6, sl, r7, r6
 8007b94:	4f51      	ldr	r7, [pc, #324]	; (8007cdc <D128_GENERIC+0x39c>)
 8007b96:	fb21 6607 	smlad	r6, r1, r7, r6
 8007b9a:	4f51      	ldr	r7, [pc, #324]	; (8007ce0 <D128_GENERIC+0x3a0>)
 8007b9c:	fb24 6607 	smlad	r6, r4, r7, r6
 8007ba0:	4f50      	ldr	r7, [pc, #320]	; (8007ce4 <D128_GENERIC+0x3a4>)
 8007ba2:	fb28 6607 	smlad	r6, r8, r7, r6
 8007ba6:	4f50      	ldr	r7, [pc, #320]	; (8007ce8 <D128_GENERIC+0x3a8>)
 8007ba8:	fb20 6607 	smlad	r6, r0, r7, r6
 8007bac:	4f4f      	ldr	r7, [pc, #316]	; (8007cec <D128_GENERIC+0x3ac>)
 8007bae:	fb23 6607 	smlad	r6, r3, r7, r6
 8007bb2:	f44f 3780 	mov.w	r7, #65536	; 0x10000
 8007bb6:	fb25 6607 	smlad	r6, r5, r7, r6
 8007bba:	4f4d      	ldr	r7, [pc, #308]	; (8007cf0 <D128_GENERIC+0x3b0>)
 8007bbc:	9a04      	ldr	r2, [sp, #16]
 8007bbe:	fb2c 2e07 	smlad	lr, ip, r7, r2
 8007bc2:	4a4c      	ldr	r2, [pc, #304]	; (8007cf4 <D128_GENERIC+0x3b4>)
 8007bc4:	fb2a ee02 	smlad	lr, sl, r2, lr
 8007bc8:	4f4b      	ldr	r7, [pc, #300]	; (8007cf8 <D128_GENERIC+0x3b8>)
 8007bca:	fb21 ee07 	smlad	lr, r1, r7, lr
 8007bce:	4f4b      	ldr	r7, [pc, #300]	; (8007cfc <D128_GENERIC+0x3bc>)
 8007bd0:	fb24 ee07 	smlad	lr, r4, r7, lr
 8007bd4:	4f4a      	ldr	r7, [pc, #296]	; (8007d00 <D128_GENERIC+0x3c0>)
 8007bd6:	fb28 ee07 	smlad	lr, r8, r7, lr
 8007bda:	4f4a      	ldr	r7, [pc, #296]	; (8007d04 <D128_GENERIC+0x3c4>)
 8007bdc:	fb20 ee07 	smlad	lr, r0, r7, lr
 8007be0:	4f49      	ldr	r7, [pc, #292]	; (8007d08 <D128_GENERIC+0x3c8>)
 8007be2:	fb23 e707 	smlad	r7, r3, r7, lr
 8007be6:	f8df e144 	ldr.w	lr, [pc, #324]	; 8007d2c <D128_GENERIC+0x3ec>
 8007bea:	fb25 720e 	smlad	r2, r5, lr, r7
 8007bee:	f04f 0b01 	mov.w	fp, #1
 8007bf2:	9203      	str	r2, [sp, #12]
 8007bf4:	fb2c fb0b 	smuad	fp, ip, fp
 8007bf8:	4f44      	ldr	r7, [pc, #272]	; (8007d0c <D128_GENERIC+0x3cc>)
 8007bfa:	fb2a ba07 	smlad	sl, sl, r7, fp
 8007bfe:	4f44      	ldr	r7, [pc, #272]	; (8007d10 <D128_GENERIC+0x3d0>)
 8007c00:	fb21 aa07 	smlad	sl, r1, r7, sl
 8007c04:	4f43      	ldr	r7, [pc, #268]	; (8007d14 <D128_GENERIC+0x3d4>)
 8007c06:	fb24 aa07 	smlad	sl, r4, r7, sl
 8007c0a:	4f43      	ldr	r7, [pc, #268]	; (8007d18 <D128_GENERIC+0x3d8>)
 8007c0c:	fb28 a707 	smlad	r7, r8, r7, sl
 8007c10:	4a42      	ldr	r2, [pc, #264]	; (8007d1c <D128_GENERIC+0x3dc>)
 8007c12:	fb20 7702 	smlad	r7, r0, r2, r7
 8007c16:	4a42      	ldr	r2, [pc, #264]	; (8007d20 <D128_GENERIC+0x3e0>)
 8007c18:	fb23 7702 	smlad	r7, r3, r2, r7
 8007c1c:	4b41      	ldr	r3, [pc, #260]	; (8007d24 <D128_GENERIC+0x3e4>)
 8007c1e:	fb25 7303 	smlad	r3, r5, r3, r7
 8007c22:	9d10      	ldr	r5, [sp, #64]	; 0x40
 8007c24:	9304      	str	r3, [sp, #16]
 8007c26:	f5a6 1680 	sub.w	r6, r6, #1048576	; 0x100000
 8007c2a:	b185      	cbz	r5, 8007c4e <D128_GENERIC+0x30e>
 8007c2c:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8007c2e:	990d      	ldr	r1, [sp, #52]	; 0x34
 8007c30:	960d      	str	r6, [sp, #52]	; 0x34
 8007c32:	4432      	add	r2, r6
 8007c34:	1a52      	subs	r2, r2, r1
 8007c36:	17d1      	asrs	r1, r2, #31
 8007c38:	fba2 2305 	umull	r2, r3, r2, r5
 8007c3c:	fb05 3301 	mla	r3, r5, r1, r3
 8007c40:	f112 4200 	adds.w	r2, r2, #2147483648	; 0x80000000
 8007c44:	f143 0300 	adc.w	r3, r3, #0
 8007c48:	005b      	lsls	r3, r3, #1
 8007c4a:	930c      	str	r3, [sp, #48]	; 0x30
 8007c4c:	461e      	mov	r6, r3
 8007c4e:	9801      	ldr	r0, [sp, #4]
 8007c50:	9c06      	ldr	r4, [sp, #24]
 8007c52:	8d01      	ldrh	r1, [r0, #40]	; 0x28
 8007c54:	9d0e      	ldr	r5, [sp, #56]	; 0x38
 8007c56:	01f6      	lsls	r6, r6, #7
 8007c58:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
 8007c5c:	2300      	movs	r3, #0
 8007c5e:	fbc5 2306 	smlal	r2, r3, r5, r6
 8007c62:	fb04 f101 	mul.w	r1, r4, r1
 8007c66:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8007c68:	109b      	asrs	r3, r3, #2
 8007c6a:	f303 030f 	ssat	r3, #16, r3
 8007c6e:	f822 3011 	strh.w	r3, [r2, r1, lsl #1]
 8007c72:	8cc3      	ldrh	r3, [r0, #38]	; 0x26
 8007c74:	1c62      	adds	r2, r4, #1
 8007c76:	4293      	cmp	r3, r2
 8007c78:	9206      	str	r2, [sp, #24]
 8007c7a:	dd18      	ble.n	8007cae <D128_GENERIC+0x36e>
 8007c7c:	9b01      	ldr	r3, [sp, #4]
 8007c7e:	8d5a      	ldrh	r2, [r3, #42]	; 0x2a
 8007c80:	2a01      	cmp	r2, #1
 8007c82:	f47f ae80 	bne.w	8007986 <D128_GENERIC+0x46>
 8007c86:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8007c88:	9d05      	ldr	r5, [sp, #20]
 8007c8a:	069b      	lsls	r3, r3, #26
 8007c8c:	6829      	ldr	r1, [r5, #0]
 8007c8e:	686a      	ldr	r2, [r5, #4]
 8007c90:	68a8      	ldr	r0, [r5, #8]
 8007c92:	f8d5 a00c 	ldr.w	sl, [r5, #12]
 8007c96:	f105 0410 	add.w	r4, r5, #16
 8007c9a:	d506      	bpl.n	8007caa <D128_GENERIC+0x36a>
 8007c9c:	ba49      	rev16	r1, r1
 8007c9e:	ba52      	rev16	r2, r2
 8007ca0:	ba40      	rev16	r0, r0
 8007ca2:	fa9a fa9a 	rev16.w	sl, sl
 8007ca6:	9405      	str	r4, [sp, #20]
 8007ca8:	e6cf      	b.n	8007a4a <D128_GENERIC+0x10a>
 8007caa:	9405      	str	r4, [sp, #20]
 8007cac:	e6cd      	b.n	8007a4a <D128_GENERIC+0x10a>
 8007cae:	9a01      	ldr	r2, [sp, #4]
 8007cb0:	9904      	ldr	r1, [sp, #16]
 8007cb2:	6091      	str	r1, [r2, #8]
 8007cb4:	9903      	ldr	r1, [sp, #12]
 8007cb6:	60d1      	str	r1, [r2, #12]
 8007cb8:	9b02      	ldr	r3, [sp, #8]
 8007cba:	61d3      	str	r3, [r2, #28]
 8007cbc:	4611      	mov	r1, r2
 8007cbe:	4613      	mov	r3, r2
 8007cc0:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8007cc2:	610a      	str	r2, [r1, #16]
 8007cc4:	990d      	ldr	r1, [sp, #52]	; 0x34
 8007cc6:	6159      	str	r1, [r3, #20]
 8007cc8:	9911      	ldr	r1, [sp, #68]	; 0x44
 8007cca:	6199      	str	r1, [r3, #24]
 8007ccc:	2000      	movs	r0, #0
 8007cce:	b013      	add	sp, #76	; 0x4c
 8007cd0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8007cd4:	00780069 	.word	0x00780069
 8007cd8:	005b004e 	.word	0x005b004e
 8007cdc:	00420037 	.word	0x00420037
 8007ce0:	002d0024 	.word	0x002d0024
 8007ce4:	001c0015 	.word	0x001c0015
 8007ce8:	000f000a 	.word	0x000f000a
 8007cec:	00060003 	.word	0x00060003
 8007cf0:	00880096 	.word	0x00880096
 8007cf4:	00a200ac 	.word	0x00a200ac
 8007cf8:	00b400ba 	.word	0x00b400ba
 8007cfc:	00be00c0 	.word	0x00be00c0
 8007d00:	00c000be 	.word	0x00c000be
 8007d04:	00ba00b4 	.word	0x00ba00b4
 8007d08:	00ac00a2 	.word	0x00ac00a2
 8007d0c:	00030006 	.word	0x00030006
 8007d10:	000a000f 	.word	0x000a000f
 8007d14:	0015001c 	.word	0x0015001c
 8007d18:	0024002d 	.word	0x0024002d
 8007d1c:	00370042 	.word	0x00370042
 8007d20:	004e005b 	.word	0x004e005b
 8007d24:	00690078 	.word	0x00690078
 8007d28:	200000c8 	.word	0x200000c8
 8007d2c:	00960088 	.word	0x00960088

08007d30 <D16_1CH_HTONS_VOL_HP>:
 8007d30:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8007d34:	4691      	mov	r9, r2
 8007d36:	b083      	sub	sp, #12
 8007d38:	8cd2      	ldrh	r2, [r2, #38]	; 0x26
 8007d3a:	f8d9 3018 	ldr.w	r3, [r9, #24]
 8007d3e:	f8d9 400c 	ldr.w	r4, [r9, #12]
 8007d42:	9300      	str	r3, [sp, #0]
 8007d44:	4680      	mov	r8, r0
 8007d46:	f8d9 7014 	ldr.w	r7, [r9, #20]
 8007d4a:	f8d9 0010 	ldr.w	r0, [r9, #16]
 8007d4e:	f8d9 301c 	ldr.w	r3, [r9, #28]
 8007d52:	f8d9 5008 	ldr.w	r5, [r9, #8]
 8007d56:	9401      	str	r4, [sp, #4]
 8007d58:	f8d9 a030 	ldr.w	sl, [r9, #48]	; 0x30
 8007d5c:	f8d9 e020 	ldr.w	lr, [r9, #32]
 8007d60:	2a00      	cmp	r2, #0
 8007d62:	d04e      	beq.n	8007e02 <D16_1CH_HTONS_VOL_HP+0xd2>
 8007d64:	f8df c0a8 	ldr.w	ip, [pc, #168]	; 8007e10 <D16_1CH_HTONS_VOL_HP+0xe0>
 8007d68:	1e8c      	subs	r4, r1, #2
 8007d6a:	eb08 0b42 	add.w	fp, r8, r2, lsl #1
 8007d6e:	f858 2b02 	ldr.w	r2, [r8], #2
 8007d72:	ba52      	rev16	r2, r2
 8007d74:	b2d6      	uxtb	r6, r2
 8007d76:	f3c2 2107 	ubfx	r1, r2, #8, #8
 8007d7a:	f85c 2026 	ldr.w	r2, [ip, r6, lsl #2]
 8007d7e:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
 8007d82:	4413      	add	r3, r2
 8007d84:	eb01 2293 	add.w	r2, r1, r3, lsr #10
 8007d88:	f3c2 0109 	ubfx	r1, r2, #0, #10
 8007d8c:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8007d90:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 8007d94:	0a93      	lsrs	r3, r2, #10
 8007d96:	4a1c      	ldr	r2, [pc, #112]	; (8007e08 <D16_1CH_HTONS_VOL_HP+0xd8>)
 8007d98:	fb21 5202 	smlad	r2, r1, r2, r5
 8007d9c:	4d1b      	ldr	r5, [pc, #108]	; (8007e0c <D16_1CH_HTONS_VOL_HP+0xdc>)
 8007d9e:	fb21 f505 	smuad	r5, r1, r5
 8007da2:	f5a2 6200 	sub.w	r2, r2, #2048	; 0x800
 8007da6:	4410      	add	r0, r2
 8007da8:	1bc0      	subs	r0, r0, r7
 8007daa:	17c7      	asrs	r7, r0, #31
 8007dac:	fba0 010e 	umull	r0, r1, r0, lr
 8007db0:	f110 4000 	adds.w	r0, r0, #2147483648	; 0x80000000
 8007db4:	fb0e 1107 	mla	r1, lr, r7, r1
 8007db8:	f141 0100 	adc.w	r1, r1, #0
 8007dbc:	0448      	lsls	r0, r1, #17
 8007dbe:	f04f 4600 	mov.w	r6, #2147483648	; 0x80000000
 8007dc2:	2700      	movs	r7, #0
 8007dc4:	fbc0 670a 	smlal	r6, r7, r0, sl
 8007dc8:	45d8      	cmp	r8, fp
 8007dca:	ea4f 0041 	mov.w	r0, r1, lsl #1
 8007dce:	ea4f 01a7 	mov.w	r1, r7, asr #2
 8007dd2:	4617      	mov	r7, r2
 8007dd4:	f301 010f 	ssat	r1, #16, r1
 8007dd8:	f824 1f02 	strh.w	r1, [r4, #2]!
 8007ddc:	d1c7      	bne.n	8007d6e <D16_1CH_HTONS_VOL_HP+0x3e>
 8007dde:	9901      	ldr	r1, [sp, #4]
 8007de0:	f8c9 301c 	str.w	r3, [r9, #28]
 8007de4:	9b00      	ldr	r3, [sp, #0]
 8007de6:	f8c9 0010 	str.w	r0, [r9, #16]
 8007dea:	2000      	movs	r0, #0
 8007dec:	f8c9 5008 	str.w	r5, [r9, #8]
 8007df0:	f8c9 100c 	str.w	r1, [r9, #12]
 8007df4:	f8c9 2014 	str.w	r2, [r9, #20]
 8007df8:	f8c9 3018 	str.w	r3, [r9, #24]
 8007dfc:	b003      	add	sp, #12
 8007dfe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8007e02:	463a      	mov	r2, r7
 8007e04:	4621      	mov	r1, r4
 8007e06:	e7eb      	b.n	8007de0 <D16_1CH_HTONS_VOL_HP+0xb0>
 8007e08:	00030001 	.word	0x00030001
 8007e0c:	00010003 	.word	0x00010003
 8007e10:	200000c8 	.word	0x200000c8

08007e14 <D24_1CH_HTONS_VOL_HP>:
 8007e14:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8007e18:	b089      	sub	sp, #36	; 0x24
 8007e1a:	8cd3      	ldrh	r3, [r2, #38]	; 0x26
 8007e1c:	6996      	ldr	r6, [r2, #24]
 8007e1e:	9304      	str	r3, [sp, #16]
 8007e20:	6b17      	ldr	r7, [r2, #48]	; 0x30
 8007e22:	9207      	str	r2, [sp, #28]
 8007e24:	6915      	ldr	r5, [r2, #16]
 8007e26:	6954      	ldr	r4, [r2, #20]
 8007e28:	9606      	str	r6, [sp, #24]
 8007e2a:	6893      	ldr	r3, [r2, #8]
 8007e2c:	69d6      	ldr	r6, [r2, #28]
 8007e2e:	f8d2 c00c 	ldr.w	ip, [r2, #12]
 8007e32:	f8d2 a020 	ldr.w	sl, [r2, #32]
 8007e36:	9a04      	ldr	r2, [sp, #16]
 8007e38:	9705      	str	r7, [sp, #20]
 8007e3a:	2a00      	cmp	r2, #0
 8007e3c:	d07e      	beq.n	8007f3c <D24_1CH_HTONS_VOL_HP+0x128>
 8007e3e:	f1a1 0b02 	sub.w	fp, r1, #2
 8007e42:	2700      	movs	r7, #0
 8007e44:	46a8      	mov	r8, r5
 8007e46:	f8cd b004 	str.w	fp, [sp, #4]
 8007e4a:	4655      	mov	r5, sl
 8007e4c:	46e3      	mov	fp, ip
 8007e4e:	f8df e0f8 	ldr.w	lr, [pc, #248]	; 8007f48 <D24_1CH_HTONS_VOL_HP+0x134>
 8007e52:	46ba      	mov	sl, r7
 8007e54:	469c      	mov	ip, r3
 8007e56:	e055      	b.n	8007f04 <D24_1CH_HTONS_VOL_HP+0xf0>
 8007e58:	7802      	ldrb	r2, [r0, #0]
 8007e5a:	78c3      	ldrb	r3, [r0, #3]
 8007e5c:	7841      	ldrb	r1, [r0, #1]
 8007e5e:	0212      	lsls	r2, r2, #8
 8007e60:	eb02 4303 	add.w	r3, r2, r3, lsl #16
 8007e64:	440b      	add	r3, r1
 8007e66:	3002      	adds	r0, #2
 8007e68:	b2d9      	uxtb	r1, r3
 8007e6a:	f3c3 2207 	ubfx	r2, r3, #8, #8
 8007e6e:	f85e 7021 	ldr.w	r7, [lr, r1, lsl #2]
 8007e72:	f85e 2022 	ldr.w	r2, [lr, r2, lsl #2]
 8007e76:	0c1b      	lsrs	r3, r3, #16
 8007e78:	eb07 2796 	add.w	r7, r7, r6, lsr #10
 8007e7c:	eb02 2297 	add.w	r2, r2, r7, lsr #10
 8007e80:	f85e 6023 	ldr.w	r6, [lr, r3, lsl #2]
 8007e84:	f3c7 0309 	ubfx	r3, r7, #0, #10
 8007e88:	f3c2 0709 	ubfx	r7, r2, #0, #10
 8007e8c:	eb06 2692 	add.w	r6, r6, r2, lsr #10
 8007e90:	ea47 4303 	orr.w	r3, r7, r3, lsl #16
 8007e94:	4a2a      	ldr	r2, [pc, #168]	; (8007f40 <D24_1CH_HTONS_VOL_HP+0x12c>)
 8007e96:	fb23 b102 	smlad	r1, r3, r2, fp
 8007e9a:	4a2a      	ldr	r2, [pc, #168]	; (8007f44 <D24_1CH_HTONS_VOL_HP+0x130>)
 8007e9c:	fb23 cb02 	smlad	fp, r3, r2, ip
 8007ea0:	f3c6 0c09 	ubfx	ip, r6, #0, #10
 8007ea4:	eb0c 0c4c 	add.w	ip, ip, ip, lsl #1
 8007ea8:	eb0b 0b4c 	add.w	fp, fp, ip, lsl #1
 8007eac:	2201      	movs	r2, #1
 8007eae:	fb23 f702 	smuad	r7, r3, r2
 8007eb2:	f5a1 51d8 	sub.w	r1, r1, #6912	; 0x1b00
 8007eb6:	eb01 0208 	add.w	r2, r1, r8
 8007eba:	1b12      	subs	r2, r2, r4
 8007ebc:	17d4      	asrs	r4, r2, #31
 8007ebe:	fba2 2305 	umull	r2, r3, r2, r5
 8007ec2:	f112 4200 	adds.w	r2, r2, #2147483648	; 0x80000000
 8007ec6:	fb05 3304 	mla	r3, r5, r4, r3
 8007eca:	f143 0300 	adc.w	r3, r3, #0
 8007ece:	9c05      	ldr	r4, [sp, #20]
 8007ed0:	03da      	lsls	r2, r3, #15
 8007ed2:	f04f 4800 	mov.w	r8, #2147483648	; 0x80000000
 8007ed6:	f04f 0900 	mov.w	r9, #0
 8007eda:	fbc4 8902 	smlal	r8, r9, r4, r2
 8007ede:	e9cd 8902 	strd	r8, r9, [sp, #8]
 8007ee2:	9a01      	ldr	r2, [sp, #4]
 8007ee4:	ea4f 0843 	mov.w	r8, r3, lsl #1
 8007ee8:	9b03      	ldr	r3, [sp, #12]
 8007eea:	109b      	asrs	r3, r3, #2
 8007eec:	f303 030f 	ssat	r3, #16, r3
 8007ef0:	f822 3f02 	strh.w	r3, [r2, #2]!
 8007ef4:	9b04      	ldr	r3, [sp, #16]
 8007ef6:	9201      	str	r2, [sp, #4]
 8007ef8:	f10a 0a01 	add.w	sl, sl, #1
 8007efc:	459a      	cmp	sl, r3
 8007efe:	44bc      	add	ip, r7
 8007f00:	460c      	mov	r4, r1
 8007f02:	d00b      	beq.n	8007f1c <D24_1CH_HTONS_VOL_HP+0x108>
 8007f04:	f01a 0f01 	tst.w	sl, #1
 8007f08:	d0a6      	beq.n	8007e58 <D24_1CH_HTONS_VOL_HP+0x44>
 8007f0a:	78c2      	ldrb	r2, [r0, #3]
 8007f0c:	7883      	ldrb	r3, [r0, #2]
 8007f0e:	f810 1b04 	ldrb.w	r1, [r0], #4
 8007f12:	0212      	lsls	r2, r2, #8
 8007f14:	eb02 4303 	add.w	r3, r2, r3, lsl #16
 8007f18:	440b      	add	r3, r1
 8007f1a:	e7a5      	b.n	8007e68 <D24_1CH_HTONS_VOL_HP+0x54>
 8007f1c:	4663      	mov	r3, ip
 8007f1e:	4645      	mov	r5, r8
 8007f20:	46dc      	mov	ip, fp
 8007f22:	9807      	ldr	r0, [sp, #28]
 8007f24:	6141      	str	r1, [r0, #20]
 8007f26:	9906      	ldr	r1, [sp, #24]
 8007f28:	6083      	str	r3, [r0, #8]
 8007f2a:	f8c0 c00c 	str.w	ip, [r0, #12]
 8007f2e:	61c6      	str	r6, [r0, #28]
 8007f30:	6105      	str	r5, [r0, #16]
 8007f32:	6181      	str	r1, [r0, #24]
 8007f34:	2000      	movs	r0, #0
 8007f36:	b009      	add	sp, #36	; 0x24
 8007f38:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8007f3c:	4621      	mov	r1, r4
 8007f3e:	e7f0      	b.n	8007f22 <D24_1CH_HTONS_VOL_HP+0x10e>
 8007f40:	00030001 	.word	0x00030001
 8007f44:	00060007 	.word	0x00060007
 8007f48:	200000c8 	.word	0x200000c8

08007f4c <D32_1CH_HTONS_VOL_HP>:
 8007f4c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8007f50:	4692      	mov	sl, r2
 8007f52:	b087      	sub	sp, #28
 8007f54:	8cd2      	ldrh	r2, [r2, #38]	; 0x26
 8007f56:	f8da 3018 	ldr.w	r3, [sl, #24]
 8007f5a:	f8da 5030 	ldr.w	r5, [sl, #48]	; 0x30
 8007f5e:	9304      	str	r3, [sp, #16]
 8007f60:	f8da 4010 	ldr.w	r4, [sl, #16]
 8007f64:	f8da 8014 	ldr.w	r8, [sl, #20]
 8007f68:	f8da 601c 	ldr.w	r6, [sl, #28]
 8007f6c:	f8da 3008 	ldr.w	r3, [sl, #8]
 8007f70:	f8da e00c 	ldr.w	lr, [sl, #12]
 8007f74:	9501      	str	r5, [sp, #4]
 8007f76:	f8da c020 	ldr.w	ip, [sl, #32]
 8007f7a:	2a00      	cmp	r2, #0
 8007f7c:	d07b      	beq.n	8008076 <D32_1CH_HTONS_VOL_HP+0x12a>
 8007f7e:	eb01 0242 	add.w	r2, r1, r2, lsl #1
 8007f82:	4f3e      	ldr	r7, [pc, #248]	; (800807c <D32_1CH_HTONS_VOL_HP+0x130>)
 8007f84:	f8cd c00c 	str.w	ip, [sp, #12]
 8007f88:	9202      	str	r2, [sp, #8]
 8007f8a:	460d      	mov	r5, r1
 8007f8c:	46a1      	mov	r9, r4
 8007f8e:	4684      	mov	ip, r0
 8007f90:	f8cd a014 	str.w	sl, [sp, #20]
 8007f94:	f85c 1b04 	ldr.w	r1, [ip], #4
 8007f98:	ba49      	rev16	r1, r1
 8007f9a:	b2c8      	uxtb	r0, r1
 8007f9c:	f3c1 2207 	ubfx	r2, r1, #8, #8
 8007fa0:	f3c1 4a07 	ubfx	sl, r1, #16, #8
 8007fa4:	f857 0020 	ldr.w	r0, [r7, r0, lsl #2]
 8007fa8:	f857 2022 	ldr.w	r2, [r7, r2, lsl #2]
 8007fac:	0e09      	lsrs	r1, r1, #24
 8007fae:	eb00 2096 	add.w	r0, r0, r6, lsr #10
 8007fb2:	f857 602a 	ldr.w	r6, [r7, sl, lsl #2]
 8007fb6:	f857 1021 	ldr.w	r1, [r7, r1, lsl #2]
 8007fba:	eb02 2290 	add.w	r2, r2, r0, lsr #10
 8007fbe:	eb06 2a92 	add.w	sl, r6, r2, lsr #10
 8007fc2:	eb01 269a 	add.w	r6, r1, sl, lsr #10
 8007fc6:	f3c2 0209 	ubfx	r2, r2, #0, #10
 8007fca:	f3c6 0109 	ubfx	r1, r6, #0, #10
 8007fce:	f3c0 0009 	ubfx	r0, r0, #0, #10
 8007fd2:	f3ca 0a09 	ubfx	sl, sl, #0, #10
 8007fd6:	ea42 4000 	orr.w	r0, r2, r0, lsl #16
 8007fda:	ea41 4a0a 	orr.w	sl, r1, sl, lsl #16
 8007fde:	4a28      	ldr	r2, [pc, #160]	; (8008080 <D32_1CH_HTONS_VOL_HP+0x134>)
 8007fe0:	fb20 e202 	smlad	r2, r0, r2, lr
 8007fe4:	f44f 3180 	mov.w	r1, #65536	; 0x10000
 8007fe8:	fb2a 2101 	smlad	r1, sl, r1, r2
 8007fec:	4a25      	ldr	r2, [pc, #148]	; (8008084 <D32_1CH_HTONS_VOL_HP+0x138>)
 8007fee:	fb20 3302 	smlad	r3, r0, r2, r3
 8007ff2:	4a25      	ldr	r2, [pc, #148]	; (8008088 <D32_1CH_HTONS_VOL_HP+0x13c>)
 8007ff4:	fb2a 3e02 	smlad	lr, sl, r2, r3
 8007ff8:	2301      	movs	r3, #1
 8007ffa:	fb20 f003 	smuad	r0, r0, r3
 8007ffe:	4b23      	ldr	r3, [pc, #140]	; (800808c <D32_1CH_HTONS_VOL_HP+0x140>)
 8008000:	fb2a 0303 	smlad	r3, sl, r3, r0
 8008004:	f5a1 4280 	sub.w	r2, r1, #16384	; 0x4000
 8008008:	9c03      	ldr	r4, [sp, #12]
 800800a:	eb02 0009 	add.w	r0, r2, r9
 800800e:	eba0 0008 	sub.w	r0, r0, r8
 8008012:	ea4f 7be0 	mov.w	fp, r0, asr #31
 8008016:	fba0 0104 	umull	r0, r1, r0, r4
 800801a:	f110 4000 	adds.w	r0, r0, #2147483648	; 0x80000000
 800801e:	fb04 110b 	mla	r1, r4, fp, r1
 8008022:	f141 0100 	adc.w	r1, r1, #0
 8008026:	9c01      	ldr	r4, [sp, #4]
 8008028:	0388      	lsls	r0, r1, #14
 800802a:	f04f 4800 	mov.w	r8, #2147483648	; 0x80000000
 800802e:	f04f 0900 	mov.w	r9, #0
 8008032:	fbc0 8904 	smlal	r8, r9, r0, r4
 8008036:	ea4f 00a9 	mov.w	r0, r9, asr #2
 800803a:	ea4f 0941 	mov.w	r9, r1, lsl #1
 800803e:	f300 000f 	ssat	r0, #16, r0
 8008042:	9902      	ldr	r1, [sp, #8]
 8008044:	f825 0b02 	strh.w	r0, [r5], #2
 8008048:	428d      	cmp	r5, r1
 800804a:	4690      	mov	r8, r2
 800804c:	d1a2      	bne.n	8007f94 <D32_1CH_HTONS_VOL_HP+0x48>
 800804e:	f8dd a014 	ldr.w	sl, [sp, #20]
 8008052:	464c      	mov	r4, r9
 8008054:	f8ca 3008 	str.w	r3, [sl, #8]
 8008058:	9b04      	ldr	r3, [sp, #16]
 800805a:	f8ca e00c 	str.w	lr, [sl, #12]
 800805e:	2000      	movs	r0, #0
 8008060:	f8ca 601c 	str.w	r6, [sl, #28]
 8008064:	f8ca 4010 	str.w	r4, [sl, #16]
 8008068:	f8ca 2014 	str.w	r2, [sl, #20]
 800806c:	f8ca 3018 	str.w	r3, [sl, #24]
 8008070:	b007      	add	sp, #28
 8008072:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8008076:	4642      	mov	r2, r8
 8008078:	e7ec      	b.n	8008054 <D32_1CH_HTONS_VOL_HP+0x108>
 800807a:	bf00      	nop
 800807c:	200000c8 	.word	0x200000c8
 8008080:	00060003 	.word	0x00060003
 8008084:	000a000c 	.word	0x000a000c
 8008088:	000c000a 	.word	0x000c000a
 800808c:	00030006 	.word	0x00030006

08008090 <D48_1CH_HTONS_VOL_HP>:
 8008090:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8008094:	4613      	mov	r3, r2
 8008096:	461c      	mov	r4, r3
 8008098:	b087      	sub	sp, #28
 800809a:	4625      	mov	r5, r4
 800809c:	4626      	mov	r6, r4
 800809e:	6b2d      	ldr	r5, [r5, #48]	; 0x30
 80080a0:	9205      	str	r2, [sp, #20]
 80080a2:	8cd2      	ldrh	r2, [r2, #38]	; 0x26
 80080a4:	f8d3 9014 	ldr.w	r9, [r3, #20]
 80080a8:	9501      	str	r5, [sp, #4]
 80080aa:	4680      	mov	r8, r0
 80080ac:	6a35      	ldr	r5, [r6, #32]
 80080ae:	6918      	ldr	r0, [r3, #16]
 80080b0:	699b      	ldr	r3, [r3, #24]
 80080b2:	9304      	str	r3, [sp, #16]
 80080b4:	f8d4 e01c 	ldr.w	lr, [r4, #28]
 80080b8:	68a3      	ldr	r3, [r4, #8]
 80080ba:	9502      	str	r5, [sp, #8]
 80080bc:	68e4      	ldr	r4, [r4, #12]
 80080be:	2a00      	cmp	r2, #0
 80080c0:	f000 808c 	beq.w	80081dc <D48_1CH_HTONS_VOL_HP+0x14c>
 80080c4:	eb01 0242 	add.w	r2, r1, r2, lsl #1
 80080c8:	4d45      	ldr	r5, [pc, #276]	; (80081e0 <D48_1CH_HTONS_VOL_HP+0x150>)
 80080ca:	9203      	str	r2, [sp, #12]
 80080cc:	468c      	mov	ip, r1
 80080ce:	e898 0044 	ldmia.w	r8, {r2, r6}
 80080d2:	f108 0806 	add.w	r8, r8, #6
 80080d6:	ba52      	rev16	r2, r2
 80080d8:	ba76      	rev16	r6, r6
 80080da:	b2d7      	uxtb	r7, r2
 80080dc:	f3c2 2107 	ubfx	r1, r2, #8, #8
 80080e0:	f855 a027 	ldr.w	sl, [r5, r7, lsl #2]
 80080e4:	f855 1021 	ldr.w	r1, [r5, r1, lsl #2]
 80080e8:	f3c2 4707 	ubfx	r7, r2, #16, #8
 80080ec:	0e12      	lsrs	r2, r2, #24
 80080ee:	eb0a 2a9e 	add.w	sl, sl, lr, lsr #10
 80080f2:	f855 7027 	ldr.w	r7, [r5, r7, lsl #2]
 80080f6:	f855 2022 	ldr.w	r2, [r5, r2, lsl #2]
 80080fa:	fa5f fb86 	uxtb.w	fp, r6
 80080fe:	eb01 219a 	add.w	r1, r1, sl, lsr #10
 8008102:	f3c6 2e07 	ubfx	lr, r6, #8, #8
 8008106:	eb07 2791 	add.w	r7, r7, r1, lsr #10
 800810a:	f855 602b 	ldr.w	r6, [r5, fp, lsl #2]
 800810e:	f855 e02e 	ldr.w	lr, [r5, lr, lsl #2]
 8008112:	eb02 2297 	add.w	r2, r2, r7, lsr #10
 8008116:	eb06 2692 	add.w	r6, r6, r2, lsr #10
 800811a:	eb0e 2e96 	add.w	lr, lr, r6, lsr #10
 800811e:	f3c1 0109 	ubfx	r1, r1, #0, #10
 8008122:	f3c2 0209 	ubfx	r2, r2, #0, #10
 8008126:	f3ce 0b09 	ubfx	fp, lr, #0, #10
 800812a:	f3ca 0a09 	ubfx	sl, sl, #0, #10
 800812e:	f3c7 0709 	ubfx	r7, r7, #0, #10
 8008132:	f3c6 0609 	ubfx	r6, r6, #0, #10
 8008136:	ea42 4707 	orr.w	r7, r2, r7, lsl #16
 800813a:	ea41 4a0a 	orr.w	sl, r1, sl, lsl #16
 800813e:	ea4b 4606 	orr.w	r6, fp, r6, lsl #16
 8008142:	4a28      	ldr	r2, [pc, #160]	; (80081e4 <D48_1CH_HTONS_VOL_HP+0x154>)
 8008144:	fb2a 4202 	smlad	r2, sl, r2, r4
 8008148:	4927      	ldr	r1, [pc, #156]	; (80081e8 <D48_1CH_HTONS_VOL_HP+0x158>)
 800814a:	fb27 2201 	smlad	r2, r7, r1, r2
 800814e:	f44f 3180 	mov.w	r1, #65536	; 0x10000
 8008152:	fb26 2201 	smlad	r2, r6, r1, r2
 8008156:	4925      	ldr	r1, [pc, #148]	; (80081ec <D48_1CH_HTONS_VOL_HP+0x15c>)
 8008158:	fb2a 3401 	smlad	r4, sl, r1, r3
 800815c:	f04f 131b 	mov.w	r3, #1769499	; 0x1b001b
 8008160:	fb27 4403 	smlad	r4, r7, r3, r4
 8008164:	4b22      	ldr	r3, [pc, #136]	; (80081f0 <D48_1CH_HTONS_VOL_HP+0x160>)
 8008166:	fb26 4403 	smlad	r4, r6, r3, r4
 800816a:	2101      	movs	r1, #1
 800816c:	fb2a fa01 	smuad	sl, sl, r1
 8008170:	4b20      	ldr	r3, [pc, #128]	; (80081f4 <D48_1CH_HTONS_VOL_HP+0x164>)
 8008172:	fb27 a703 	smlad	r7, r7, r3, sl
 8008176:	4b20      	ldr	r3, [pc, #128]	; (80081f8 <D48_1CH_HTONS_VOL_HP+0x168>)
 8008178:	fb26 7303 	smlad	r3, r6, r3, r7
 800817c:	f5a2 4258 	sub.w	r2, r2, #55296	; 0xd800
 8008180:	9e02      	ldr	r6, [sp, #8]
 8008182:	9f01      	ldr	r7, [sp, #4]
 8008184:	4410      	add	r0, r2
 8008186:	eba0 0009 	sub.w	r0, r0, r9
 800818a:	ea4f 7ae0 	mov.w	sl, r0, asr #31
 800818e:	fba0 0106 	umull	r0, r1, r0, r6
 8008192:	f110 4000 	adds.w	r0, r0, #2147483648	; 0x80000000
 8008196:	fb06 110a 	mla	r1, r6, sl, r1
 800819a:	f141 0100 	adc.w	r1, r1, #0
 800819e:	0308      	lsls	r0, r1, #12
 80081a0:	f04f 4900 	mov.w	r9, #2147483648	; 0x80000000
 80081a4:	f04f 0a00 	mov.w	sl, #0
 80081a8:	fbc0 9a07 	smlal	r9, sl, r0, r7
 80081ac:	4657      	mov	r7, sl
 80081ae:	10b8      	asrs	r0, r7, #2
 80081b0:	f300 000f 	ssat	r0, #16, r0
 80081b4:	f82c 0b02 	strh.w	r0, [ip], #2
 80081b8:	0048      	lsls	r0, r1, #1
 80081ba:	9903      	ldr	r1, [sp, #12]
 80081bc:	458c      	cmp	ip, r1
 80081be:	4691      	mov	r9, r2
 80081c0:	d185      	bne.n	80080ce <D48_1CH_HTONS_VOL_HP+0x3e>
 80081c2:	9d05      	ldr	r5, [sp, #20]
 80081c4:	616a      	str	r2, [r5, #20]
 80081c6:	9a04      	ldr	r2, [sp, #16]
 80081c8:	6128      	str	r0, [r5, #16]
 80081ca:	2000      	movs	r0, #0
 80081cc:	60ab      	str	r3, [r5, #8]
 80081ce:	60ec      	str	r4, [r5, #12]
 80081d0:	f8c5 e01c 	str.w	lr, [r5, #28]
 80081d4:	61aa      	str	r2, [r5, #24]
 80081d6:	b007      	add	sp, #28
 80081d8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80081dc:	464a      	mov	r2, r9
 80081de:	e7f0      	b.n	80081c2 <D48_1CH_HTONS_VOL_HP+0x132>
 80081e0:	200000c8 	.word	0x200000c8
 80081e4:	000f000a 	.word	0x000f000a
 80081e8:	00060003 	.word	0x00060003
 80081ec:	00150019 	.word	0x00150019
 80081f0:	00190015 	.word	0x00190015
 80081f4:	00030006 	.word	0x00030006
 80081f8:	000a000f 	.word	0x000a000f

080081fc <D64_1CH_HTONS_VOL_HP>:
 80081fc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8008200:	b089      	sub	sp, #36	; 0x24
 8008202:	4614      	mov	r4, r2
 8008204:	9207      	str	r2, [sp, #28]
 8008206:	8cd3      	ldrh	r3, [r2, #38]	; 0x26
 8008208:	f8d2 c010 	ldr.w	ip, [r2, #16]
 800820c:	f8d2 8014 	ldr.w	r8, [r2, #20]
 8008210:	6992      	ldr	r2, [r2, #24]
 8008212:	9206      	str	r2, [sp, #24]
 8008214:	68e2      	ldr	r2, [r4, #12]
 8008216:	9201      	str	r2, [sp, #4]
 8008218:	6b22      	ldr	r2, [r4, #48]	; 0x30
 800821a:	9203      	str	r2, [sp, #12]
 800821c:	6a22      	ldr	r2, [r4, #32]
 800821e:	69e5      	ldr	r5, [r4, #28]
 8008220:	68a6      	ldr	r6, [r4, #8]
 8008222:	9204      	str	r2, [sp, #16]
 8008224:	2b00      	cmp	r3, #0
 8008226:	f000 80b0 	beq.w	800838a <D64_1CH_HTONS_VOL_HP+0x18e>
 800822a:	eb01 0343 	add.w	r3, r1, r3, lsl #1
 800822e:	4f58      	ldr	r7, [pc, #352]	; (8008390 <D64_1CH_HTONS_VOL_HP+0x194>)
 8008230:	9305      	str	r3, [sp, #20]
 8008232:	9102      	str	r1, [sp, #8]
 8008234:	f850 2b08 	ldr.w	r2, [r0], #8
 8008238:	f850 3c04 	ldr.w	r3, [r0, #-4]
 800823c:	ba52      	rev16	r2, r2
 800823e:	fa93 f993 	rev16.w	r9, r3
 8008242:	b2d4      	uxtb	r4, r2
 8008244:	f3c2 2307 	ubfx	r3, r2, #8, #8
 8008248:	f857 b024 	ldr.w	fp, [r7, r4, lsl #2]
 800824c:	f857 3023 	ldr.w	r3, [r7, r3, lsl #2]
 8008250:	9901      	ldr	r1, [sp, #4]
 8008252:	f3c2 4407 	ubfx	r4, r2, #16, #8
 8008256:	0e12      	lsrs	r2, r2, #24
 8008258:	44ab      	add	fp, r5
 800825a:	f857 5024 	ldr.w	r5, [r7, r4, lsl #2]
 800825e:	f857 4022 	ldr.w	r4, [r7, r2, lsl #2]
 8008262:	fa5f f289 	uxtb.w	r2, r9
 8008266:	eb03 2e9b 	add.w	lr, r3, fp, lsr #10
 800826a:	f3c9 2307 	ubfx	r3, r9, #8, #8
 800826e:	eb05 2a9e 	add.w	sl, r5, lr, lsr #10
 8008272:	f857 2022 	ldr.w	r2, [r7, r2, lsl #2]
 8008276:	f857 3023 	ldr.w	r3, [r7, r3, lsl #2]
 800827a:	f3c9 4507 	ubfx	r5, r9, #16, #8
 800827e:	eb04 249a 	add.w	r4, r4, sl, lsr #10
 8008282:	ea4f 6919 	mov.w	r9, r9, lsr #24
 8008286:	eb02 2294 	add.w	r2, r2, r4, lsr #10
 800828a:	f857 5025 	ldr.w	r5, [r7, r5, lsl #2]
 800828e:	f857 9029 	ldr.w	r9, [r7, r9, lsl #2]
 8008292:	eb03 2392 	add.w	r3, r3, r2, lsr #10
 8008296:	eb05 2593 	add.w	r5, r5, r3, lsr #10
 800829a:	eb09 2995 	add.w	r9, r9, r5, lsr #10
 800829e:	f3ce 0e09 	ubfx	lr, lr, #0, #10
 80082a2:	f3cb 0b09 	ubfx	fp, fp, #0, #10
 80082a6:	f3ca 0a09 	ubfx	sl, sl, #0, #10
 80082aa:	f3c3 0309 	ubfx	r3, r3, #0, #10
 80082ae:	f3c5 0509 	ubfx	r5, r5, #0, #10
 80082b2:	ea4e 4b0b 	orr.w	fp, lr, fp, lsl #16
 80082b6:	f3c4 0409 	ubfx	r4, r4, #0, #10
 80082ba:	f3c9 0e09 	ubfx	lr, r9, #0, #10
 80082be:	f3c2 0209 	ubfx	r2, r2, #0, #10
 80082c2:	ea43 4202 	orr.w	r2, r3, r2, lsl #16
 80082c6:	ea4e 4e05 	orr.w	lr, lr, r5, lsl #16
 80082ca:	ea44 440a 	orr.w	r4, r4, sl, lsl #16
 80082ce:	ea4f 2599 	mov.w	r5, r9, lsr #10
 80082d2:	4b30      	ldr	r3, [pc, #192]	; (8008394 <D64_1CH_HTONS_VOL_HP+0x198>)
 80082d4:	fb2b 1303 	smlad	r3, fp, r3, r1
 80082d8:	492f      	ldr	r1, [pc, #188]	; (8008398 <D64_1CH_HTONS_VOL_HP+0x19c>)
 80082da:	fb24 3301 	smlad	r3, r4, r1, r3
 80082de:	492f      	ldr	r1, [pc, #188]	; (800839c <D64_1CH_HTONS_VOL_HP+0x1a0>)
 80082e0:	fb22 3301 	smlad	r3, r2, r1, r3
 80082e4:	f44f 3a80 	mov.w	sl, #65536	; 0x10000
 80082e8:	fb2e 390a 	smlad	r9, lr, sl, r3
 80082ec:	4b2c      	ldr	r3, [pc, #176]	; (80083a0 <D64_1CH_HTONS_VOL_HP+0x1a4>)
 80082ee:	fb2b 6603 	smlad	r6, fp, r3, r6
 80082f2:	fb2e 6613 	smladx	r6, lr, r3, r6
 80082f6:	4b2b      	ldr	r3, [pc, #172]	; (80083a4 <D64_1CH_HTONS_VOL_HP+0x1a8>)
 80082f8:	fb24 6603 	smlad	r6, r4, r3, r6
 80082fc:	fb22 6313 	smladx	r3, r2, r3, r6
 8008300:	f04f 0a01 	mov.w	sl, #1
 8008304:	9301      	str	r3, [sp, #4]
 8008306:	fb2b fb0a 	smuad	fp, fp, sl
 800830a:	4b27      	ldr	r3, [pc, #156]	; (80083a8 <D64_1CH_HTONS_VOL_HP+0x1ac>)
 800830c:	fb24 ba03 	smlad	sl, r4, r3, fp
 8008310:	4b26      	ldr	r3, [pc, #152]	; (80083ac <D64_1CH_HTONS_VOL_HP+0x1b0>)
 8008312:	fb22 a203 	smlad	r2, r2, r3, sl
 8008316:	4b26      	ldr	r3, [pc, #152]	; (80083b0 <D64_1CH_HTONS_VOL_HP+0x1b4>)
 8008318:	fb2e 2603 	smlad	r6, lr, r3, r2
 800831c:	f5a9 3a00 	sub.w	sl, r9, #131072	; 0x20000
 8008320:	eb0a 020c 	add.w	r2, sl, ip
 8008324:	9c04      	ldr	r4, [sp, #16]
 8008326:	9903      	ldr	r1, [sp, #12]
 8008328:	eba2 0208 	sub.w	r2, r2, r8
 800832c:	ea4f 79e2 	mov.w	r9, r2, asr #31
 8008330:	fba2 2304 	umull	r2, r3, r2, r4
 8008334:	f112 4200 	adds.w	r2, r2, #2147483648	; 0x80000000
 8008338:	fb04 3309 	mla	r3, r4, r9, r3
 800833c:	f143 0300 	adc.w	r3, r3, #0
 8008340:	02da      	lsls	r2, r3, #11
 8008342:	f04f 4800 	mov.w	r8, #2147483648	; 0x80000000
 8008346:	f04f 0900 	mov.w	r9, #0
 800834a:	fbc1 8902 	smlal	r8, r9, r1, r2
 800834e:	9902      	ldr	r1, [sp, #8]
 8008350:	ea4f 02a9 	mov.w	r2, r9, asr #2
 8008354:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8008358:	f302 020f 	ssat	r2, #16, r2
 800835c:	9b05      	ldr	r3, [sp, #20]
 800835e:	f821 2b02 	strh.w	r2, [r1], #2
 8008362:	4299      	cmp	r1, r3
 8008364:	9102      	str	r1, [sp, #8]
 8008366:	46d0      	mov	r8, sl
 8008368:	f47f af64 	bne.w	8008234 <D64_1CH_HTONS_VOL_HP+0x38>
 800836c:	9a07      	ldr	r2, [sp, #28]
 800836e:	9901      	ldr	r1, [sp, #4]
 8008370:	60d1      	str	r1, [r2, #12]
 8008372:	9906      	ldr	r1, [sp, #24]
 8008374:	6096      	str	r6, [r2, #8]
 8008376:	2000      	movs	r0, #0
 8008378:	61d5      	str	r5, [r2, #28]
 800837a:	f8c2 c010 	str.w	ip, [r2, #16]
 800837e:	f8c2 a014 	str.w	sl, [r2, #20]
 8008382:	6191      	str	r1, [r2, #24]
 8008384:	b009      	add	sp, #36	; 0x24
 8008386:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800838a:	46c2      	mov	sl, r8
 800838c:	4622      	mov	r2, r4
 800838e:	e7ee      	b.n	800836e <D64_1CH_HTONS_VOL_HP+0x172>
 8008390:	200000c8 	.word	0x200000c8
 8008394:	001c0015 	.word	0x001c0015
 8008398:	000f000a 	.word	0x000f000a
 800839c:	00060003 	.word	0x00060003
 80083a0:	0024002a 	.word	0x0024002a
 80083a4:	002e0030 	.word	0x002e0030
 80083a8:	00030006 	.word	0x00030006
 80083ac:	000a000f 	.word	0x000a000f
 80083b0:	0015001c 	.word	0x0015001c

080083b4 <D80_1CH_HTONS_VOL_HP>:
 80083b4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80083b8:	4613      	mov	r3, r2
 80083ba:	b089      	sub	sp, #36	; 0x24
 80083bc:	4686      	mov	lr, r0
 80083be:	6918      	ldr	r0, [r3, #16]
 80083c0:	9000      	str	r0, [sp, #0]
 80083c2:	4618      	mov	r0, r3
 80083c4:	461c      	mov	r4, r3
 80083c6:	695b      	ldr	r3, [r3, #20]
 80083c8:	9302      	str	r3, [sp, #8]
 80083ca:	6983      	ldr	r3, [r0, #24]
 80083cc:	9306      	str	r3, [sp, #24]
 80083ce:	f8d0 c008 	ldr.w	ip, [r0, #8]
 80083d2:	69c3      	ldr	r3, [r0, #28]
 80083d4:	68c0      	ldr	r0, [r0, #12]
 80083d6:	9207      	str	r2, [sp, #28]
 80083d8:	9001      	str	r0, [sp, #4]
 80083da:	8cd2      	ldrh	r2, [r2, #38]	; 0x26
 80083dc:	6b20      	ldr	r0, [r4, #48]	; 0x30
 80083de:	9003      	str	r0, [sp, #12]
 80083e0:	6a20      	ldr	r0, [r4, #32]
 80083e2:	9004      	str	r0, [sp, #16]
 80083e4:	2a00      	cmp	r2, #0
 80083e6:	f000 80d2 	beq.w	800858e <D80_1CH_HTONS_VOL_HP+0x1da>
 80083ea:	eb01 0242 	add.w	r2, r1, r2, lsl #1
 80083ee:	4869      	ldr	r0, [pc, #420]	; (8008594 <D80_1CH_HTONS_VOL_HP+0x1e0>)
 80083f0:	9205      	str	r2, [sp, #20]
 80083f2:	461c      	mov	r4, r3
 80083f4:	f8de 5000 	ldr.w	r5, [lr]
 80083f8:	f8de 2004 	ldr.w	r2, [lr, #4]
 80083fc:	f8de 3008 	ldr.w	r3, [lr, #8]
 8008400:	f10e 0e0a 	add.w	lr, lr, #10
 8008404:	ba6d      	rev16	r5, r5
 8008406:	ba52      	rev16	r2, r2
 8008408:	fa93 fb93 	rev16.w	fp, r3
 800840c:	b2ee      	uxtb	r6, r5
 800840e:	f3c5 2307 	ubfx	r3, r5, #8, #8
 8008412:	f850 7026 	ldr.w	r7, [r0, r6, lsl #2]
 8008416:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 800841a:	f3c5 4607 	ubfx	r6, r5, #16, #8
 800841e:	eb04 0a07 	add.w	sl, r4, r7
 8008422:	0e2d      	lsrs	r5, r5, #24
 8008424:	f850 4026 	ldr.w	r4, [r0, r6, lsl #2]
 8008428:	f850 6025 	ldr.w	r6, [r0, r5, lsl #2]
 800842c:	eb03 239a 	add.w	r3, r3, sl, lsr #10
 8008430:	eb04 2993 	add.w	r9, r4, r3, lsr #10
 8008434:	b2d5      	uxtb	r5, r2
 8008436:	f3c2 2407 	ubfx	r4, r2, #8, #8
 800843a:	f850 7025 	ldr.w	r7, [r0, r5, lsl #2]
 800843e:	f850 5024 	ldr.w	r5, [r0, r4, lsl #2]
 8008442:	f3c2 4407 	ubfx	r4, r2, #16, #8
 8008446:	eb06 2699 	add.w	r6, r6, r9, lsr #10
 800844a:	0e12      	lsrs	r2, r2, #24
 800844c:	eb07 2896 	add.w	r8, r7, r6, lsr #10
 8008450:	f850 7024 	ldr.w	r7, [r0, r4, lsl #2]
 8008454:	f850 2022 	ldr.w	r2, [r0, r2, lsl #2]
 8008458:	fa5f f48b 	uxtb.w	r4, fp
 800845c:	eb05 2598 	add.w	r5, r5, r8, lsr #10
 8008460:	f3cb 2b07 	ubfx	fp, fp, #8, #8
 8008464:	eb07 2795 	add.w	r7, r7, r5, lsr #10
 8008468:	f850 4024 	ldr.w	r4, [r0, r4, lsl #2]
 800846c:	f850 b02b 	ldr.w	fp, [r0, fp, lsl #2]
 8008470:	eb02 2297 	add.w	r2, r2, r7, lsr #10
 8008474:	eb04 2492 	add.w	r4, r4, r2, lsr #10
 8008478:	eb0b 2b94 	add.w	fp, fp, r4, lsr #10
 800847c:	f3c6 0609 	ubfx	r6, r6, #0, #10
 8008480:	f3c9 0909 	ubfx	r9, r9, #0, #10
 8008484:	f3ca 0a09 	ubfx	sl, sl, #0, #10
 8008488:	f3c5 0509 	ubfx	r5, r5, #0, #10
 800848c:	f3c7 0709 	ubfx	r7, r7, #0, #10
 8008490:	f3c4 0409 	ubfx	r4, r4, #0, #10
 8008494:	ea46 4909 	orr.w	r9, r6, r9, lsl #16
 8008498:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800849c:	f3cb 0609 	ubfx	r6, fp, #0, #10
 80084a0:	f3c8 0809 	ubfx	r8, r8, #0, #10
 80084a4:	f3c2 0209 	ubfx	r2, r2, #0, #10
 80084a8:	ea45 4808 	orr.w	r8, r5, r8, lsl #16
 80084ac:	ea42 4207 	orr.w	r2, r2, r7, lsl #16
 80084b0:	ea46 4604 	orr.w	r6, r6, r4, lsl #16
 80084b4:	ea43 430a 	orr.w	r3, r3, sl, lsl #16
 80084b8:	ea4f 249b 	mov.w	r4, fp, lsr #10
 80084bc:	4d36      	ldr	r5, [pc, #216]	; (8008598 <D80_1CH_HTONS_VOL_HP+0x1e4>)
 80084be:	9f01      	ldr	r7, [sp, #4]
 80084c0:	fb23 7505 	smlad	r5, r3, r5, r7
 80084c4:	4f35      	ldr	r7, [pc, #212]	; (800859c <D80_1CH_HTONS_VOL_HP+0x1e8>)
 80084c6:	fb29 5507 	smlad	r5, r9, r7, r5
 80084ca:	4f35      	ldr	r7, [pc, #212]	; (80085a0 <D80_1CH_HTONS_VOL_HP+0x1ec>)
 80084cc:	fb28 5507 	smlad	r5, r8, r7, r5
 80084d0:	4f34      	ldr	r7, [pc, #208]	; (80085a4 <D80_1CH_HTONS_VOL_HP+0x1f0>)
 80084d2:	fb22 5507 	smlad	r5, r2, r7, r5
 80084d6:	f44f 3a80 	mov.w	sl, #65536	; 0x10000
 80084da:	fb26 5b0a 	smlad	fp, r6, sl, r5
 80084de:	4d32      	ldr	r5, [pc, #200]	; (80085a8 <D80_1CH_HTONS_VOL_HP+0x1f4>)
 80084e0:	fb23 cc05 	smlad	ip, r3, r5, ip
 80084e4:	4d31      	ldr	r5, [pc, #196]	; (80085ac <D80_1CH_HTONS_VOL_HP+0x1f8>)
 80084e6:	fb29 cc05 	smlad	ip, r9, r5, ip
 80084ea:	f04f 154b 	mov.w	r5, #4915275	; 0x4b004b
 80084ee:	fb28 c505 	smlad	r5, r8, r5, ip
 80084f2:	4f2f      	ldr	r7, [pc, #188]	; (80085b0 <D80_1CH_HTONS_VOL_HP+0x1fc>)
 80084f4:	fb22 5507 	smlad	r5, r2, r7, r5
 80084f8:	4f2e      	ldr	r7, [pc, #184]	; (80085b4 <D80_1CH_HTONS_VOL_HP+0x200>)
 80084fa:	fb26 5507 	smlad	r5, r6, r7, r5
 80084fe:	f04f 0a01 	mov.w	sl, #1
 8008502:	9501      	str	r5, [sp, #4]
 8008504:	fb23 fa0a 	smuad	sl, r3, sl
 8008508:	4b2b      	ldr	r3, [pc, #172]	; (80085b8 <D80_1CH_HTONS_VOL_HP+0x204>)
 800850a:	fb29 a903 	smlad	r9, r9, r3, sl
 800850e:	4d2b      	ldr	r5, [pc, #172]	; (80085bc <D80_1CH_HTONS_VOL_HP+0x208>)
 8008510:	fb28 9805 	smlad	r8, r8, r5, r9
 8008514:	4d2a      	ldr	r5, [pc, #168]	; (80085c0 <D80_1CH_HTONS_VOL_HP+0x20c>)
 8008516:	fb22 8205 	smlad	r2, r2, r5, r8
 800851a:	4b2a      	ldr	r3, [pc, #168]	; (80085c4 <D80_1CH_HTONS_VOL_HP+0x210>)
 800851c:	fb26 2c03 	smlad	ip, r6, r3, r2
 8008520:	9b00      	ldr	r3, [sp, #0]
 8008522:	9d04      	ldr	r5, [sp, #16]
 8008524:	f5ab 3a7a 	sub.w	sl, fp, #256000	; 0x3e800
 8008528:	4453      	add	r3, sl
 800852a:	461a      	mov	r2, r3
 800852c:	9b02      	ldr	r3, [sp, #8]
 800852e:	f8cd a008 	str.w	sl, [sp, #8]
 8008532:	1ad2      	subs	r2, r2, r3
 8008534:	17d7      	asrs	r7, r2, #31
 8008536:	fba2 2305 	umull	r2, r3, r2, r5
 800853a:	fb05 3307 	mla	r3, r5, r7, r3
 800853e:	f112 4200 	adds.w	r2, r2, #2147483648	; 0x80000000
 8008542:	f143 0300 	adc.w	r3, r3, #0
 8008546:	9d03      	ldr	r5, [sp, #12]
 8008548:	029a      	lsls	r2, r3, #10
 800854a:	f04f 4600 	mov.w	r6, #2147483648	; 0x80000000
 800854e:	2700      	movs	r7, #0
 8008550:	005b      	lsls	r3, r3, #1
 8008552:	fbc5 6702 	smlal	r6, r7, r5, r2
 8008556:	10ba      	asrs	r2, r7, #2
 8008558:	9300      	str	r3, [sp, #0]
 800855a:	f302 020f 	ssat	r2, #16, r2
 800855e:	9b05      	ldr	r3, [sp, #20]
 8008560:	f821 2b02 	strh.w	r2, [r1], #2
 8008564:	4299      	cmp	r1, r3
 8008566:	f47f af45 	bne.w	80083f4 <D80_1CH_HTONS_VOL_HP+0x40>
 800856a:	4623      	mov	r3, r4
 800856c:	9907      	ldr	r1, [sp, #28]
 800856e:	9801      	ldr	r0, [sp, #4]
 8008570:	60c8      	str	r0, [r1, #12]
 8008572:	9a00      	ldr	r2, [sp, #0]
 8008574:	f8c1 c008 	str.w	ip, [r1, #8]
 8008578:	4608      	mov	r0, r1
 800857a:	61cb      	str	r3, [r1, #28]
 800857c:	610a      	str	r2, [r1, #16]
 800857e:	f8c1 a014 	str.w	sl, [r1, #20]
 8008582:	9906      	ldr	r1, [sp, #24]
 8008584:	6181      	str	r1, [r0, #24]
 8008586:	2000      	movs	r0, #0
 8008588:	b009      	add	sp, #36	; 0x24
 800858a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800858e:	f8dd a008 	ldr.w	sl, [sp, #8]
 8008592:	e7eb      	b.n	800856c <D80_1CH_HTONS_VOL_HP+0x1b8>
 8008594:	200000c8 	.word	0x200000c8
 8008598:	002d0024 	.word	0x002d0024
 800859c:	001c0015 	.word	0x001c0015
 80085a0:	000f000a 	.word	0x000f000a
 80085a4:	00060003 	.word	0x00060003
 80085a8:	0037003f 	.word	0x0037003f
 80085ac:	00450049 	.word	0x00450049
 80085b0:	00490045 	.word	0x00490045
 80085b4:	003f0037 	.word	0x003f0037
 80085b8:	00030006 	.word	0x00030006
 80085bc:	000a000f 	.word	0x000a000f
 80085c0:	0015001c 	.word	0x0015001c
 80085c4:	0024002d 	.word	0x0024002d

080085c8 <D128_1CH_HTONS_VOL_HP>:
 80085c8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80085cc:	b093      	sub	sp, #76	; 0x4c
 80085ce:	4614      	mov	r4, r2
 80085d0:	9211      	str	r2, [sp, #68]	; 0x44
 80085d2:	8cd3      	ldrh	r3, [r2, #38]	; 0x26
 80085d4:	6912      	ldr	r2, [r2, #16]
 80085d6:	9203      	str	r2, [sp, #12]
 80085d8:	4622      	mov	r2, r4
 80085da:	4615      	mov	r5, r2
 80085dc:	6964      	ldr	r4, [r4, #20]
 80085de:	9406      	str	r4, [sp, #24]
 80085e0:	4614      	mov	r4, r2
 80085e2:	6992      	ldr	r2, [r2, #24]
 80085e4:	9210      	str	r2, [sp, #64]	; 0x40
 80085e6:	68ea      	ldr	r2, [r5, #12]
 80085e8:	9204      	str	r2, [sp, #16]
 80085ea:	6b2a      	ldr	r2, [r5, #48]	; 0x30
 80085ec:	69e6      	ldr	r6, [r4, #28]
 80085ee:	920d      	str	r2, [sp, #52]	; 0x34
 80085f0:	68a4      	ldr	r4, [r4, #8]
 80085f2:	6a2a      	ldr	r2, [r5, #32]
 80085f4:	9405      	str	r4, [sp, #20]
 80085f6:	920e      	str	r2, [sp, #56]	; 0x38
 80085f8:	2b00      	cmp	r3, #0
 80085fa:	f000 8145 	beq.w	8008888 <D128_1CH_HTONS_VOL_HP+0x2c0>
 80085fe:	eb01 0343 	add.w	r3, r1, r3, lsl #1
 8008602:	930f      	str	r3, [sp, #60]	; 0x3c
 8008604:	f8df 82dc 	ldr.w	r8, [pc, #732]	; 80088e4 <D128_1CH_HTONS_VOL_HP+0x31c>
 8008608:	9107      	str	r1, [sp, #28]
 800860a:	f100 0310 	add.w	r3, r0, #16
 800860e:	4699      	mov	r9, r3
 8008610:	f1a9 0110 	sub.w	r1, r9, #16
 8008614:	c90e      	ldmia	r1, {r1, r2, r3}
 8008616:	f859 0c04 	ldr.w	r0, [r9, #-4]
 800861a:	ba49      	rev16	r1, r1
 800861c:	ba52      	rev16	r2, r2
 800861e:	ba5b      	rev16	r3, r3
 8008620:	fa90 fa90 	rev16.w	sl, r0
 8008624:	f3c1 2007 	ubfx	r0, r1, #8, #8
 8008628:	b2cc      	uxtb	r4, r1
 800862a:	f858 5020 	ldr.w	r5, [r8, r0, lsl #2]
 800862e:	f858 4024 	ldr.w	r4, [r8, r4, lsl #2]
 8008632:	f3c1 4007 	ubfx	r0, r1, #16, #8
 8008636:	0e09      	lsrs	r1, r1, #24
 8008638:	4426      	add	r6, r4
 800863a:	f858 4020 	ldr.w	r4, [r8, r0, lsl #2]
 800863e:	f858 7021 	ldr.w	r7, [r8, r1, lsl #2]
 8008642:	b2d0      	uxtb	r0, r2
 8008644:	eb05 2596 	add.w	r5, r5, r6, lsr #10
 8008648:	eb04 2b95 	add.w	fp, r4, r5, lsr #10
 800864c:	f3c2 2107 	ubfx	r1, r2, #8, #8
 8008650:	f858 4020 	ldr.w	r4, [r8, r0, lsl #2]
 8008654:	f858 1021 	ldr.w	r1, [r8, r1, lsl #2]
 8008658:	eb07 279b 	add.w	r7, r7, fp, lsr #10
 800865c:	f3c2 4007 	ubfx	r0, r2, #16, #8
 8008660:	0e12      	lsrs	r2, r2, #24
 8008662:	eb04 2497 	add.w	r4, r4, r7, lsr #10
 8008666:	9701      	str	r7, [sp, #4]
 8008668:	f858 0020 	ldr.w	r0, [r8, r0, lsl #2]
 800866c:	4627      	mov	r7, r4
 800866e:	f858 4022 	ldr.w	r4, [r8, r2, lsl #2]
 8008672:	9702      	str	r7, [sp, #8]
 8008674:	b2da      	uxtb	r2, r3
 8008676:	eb01 2197 	add.w	r1, r1, r7, lsr #10
 800867a:	eb00 2c91 	add.w	ip, r0, r1, lsr #10
 800867e:	f858 0022 	ldr.w	r0, [r8, r2, lsl #2]
 8008682:	eb04 249c 	add.w	r4, r4, ip, lsr #10
 8008686:	eb00 2e94 	add.w	lr, r0, r4, lsr #10
 800868a:	f3c3 2207 	ubfx	r2, r3, #8, #8
 800868e:	f3c3 4007 	ubfx	r0, r3, #16, #8
 8008692:	0e1b      	lsrs	r3, r3, #24
 8008694:	f858 7020 	ldr.w	r7, [r8, r0, lsl #2]
 8008698:	f858 2022 	ldr.w	r2, [r8, r2, lsl #2]
 800869c:	f858 0023 	ldr.w	r0, [r8, r3, lsl #2]
 80086a0:	fa5f f38a 	uxtb.w	r3, sl
 80086a4:	f3c6 0609 	ubfx	r6, r6, #0, #10
 80086a8:	960a      	str	r6, [sp, #40]	; 0x28
 80086aa:	eb02 229e 	add.w	r2, r2, lr, lsr #10
 80086ae:	f858 6023 	ldr.w	r6, [r8, r3, lsl #2]
 80086b2:	f3c5 0509 	ubfx	r5, r5, #0, #10
 80086b6:	f3ca 2307 	ubfx	r3, sl, #8, #8
 80086ba:	950b      	str	r5, [sp, #44]	; 0x2c
 80086bc:	eb07 2792 	add.w	r7, r7, r2, lsr #10
 80086c0:	f3ca 4507 	ubfx	r5, sl, #16, #8
 80086c4:	eb00 2097 	add.w	r0, r0, r7, lsr #10
 80086c8:	f858 3023 	ldr.w	r3, [r8, r3, lsl #2]
 80086cc:	f858 5025 	ldr.w	r5, [r8, r5, lsl #2]
 80086d0:	ea4f 6a1a 	mov.w	sl, sl, lsr #24
 80086d4:	eb06 2690 	add.w	r6, r6, r0, lsr #10
 80086d8:	eb03 2396 	add.w	r3, r3, r6, lsr #10
 80086dc:	f858 a02a 	ldr.w	sl, [r8, sl, lsl #2]
 80086e0:	9308      	str	r3, [sp, #32]
 80086e2:	eb05 2593 	add.w	r5, r5, r3, lsr #10
 80086e6:	9b01      	ldr	r3, [sp, #4]
 80086e8:	eb0a 2a95 	add.w	sl, sl, r5, lsr #10
 80086ec:	f8cd a024 	str.w	sl, [sp, #36]	; 0x24
 80086f0:	f3c3 0a09 	ubfx	sl, r3, #0, #10
 80086f4:	9b02      	ldr	r3, [sp, #8]
 80086f6:	f3c3 0309 	ubfx	r3, r3, #0, #10
 80086fa:	9302      	str	r3, [sp, #8]
 80086fc:	9b08      	ldr	r3, [sp, #32]
 80086fe:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8008702:	9308      	str	r3, [sp, #32]
 8008704:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8008706:	f3c5 0509 	ubfx	r5, r5, #0, #10
 800870a:	950c      	str	r5, [sp, #48]	; 0x30
 800870c:	461d      	mov	r5, r3
 800870e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8008710:	f3ce 0e09 	ubfx	lr, lr, #0, #10
 8008714:	f3c2 0209 	ubfx	r2, r2, #0, #10
 8008718:	ea45 4303 	orr.w	r3, r5, r3, lsl #16
 800871c:	ea42 420e 	orr.w	r2, r2, lr, lsl #16
 8008720:	9301      	str	r3, [sp, #4]
 8008722:	9b02      	ldr	r3, [sp, #8]
 8008724:	9202      	str	r2, [sp, #8]
 8008726:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8008728:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 800872a:	f3c7 0709 	ubfx	r7, r7, #0, #10
 800872e:	f3c0 0009 	ubfx	r0, r0, #0, #10
 8008732:	ea40 4007 	orr.w	r0, r0, r7, lsl #16
 8008736:	f3c1 0109 	ubfx	r1, r1, #0, #10
 800873a:	f3c2 0709 	ubfx	r7, r2, #0, #10
 800873e:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 8008742:	ea47 4505 	orr.w	r5, r7, r5, lsl #16
 8008746:	9b08      	ldr	r3, [sp, #32]
 8008748:	9f01      	ldr	r7, [sp, #4]
 800874a:	f3cb 0b09 	ubfx	fp, fp, #0, #10
 800874e:	f3cc 0c09 	ubfx	ip, ip, #0, #10
 8008752:	f3c6 0609 	ubfx	r6, r6, #0, #10
 8008756:	f3c4 0409 	ubfx	r4, r4, #0, #10
 800875a:	ea43 4306 	orr.w	r3, r3, r6, lsl #16
 800875e:	46be      	mov	lr, r7
 8008760:	0a96      	lsrs	r6, r2, #10
 8008762:	ea4a 4a0b 	orr.w	sl, sl, fp, lsl #16
 8008766:	ea44 440c 	orr.w	r4, r4, ip, lsl #16
 800876a:	4f49      	ldr	r7, [pc, #292]	; (8008890 <D128_1CH_HTONS_VOL_HP+0x2c8>)
 800876c:	9a04      	ldr	r2, [sp, #16]
 800876e:	fb2e 2e07 	smlad	lr, lr, r7, r2
 8008772:	4a48      	ldr	r2, [pc, #288]	; (8008894 <D128_1CH_HTONS_VOL_HP+0x2cc>)
 8008774:	fb2a ee02 	smlad	lr, sl, r2, lr
 8008778:	4a47      	ldr	r2, [pc, #284]	; (8008898 <D128_1CH_HTONS_VOL_HP+0x2d0>)
 800877a:	fb21 ee02 	smlad	lr, r1, r2, lr
 800877e:	4a47      	ldr	r2, [pc, #284]	; (800889c <D128_1CH_HTONS_VOL_HP+0x2d4>)
 8008780:	fb24 ee02 	smlad	lr, r4, r2, lr
 8008784:	4a46      	ldr	r2, [pc, #280]	; (80088a0 <D128_1CH_HTONS_VOL_HP+0x2d8>)
 8008786:	9f02      	ldr	r7, [sp, #8]
 8008788:	fb27 ee02 	smlad	lr, r7, r2, lr
 800878c:	4a45      	ldr	r2, [pc, #276]	; (80088a4 <D128_1CH_HTONS_VOL_HP+0x2dc>)
 800878e:	fb20 ee02 	smlad	lr, r0, r2, lr
 8008792:	4a45      	ldr	r2, [pc, #276]	; (80088a8 <D128_1CH_HTONS_VOL_HP+0x2e0>)
 8008794:	fb23 e702 	smlad	r7, r3, r2, lr
 8008798:	f44f 3e80 	mov.w	lr, #65536	; 0x10000
 800879c:	fb25 7e0e 	smlad	lr, r5, lr, r7
 80087a0:	9f01      	ldr	r7, [sp, #4]
 80087a2:	4a42      	ldr	r2, [pc, #264]	; (80088ac <D128_1CH_HTONS_VOL_HP+0x2e4>)
 80087a4:	46bc      	mov	ip, r7
 80087a6:	9f05      	ldr	r7, [sp, #20]
 80087a8:	fb2c 7c02 	smlad	ip, ip, r2, r7
 80087ac:	4a40      	ldr	r2, [pc, #256]	; (80088b0 <D128_1CH_HTONS_VOL_HP+0x2e8>)
 80087ae:	fb2a cc02 	smlad	ip, sl, r2, ip
 80087b2:	4f40      	ldr	r7, [pc, #256]	; (80088b4 <D128_1CH_HTONS_VOL_HP+0x2ec>)
 80087b4:	fb21 cc07 	smlad	ip, r1, r7, ip
 80087b8:	4f3f      	ldr	r7, [pc, #252]	; (80088b8 <D128_1CH_HTONS_VOL_HP+0x2f0>)
 80087ba:	fb24 cc07 	smlad	ip, r4, r7, ip
 80087be:	4f3f      	ldr	r7, [pc, #252]	; (80088bc <D128_1CH_HTONS_VOL_HP+0x2f4>)
 80087c0:	9a02      	ldr	r2, [sp, #8]
 80087c2:	fb22 cc07 	smlad	ip, r2, r7, ip
 80087c6:	4f3e      	ldr	r7, [pc, #248]	; (80088c0 <D128_1CH_HTONS_VOL_HP+0x2f8>)
 80087c8:	fb20 cc07 	smlad	ip, r0, r7, ip
 80087cc:	4f3d      	ldr	r7, [pc, #244]	; (80088c4 <D128_1CH_HTONS_VOL_HP+0x2fc>)
 80087ce:	fb23 c707 	smlad	r7, r3, r7, ip
 80087d2:	f8df c114 	ldr.w	ip, [pc, #276]	; 80088e8 <D128_1CH_HTONS_VOL_HP+0x320>
 80087d6:	fb25 720c 	smlad	r2, r5, ip, r7
 80087da:	f04f 0b01 	mov.w	fp, #1
 80087de:	9204      	str	r2, [sp, #16]
 80087e0:	9f01      	ldr	r7, [sp, #4]
 80087e2:	fb27 fb0b 	smuad	fp, r7, fp
 80087e6:	4f38      	ldr	r7, [pc, #224]	; (80088c8 <D128_1CH_HTONS_VOL_HP+0x300>)
 80087e8:	fb2a ba07 	smlad	sl, sl, r7, fp
 80087ec:	4f37      	ldr	r7, [pc, #220]	; (80088cc <D128_1CH_HTONS_VOL_HP+0x304>)
 80087ee:	fb21 aa07 	smlad	sl, r1, r7, sl
 80087f2:	4f37      	ldr	r7, [pc, #220]	; (80088d0 <D128_1CH_HTONS_VOL_HP+0x308>)
 80087f4:	fb24 aa07 	smlad	sl, r4, r7, sl
 80087f8:	4f36      	ldr	r7, [pc, #216]	; (80088d4 <D128_1CH_HTONS_VOL_HP+0x30c>)
 80087fa:	9a02      	ldr	r2, [sp, #8]
 80087fc:	fb22 a707 	smlad	r7, r2, r7, sl
 8008800:	4a35      	ldr	r2, [pc, #212]	; (80088d8 <D128_1CH_HTONS_VOL_HP+0x310>)
 8008802:	fb20 7702 	smlad	r7, r0, r2, r7
 8008806:	4a35      	ldr	r2, [pc, #212]	; (80088dc <D128_1CH_HTONS_VOL_HP+0x314>)
 8008808:	fb23 7702 	smlad	r7, r3, r2, r7
 800880c:	4b34      	ldr	r3, [pc, #208]	; (80088e0 <D128_1CH_HTONS_VOL_HP+0x318>)
 800880e:	fb25 7303 	smlad	r3, r5, r3, r7
 8008812:	9305      	str	r3, [sp, #20]
 8008814:	9b03      	ldr	r3, [sp, #12]
 8008816:	9c0e      	ldr	r4, [sp, #56]	; 0x38
 8008818:	f5ae 1e80 	sub.w	lr, lr, #1048576	; 0x100000
 800881c:	4473      	add	r3, lr
 800881e:	461a      	mov	r2, r3
 8008820:	9b06      	ldr	r3, [sp, #24]
 8008822:	f8cd e018 	str.w	lr, [sp, #24]
 8008826:	1ad2      	subs	r2, r2, r3
 8008828:	17d1      	asrs	r1, r2, #31
 800882a:	fba2 2304 	umull	r2, r3, r2, r4
 800882e:	fb04 3301 	mla	r3, r4, r1, r3
 8008832:	f112 4200 	adds.w	r2, r2, #2147483648	; 0x80000000
 8008836:	f143 0300 	adc.w	r3, r3, #0
 800883a:	9c0d      	ldr	r4, [sp, #52]	; 0x34
 800883c:	021a      	lsls	r2, r3, #8
 800883e:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
 8008842:	2100      	movs	r1, #0
 8008844:	fbc4 0102 	smlal	r0, r1, r4, r2
 8008848:	108a      	asrs	r2, r1, #2
 800884a:	9907      	ldr	r1, [sp, #28]
 800884c:	f302 020f 	ssat	r2, #16, r2
 8008850:	005b      	lsls	r3, r3, #1
 8008852:	f821 2b02 	strh.w	r2, [r1], #2
 8008856:	9303      	str	r3, [sp, #12]
 8008858:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800885a:	9107      	str	r1, [sp, #28]
 800885c:	4299      	cmp	r1, r3
 800885e:	f109 0910 	add.w	r9, r9, #16
 8008862:	f47f aed5 	bne.w	8008610 <D128_1CH_HTONS_VOL_HP+0x48>
 8008866:	9a11      	ldr	r2, [sp, #68]	; 0x44
 8008868:	9905      	ldr	r1, [sp, #20]
 800886a:	6091      	str	r1, [r2, #8]
 800886c:	9904      	ldr	r1, [sp, #16]
 800886e:	60d1      	str	r1, [r2, #12]
 8008870:	4613      	mov	r3, r2
 8008872:	61d6      	str	r6, [r2, #28]
 8008874:	9910      	ldr	r1, [sp, #64]	; 0x40
 8008876:	9a03      	ldr	r2, [sp, #12]
 8008878:	611a      	str	r2, [r3, #16]
 800887a:	2000      	movs	r0, #0
 800887c:	f8c3 e014 	str.w	lr, [r3, #20]
 8008880:	6199      	str	r1, [r3, #24]
 8008882:	b013      	add	sp, #76	; 0x4c
 8008884:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8008888:	f8dd e018 	ldr.w	lr, [sp, #24]
 800888c:	e7eb      	b.n	8008866 <D128_1CH_HTONS_VOL_HP+0x29e>
 800888e:	bf00      	nop
 8008890:	00780069 	.word	0x00780069
 8008894:	005b004e 	.word	0x005b004e
 8008898:	00420037 	.word	0x00420037
 800889c:	002d0024 	.word	0x002d0024
 80088a0:	001c0015 	.word	0x001c0015
 80088a4:	000f000a 	.word	0x000f000a
 80088a8:	00060003 	.word	0x00060003
 80088ac:	00880096 	.word	0x00880096
 80088b0:	00a200ac 	.word	0x00a200ac
 80088b4:	00b400ba 	.word	0x00b400ba
 80088b8:	00be00c0 	.word	0x00be00c0
 80088bc:	00c000be 	.word	0x00c000be
 80088c0:	00ba00b4 	.word	0x00ba00b4
 80088c4:	00ac00a2 	.word	0x00ac00a2
 80088c8:	00030006 	.word	0x00030006
 80088cc:	000a000f 	.word	0x000a000f
 80088d0:	0015001c 	.word	0x0015001c
 80088d4:	0024002d 	.word	0x0024002d
 80088d8:	00370042 	.word	0x00370042
 80088dc:	004e005b 	.word	0x004e005b
 80088e0:	00690078 	.word	0x00690078
 80088e4:	200000c8 	.word	0x200000c8
 80088e8:	00960088 	.word	0x00960088

080088ec <PDM_Filter_Init>:
 80088ec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80088ee:	2240      	movs	r2, #64	; 0x40
 80088f0:	2100      	movs	r1, #0
 80088f2:	4604      	mov	r4, r0
 80088f4:	300c      	adds	r0, #12
 80088f6:	f000 fb87 	bl	8009008 <memset>
 80088fa:	4a49      	ldr	r2, [pc, #292]	; (8008a20 <PDM_Filter_Init+0x134>)
 80088fc:	4949      	ldr	r1, [pc, #292]	; (8008a24 <PDM_Filter_Init+0x138>)
 80088fe:	6813      	ldr	r3, [r2, #0]
 8008900:	f023 0301 	bic.w	r3, r3, #1
 8008904:	6013      	str	r3, [r2, #0]
 8008906:	680b      	ldr	r3, [r1, #0]
 8008908:	b933      	cbnz	r3, 8008918 <PDM_Filter_Init+0x2c>
 800890a:	4b47      	ldr	r3, [pc, #284]	; (8008a28 <PDM_Filter_Init+0x13c>)
 800890c:	681b      	ldr	r3, [r3, #0]
 800890e:	f3c3 030b 	ubfx	r3, r3, #0, #12
 8008912:	f5b3 6f8a 	cmp.w	r3, #1104	; 0x450
 8008916:	d039      	beq.n	800898c <PDM_Filter_Init+0xa0>
 8008918:	4a44      	ldr	r2, [pc, #272]	; (8008a2c <PDM_Filter_Init+0x140>)
 800891a:	2301      	movs	r3, #1
 800891c:	6013      	str	r3, [r2, #0]
 800891e:	6813      	ldr	r3, [r2, #0]
 8008920:	2b00      	cmp	r3, #0
 8008922:	d1fc      	bne.n	800891e <PDM_Filter_Init+0x32>
 8008924:	4b42      	ldr	r3, [pc, #264]	; (8008a30 <PDM_Filter_Init+0x144>)
 8008926:	4a43      	ldr	r2, [pc, #268]	; (8008a34 <PDM_Filter_Init+0x148>)
 8008928:	601a      	str	r2, [r3, #0]
 800892a:	681a      	ldr	r2, [r3, #0]
 800892c:	4b42      	ldr	r3, [pc, #264]	; (8008a38 <PDM_Filter_Init+0x14c>)
 800892e:	429a      	cmp	r2, r3
 8008930:	d034      	beq.n	800899c <PDM_Filter_Init+0xb0>
 8008932:	2300      	movs	r3, #0
 8008934:	8820      	ldrh	r0, [r4, #0]
 8008936:	8961      	ldrh	r1, [r4, #10]
 8008938:	8922      	ldrh	r2, [r4, #8]
 800893a:	6463      	str	r3, [r4, #68]	; 0x44
 800893c:	2801      	cmp	r0, #1
 800893e:	f04f 0300 	mov.w	r3, #0
 8008942:	61a3      	str	r3, [r4, #24]
 8008944:	6123      	str	r3, [r4, #16]
 8008946:	6163      	str	r3, [r4, #20]
 8008948:	60e3      	str	r3, [r4, #12]
 800894a:	6263      	str	r3, [r4, #36]	; 0x24
 800894c:	61e3      	str	r3, [r4, #28]
 800894e:	6223      	str	r3, [r4, #32]
 8008950:	6423      	str	r3, [r4, #64]	; 0x40
 8008952:	86a1      	strh	r1, [r4, #52]	; 0x34
 8008954:	86e2      	strh	r2, [r4, #54]	; 0x36
 8008956:	d926      	bls.n	80089a6 <PDM_Filter_Init+0xba>
 8008958:	2003      	movs	r0, #3
 800895a:	2302      	movs	r3, #2
 800895c:	8862      	ldrh	r2, [r4, #2]
 800895e:	2a01      	cmp	r2, #1
 8008960:	d91e      	bls.n	80089a0 <PDM_Filter_Init+0xb4>
 8008962:	2140      	movs	r1, #64	; 0x40
 8008964:	2300      	movs	r3, #0
 8008966:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8008968:	f1b2 1f01 	cmp.w	r2, #65537	; 0x10001
 800896c:	6862      	ldr	r2, [r4, #4]
 800896e:	bf04      	itt	eq
 8008970:	6421      	streq	r1, [r4, #64]	; 0x40
 8008972:	460b      	moveq	r3, r1
 8008974:	b11a      	cbz	r2, 800897e <PDM_Filter_Init+0x92>
 8008976:	f043 0310 	orr.w	r3, r3, #16
 800897a:	6423      	str	r3, [r4, #64]	; 0x40
 800897c:	62e2      	str	r2, [r4, #44]	; 0x2c
 800897e:	2200      	movs	r2, #0
 8008980:	8722      	strh	r2, [r4, #56]	; 0x38
 8008982:	b910      	cbnz	r0, 800898a <PDM_Filter_Init+0x9e>
 8008984:	3380      	adds	r3, #128	; 0x80
 8008986:	6423      	str	r3, [r4, #64]	; 0x40
 8008988:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800898a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800898c:	4a2b      	ldr	r2, [pc, #172]	; (8008a3c <PDM_Filter_Init+0x150>)
 800898e:	2301      	movs	r3, #1
 8008990:	6013      	str	r3, [r2, #0]
 8008992:	6813      	ldr	r3, [r2, #0]
 8008994:	2b00      	cmp	r3, #0
 8008996:	d1fc      	bne.n	8008992 <PDM_Filter_Init+0xa6>
 8008998:	4b29      	ldr	r3, [pc, #164]	; (8008a40 <PDM_Filter_Init+0x154>)
 800899a:	e7c4      	b.n	8008926 <PDM_Filter_Init+0x3a>
 800899c:	4b26      	ldr	r3, [pc, #152]	; (8008a38 <PDM_Filter_Init+0x14c>)
 800899e:	e7c9      	b.n	8008934 <PDM_Filter_Init+0x48>
 80089a0:	d008      	beq.n	80089b4 <PDM_Filter_Init+0xc8>
 80089a2:	4618      	mov	r0, r3
 80089a4:	e7dd      	b.n	8008962 <PDM_Filter_Init+0x76>
 80089a6:	4d27      	ldr	r5, [pc, #156]	; (8008a44 <PDM_Filter_Init+0x158>)
 80089a8:	782a      	ldrb	r2, [r5, #0]
 80089aa:	d009      	beq.n	80089c0 <PDM_Filter_Init+0xd4>
 80089ac:	2a01      	cmp	r2, #1
 80089ae:	d020      	beq.n	80089f2 <PDM_Filter_Init+0x106>
 80089b0:	2001      	movs	r0, #1
 80089b2:	e7d3      	b.n	800895c <PDM_Filter_Init+0x70>
 80089b4:	2220      	movs	r2, #32
 80089b6:	4618      	mov	r0, r3
 80089b8:	6422      	str	r2, [r4, #64]	; 0x40
 80089ba:	4613      	mov	r3, r2
 80089bc:	2160      	movs	r1, #96	; 0x60
 80089be:	e7d2      	b.n	8008966 <PDM_Filter_Init+0x7a>
 80089c0:	2a00      	cmp	r2, #0
 80089c2:	d1cb      	bne.n	800895c <PDM_Filter_Init+0x70>
 80089c4:	4920      	ldr	r1, [pc, #128]	; (8008a48 <PDM_Filter_Init+0x15c>)
 80089c6:	f8df e088 	ldr.w	lr, [pc, #136]	; 8008a50 <PDM_Filter_Init+0x164>
 80089ca:	4f20      	ldr	r7, [pc, #128]	; (8008a4c <PDM_Filter_Init+0x160>)
 80089cc:	f501 6680 	add.w	r6, r1, #1024	; 0x400
 80089d0:	684a      	ldr	r2, [r1, #4]
 80089d2:	ea0e 5302 	and.w	r3, lr, r2, lsl #20
 80089d6:	ea02 0007 	and.w	r0, r2, r7
 80089da:	4303      	orrs	r3, r0
 80089dc:	f3c2 5209 	ubfx	r2, r2, #20, #10
 80089e0:	4413      	add	r3, r2
 80089e2:	f841 3f04 	str.w	r3, [r1, #4]!
 80089e6:	428e      	cmp	r6, r1
 80089e8:	d1f2      	bne.n	80089d0 <PDM_Filter_Init+0xe4>
 80089ea:	2001      	movs	r0, #1
 80089ec:	7028      	strb	r0, [r5, #0]
 80089ee:	2300      	movs	r3, #0
 80089f0:	e7b4      	b.n	800895c <PDM_Filter_Init+0x70>
 80089f2:	4915      	ldr	r1, [pc, #84]	; (8008a48 <PDM_Filter_Init+0x15c>)
 80089f4:	f8df e058 	ldr.w	lr, [pc, #88]	; 8008a50 <PDM_Filter_Init+0x164>
 80089f8:	4f14      	ldr	r7, [pc, #80]	; (8008a4c <PDM_Filter_Init+0x160>)
 80089fa:	f501 6680 	add.w	r6, r1, #1024	; 0x400
 80089fe:	684a      	ldr	r2, [r1, #4]
 8008a00:	ea0e 5302 	and.w	r3, lr, r2, lsl #20
 8008a04:	ea02 0007 	and.w	r0, r2, r7
 8008a08:	4303      	orrs	r3, r0
 8008a0a:	f3c2 5209 	ubfx	r2, r2, #20, #10
 8008a0e:	4413      	add	r3, r2
 8008a10:	f841 3f04 	str.w	r3, [r1, #4]!
 8008a14:	428e      	cmp	r6, r1
 8008a16:	d1f2      	bne.n	80089fe <PDM_Filter_Init+0x112>
 8008a18:	2300      	movs	r3, #0
 8008a1a:	702b      	strb	r3, [r5, #0]
 8008a1c:	2001      	movs	r0, #1
 8008a1e:	e79d      	b.n	800895c <PDM_Filter_Init+0x70>
 8008a20:	e0002000 	.word	0xe0002000
 8008a24:	e0042000 	.word	0xe0042000
 8008a28:	5c001000 	.word	0x5c001000
 8008a2c:	40023008 	.word	0x40023008
 8008a30:	40023000 	.word	0x40023000
 8008a34:	f407a5c2 	.word	0xf407a5c2
 8008a38:	b5e8b5cd 	.word	0xb5e8b5cd
 8008a3c:	58024c08 	.word	0x58024c08
 8008a40:	58024c00 	.word	0x58024c00
 8008a44:	200028dd 	.word	0x200028dd
 8008a48:	200000c4 	.word	0x200000c4
 8008a4c:	000ffc00 	.word	0x000ffc00
 8008a50:	3ff00000 	.word	0x3ff00000

08008a54 <PDM_Filter_setConfig>:
 8008a54:	b570      	push	{r4, r5, r6, lr}
 8008a56:	880a      	ldrh	r2, [r1, #0]
 8008a58:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8008a5a:	4604      	mov	r4, r0
 8008a5c:	460e      	mov	r6, r1
 8008a5e:	1e51      	subs	r1, r2, #1
 8008a60:	f423 7080 	bic.w	r0, r3, #256	; 0x100
 8008a64:	2906      	cmp	r1, #6
 8008a66:	ed2d 8b04 	vpush	{d8-d9}
 8008a6a:	6420      	str	r0, [r4, #64]	; 0x40
 8008a6c:	d91c      	bls.n	8008aa8 <PDM_Filter_setConfig+0x54>
 8008a6e:	2508      	movs	r5, #8
 8008a70:	f9b4 1038 	ldrsh.w	r1, [r4, #56]	; 0x38
 8008a74:	f9b6 3004 	ldrsh.w	r3, [r6, #4]
 8008a78:	4299      	cmp	r1, r3
 8008a7a:	f000 80a7 	beq.w	8008bcc <PDM_Filter_setConfig+0x178>
 8008a7e:	f113 0f0c 	cmn.w	r3, #12
 8008a82:	db2b      	blt.n	8008adc <PDM_Filter_setConfig+0x88>
 8008a84:	2b33      	cmp	r3, #51	; 0x33
 8008a86:	dd3a      	ble.n	8008afe <PDM_Filter_setConfig+0xaa>
 8008a88:	2333      	movs	r3, #51	; 0x33
 8008a8a:	3540      	adds	r5, #64	; 0x40
 8008a8c:	80b3      	strh	r3, [r6, #4]
 8008a8e:	8622      	strh	r2, [r4, #48]	; 0x30
 8008a90:	8873      	ldrh	r3, [r6, #2]
 8008a92:	8663      	strh	r3, [r4, #50]	; 0x32
 8008a94:	b925      	cbnz	r5, 8008aa0 <PDM_Filter_setConfig+0x4c>
 8008a96:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8008a98:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8008a9c:	6423      	str	r3, [r4, #64]	; 0x40
 8008a9e:	2500      	movs	r5, #0
 8008aa0:	ecbd 8b04 	vpop	{d8-d9}
 8008aa4:	4628      	mov	r0, r5
 8008aa6:	bd70      	pop	{r4, r5, r6, pc}
 8008aa8:	8e21      	ldrh	r1, [r4, #48]	; 0x30
 8008aaa:	4291      	cmp	r1, r2
 8008aac:	d01b      	beq.n	8008ae6 <PDM_Filter_setConfig+0x92>
 8008aae:	f423 7387 	bic.w	r3, r3, #270	; 0x10e
 8008ab2:	f023 0301 	bic.w	r3, r3, #1
 8008ab6:	4313      	orrs	r3, r2
 8008ab8:	f003 0170 	and.w	r1, r3, #112	; 0x70
 8008abc:	6423      	str	r3, [r4, #64]	; 0x40
 8008abe:	2970      	cmp	r1, #112	; 0x70
 8008ac0:	f003 030f 	and.w	r3, r3, #15
 8008ac4:	f103 33ff 	add.w	r3, r3, #4294967295	; 0xffffffff
 8008ac8:	d053      	beq.n	8008b72 <PDM_Filter_setConfig+0x11e>
 8008aca:	2b06      	cmp	r3, #6
 8008acc:	f200 8098 	bhi.w	8008c00 <PDM_Filter_setConfig+0x1ac>
 8008ad0:	e8df f003 	tbb	[pc, r3]
 8008ad4:	70737679 	.word	0x70737679
 8008ad8:	6a6d      	.short	0x6a6d
 8008ada:	5f          	.byte	0x5f
 8008adb:	00          	.byte	0x00
 8008adc:	f64f 73f4 	movw	r3, #65524	; 0xfff4
 8008ae0:	3540      	adds	r5, #64	; 0x40
 8008ae2:	80b3      	strh	r3, [r6, #4]
 8008ae4:	e7d3      	b.n	8008a8e <PDM_Filter_setConfig+0x3a>
 8008ae6:	f9b6 3004 	ldrsh.w	r3, [r6, #4]
 8008aea:	f9b4 1038 	ldrsh.w	r1, [r4, #56]	; 0x38
 8008aee:	4299      	cmp	r1, r3
 8008af0:	d04c      	beq.n	8008b8c <PDM_Filter_setConfig+0x138>
 8008af2:	f113 0f0c 	cmn.w	r3, #12
 8008af6:	f04f 0500 	mov.w	r5, #0
 8008afa:	dac3      	bge.n	8008a84 <PDM_Filter_setConfig+0x30>
 8008afc:	e7ee      	b.n	8008adc <PDM_Filter_setConfig+0x88>
 8008afe:	6c22      	ldr	r2, [r4, #64]	; 0x40
 8008b00:	f002 020f 	and.w	r2, r2, #15
 8008b04:	3a01      	subs	r2, #1
 8008b06:	2a06      	cmp	r2, #6
 8008b08:	d83b      	bhi.n	8008b82 <PDM_Filter_setConfig+0x12e>
 8008b0a:	493e      	ldr	r1, [pc, #248]	; (8008c04 <PDM_Filter_setConfig+0x1b0>)
 8008b0c:	eb01 0282 	add.w	r2, r1, r2, lsl #2
 8008b10:	ed92 9a00 	vldr	s18, [r2]
 8008b14:	ed92 8a07 	vldr	s16, [r2, #28]
 8008b18:	483b      	ldr	r0, [pc, #236]	; (8008c08 <PDM_Filter_setConfig+0x1b4>)
 8008b1a:	ee07 3a90 	vmov	s15, r3
 8008b1e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8008b22:	eeb3 7a04 	vmov.f32	s14, #52	; 0x41a00000  20.0
 8008b26:	eec7 6a87 	vdiv.f32	s13, s15, s14
 8008b2a:	ee16 1a90 	vmov	r1, s13
 8008b2e:	f000 fb97 	bl	8009260 <powf>
 8008b32:	eddf 7a36 	vldr	s15, [pc, #216]	; 8008c0c <PDM_Filter_setConfig+0x1b8>
 8008b36:	ee77 7ac9 	vsub.f32	s15, s15, s18
 8008b3a:	ee08 0a90 	vmov	s17, r0
 8008b3e:	ee17 1a90 	vmov	r1, s15
 8008b42:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 8008b46:	f000 fb8b 	bl	8009260 <powf>
 8008b4a:	ee28 8a28 	vmul.f32	s16, s16, s17
 8008b4e:	ee07 0a90 	vmov	s15, r0
 8008b52:	ee68 7a27 	vmul.f32	s15, s16, s15
 8008b56:	ee17 0a90 	vmov	r0, s15
 8008b5a:	f000 fb5b 	bl	8009214 <roundf>
 8008b5e:	ee07 0a90 	vmov	s15, r0
 8008b62:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8008b66:	88b3      	ldrh	r3, [r6, #4]
 8008b68:	8832      	ldrh	r2, [r6, #0]
 8008b6a:	edc4 7a0f 	vstr	s15, [r4, #60]	; 0x3c
 8008b6e:	8723      	strh	r3, [r4, #56]	; 0x38
 8008b70:	e78d      	b.n	8008a8e <PDM_Filter_setConfig+0x3a>
 8008b72:	2b06      	cmp	r3, #6
 8008b74:	d844      	bhi.n	8008c00 <PDM_Filter_setConfig+0x1ac>
 8008b76:	e8df f003 	tbb	[pc, r3]
 8008b7a:	3d40      	.short	0x3d40
 8008b7c:	3134373a 	.word	0x3134373a
 8008b80:	2e          	.byte	0x2e
 8008b81:	00          	.byte	0x00
 8008b82:	ed9f 8a23 	vldr	s16, [pc, #140]	; 8008c10 <PDM_Filter_setConfig+0x1bc>
 8008b86:	eeb0 9a48 	vmov.f32	s18, s16
 8008b8a:	e7c5      	b.n	8008b18 <PDM_Filter_setConfig+0xc4>
 8008b8c:	8873      	ldrh	r3, [r6, #2]
 8008b8e:	8663      	strh	r3, [r4, #50]	; 0x32
 8008b90:	e781      	b.n	8008a96 <PDM_Filter_setConfig+0x42>
 8008b92:	4b20      	ldr	r3, [pc, #128]	; (8008c14 <PDM_Filter_setConfig+0x1c0>)
 8008b94:	64a3      	str	r3, [r4, #72]	; 0x48
 8008b96:	f9b6 3004 	ldrsh.w	r3, [r6, #4]
 8008b9a:	f113 0f0c 	cmn.w	r3, #12
 8008b9e:	f04f 0500 	mov.w	r5, #0
 8008ba2:	f6bf af6f 	bge.w	8008a84 <PDM_Filter_setConfig+0x30>
 8008ba6:	e799      	b.n	8008adc <PDM_Filter_setConfig+0x88>
 8008ba8:	4b1b      	ldr	r3, [pc, #108]	; (8008c18 <PDM_Filter_setConfig+0x1c4>)
 8008baa:	64a3      	str	r3, [r4, #72]	; 0x48
 8008bac:	e7f3      	b.n	8008b96 <PDM_Filter_setConfig+0x142>
 8008bae:	4b1b      	ldr	r3, [pc, #108]	; (8008c1c <PDM_Filter_setConfig+0x1c8>)
 8008bb0:	64a3      	str	r3, [r4, #72]	; 0x48
 8008bb2:	e7f0      	b.n	8008b96 <PDM_Filter_setConfig+0x142>
 8008bb4:	4b1a      	ldr	r3, [pc, #104]	; (8008c20 <PDM_Filter_setConfig+0x1cc>)
 8008bb6:	64a3      	str	r3, [r4, #72]	; 0x48
 8008bb8:	e7ed      	b.n	8008b96 <PDM_Filter_setConfig+0x142>
 8008bba:	4b1a      	ldr	r3, [pc, #104]	; (8008c24 <PDM_Filter_setConfig+0x1d0>)
 8008bbc:	64a3      	str	r3, [r4, #72]	; 0x48
 8008bbe:	e7ea      	b.n	8008b96 <PDM_Filter_setConfig+0x142>
 8008bc0:	4b19      	ldr	r3, [pc, #100]	; (8008c28 <PDM_Filter_setConfig+0x1d4>)
 8008bc2:	64a3      	str	r3, [r4, #72]	; 0x48
 8008bc4:	e7e7      	b.n	8008b96 <PDM_Filter_setConfig+0x142>
 8008bc6:	4b19      	ldr	r3, [pc, #100]	; (8008c2c <PDM_Filter_setConfig+0x1d8>)
 8008bc8:	64a3      	str	r3, [r4, #72]	; 0x48
 8008bca:	e7e4      	b.n	8008b96 <PDM_Filter_setConfig+0x142>
 8008bcc:	8e21      	ldrh	r1, [r4, #48]	; 0x30
 8008bce:	4291      	cmp	r1, r2
 8008bd0:	f47f af55 	bne.w	8008a7e <PDM_Filter_setConfig+0x2a>
 8008bd4:	e75c      	b.n	8008a90 <PDM_Filter_setConfig+0x3c>
 8008bd6:	4b16      	ldr	r3, [pc, #88]	; (8008c30 <PDM_Filter_setConfig+0x1dc>)
 8008bd8:	64a3      	str	r3, [r4, #72]	; 0x48
 8008bda:	e7dc      	b.n	8008b96 <PDM_Filter_setConfig+0x142>
 8008bdc:	4b15      	ldr	r3, [pc, #84]	; (8008c34 <PDM_Filter_setConfig+0x1e0>)
 8008bde:	64a3      	str	r3, [r4, #72]	; 0x48
 8008be0:	e7d9      	b.n	8008b96 <PDM_Filter_setConfig+0x142>
 8008be2:	4b15      	ldr	r3, [pc, #84]	; (8008c38 <PDM_Filter_setConfig+0x1e4>)
 8008be4:	64a3      	str	r3, [r4, #72]	; 0x48
 8008be6:	e7d6      	b.n	8008b96 <PDM_Filter_setConfig+0x142>
 8008be8:	4b14      	ldr	r3, [pc, #80]	; (8008c3c <PDM_Filter_setConfig+0x1e8>)
 8008bea:	64a3      	str	r3, [r4, #72]	; 0x48
 8008bec:	e7d3      	b.n	8008b96 <PDM_Filter_setConfig+0x142>
 8008bee:	4b14      	ldr	r3, [pc, #80]	; (8008c40 <PDM_Filter_setConfig+0x1ec>)
 8008bf0:	64a3      	str	r3, [r4, #72]	; 0x48
 8008bf2:	e7d0      	b.n	8008b96 <PDM_Filter_setConfig+0x142>
 8008bf4:	4b13      	ldr	r3, [pc, #76]	; (8008c44 <PDM_Filter_setConfig+0x1f0>)
 8008bf6:	64a3      	str	r3, [r4, #72]	; 0x48
 8008bf8:	e7cd      	b.n	8008b96 <PDM_Filter_setConfig+0x142>
 8008bfa:	4b13      	ldr	r3, [pc, #76]	; (8008c48 <PDM_Filter_setConfig+0x1f4>)
 8008bfc:	64a3      	str	r3, [r4, #72]	; 0x48
 8008bfe:	e7ca      	b.n	8008b96 <PDM_Filter_setConfig+0x142>
 8008c00:	2500      	movs	r5, #0
 8008c02:	e735      	b.n	8008a70 <PDM_Filter_setConfig+0x1c>
 8008c04:	08009c5c 	.word	0x08009c5c
 8008c08:	41200000 	.word	0x41200000
 8008c0c:	42000000 	.word	0x42000000
 8008c10:	00000000 	.word	0x00000000
 8008c14:	080070fd 	.word	0x080070fd
 8008c18:	08006f6d 	.word	0x08006f6d
 8008c1c:	08006e4d 	.word	0x08006e4d
 8008c20:	08007941 	.word	0x08007941
 8008c24:	080076a1 	.word	0x080076a1
 8008c28:	08007481 	.word	0x08007481
 8008c2c:	08007295 	.word	0x08007295
 8008c30:	08007f4d 	.word	0x08007f4d
 8008c34:	08007e15 	.word	0x08007e15
 8008c38:	08007d31 	.word	0x08007d31
 8008c3c:	080085c9 	.word	0x080085c9
 8008c40:	080083b5 	.word	0x080083b5
 8008c44:	080081fd 	.word	0x080081fd
 8008c48:	08008091 	.word	0x08008091

08008c4c <PDM_Filter>:
 8008c4c:	6c13      	ldr	r3, [r2, #64]	; 0x40
 8008c4e:	f413 7f80 	tst.w	r3, #256	; 0x100
 8008c52:	d105      	bne.n	8008c60 <PDM_Filter+0x14>
 8008c54:	f013 0f80 	tst.w	r3, #128	; 0x80
 8008c58:	bf14      	ite	ne
 8008c5a:	2020      	movne	r0, #32
 8008c5c:	2030      	moveq	r0, #48	; 0x30
 8008c5e:	4770      	bx	lr
 8008c60:	6c93      	ldr	r3, [r2, #72]	; 0x48
 8008c62:	320c      	adds	r2, #12
 8008c64:	4718      	bx	r3
 8008c66:	bf00      	nop

08008c68 <arm_fir_decimate_q15>:
 8008c68:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8008c6c:	4604      	mov	r4, r0
 8008c6e:	8845      	ldrh	r5, [r0, #2]
 8008c70:	f8d0 9008 	ldr.w	r9, [r0, #8]
 8008c74:	6866      	ldr	r6, [r4, #4]
 8008c76:	f105 4400 	add.w	r4, r5, #2147483648	; 0x80000000
 8008c7a:	b08f      	sub	sp, #60	; 0x3c
 8008c7c:	3c01      	subs	r4, #1
 8008c7e:	eb09 0444 	add.w	r4, r9, r4, lsl #1
 8008c82:	9002      	str	r0, [sp, #8]
 8008c84:	9401      	str	r4, [sp, #4]
 8008c86:	7800      	ldrb	r0, [r0, #0]
 8008c88:	fbb3 f3f0 	udiv	r3, r3, r0
 8008c8c:	f003 0401 	and.w	r4, r3, #1
 8008c90:	940c      	str	r4, [sp, #48]	; 0x30
 8008c92:	085c      	lsrs	r4, r3, #1
 8008c94:	950a      	str	r5, [sp, #40]	; 0x28
 8008c96:	9606      	str	r6, [sp, #24]
 8008c98:	920b      	str	r2, [sp, #44]	; 0x2c
 8008c9a:	940d      	str	r4, [sp, #52]	; 0x34
 8008c9c:	f000 8096 	beq.w	8008dcc <arm_fir_decimate_q15+0x164>
 8008ca0:	462b      	mov	r3, r5
 8008ca2:	f003 0303 	and.w	r3, r3, #3
 8008ca6:	9308      	str	r3, [sp, #32]
 8008ca8:	4613      	mov	r3, r2
 8008caa:	3304      	adds	r3, #4
 8008cac:	08ad      	lsrs	r5, r5, #2
 8008cae:	e9cd 4303 	strd	r4, r3, [sp, #12]
 8008cb2:	9507      	str	r5, [sp, #28]
 8008cb4:	00ed      	lsls	r5, r5, #3
 8008cb6:	9509      	str	r5, [sp, #36]	; 0x24
 8008cb8:	eb06 0805 	add.w	r8, r6, r5
 8008cbc:	9c01      	ldr	r4, [sp, #4]
 8008cbe:	1d0a      	adds	r2, r1, #4
 8008cc0:	1d23      	adds	r3, r4, #4
 8008cc2:	2602      	movs	r6, #2
 8008cc4:	4299      	cmp	r1, r3
 8008cc6:	bf38      	it	cc
 8008cc8:	4294      	cmpcc	r4, r2
 8008cca:	fb10 f506 	smulbb	r5, r0, r6
 8008cce:	d36d      	bcc.n	8008dac <arm_fir_decimate_q15+0x144>
 8008cd0:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8008cd4:	fb16 2000 	smlabb	r0, r6, r0, r2
 8008cd8:	2809      	cmp	r0, #9
 8008cda:	d967      	bls.n	8008dac <arm_fir_decimate_q15+0x144>
 8008cdc:	1eae      	subs	r6, r5, #2
 8008cde:	0876      	lsrs	r6, r6, #1
 8008ce0:	3601      	adds	r6, #1
 8008ce2:	4608      	mov	r0, r1
 8008ce4:	4622      	mov	r2, r4
 8008ce6:	2300      	movs	r3, #0
 8008ce8:	3301      	adds	r3, #1
 8008cea:	f850 4b04 	ldr.w	r4, [r0], #4
 8008cee:	f842 4b04 	str.w	r4, [r2], #4
 8008cf2:	429e      	cmp	r6, r3
 8008cf4:	d8f8      	bhi.n	8008ce8 <arm_fir_decimate_q15+0x80>
 8008cf6:	9b02      	ldr	r3, [sp, #8]
 8008cf8:	9a01      	ldr	r2, [sp, #4]
 8008cfa:	781b      	ldrb	r3, [r3, #0]
 8008cfc:	9305      	str	r3, [sp, #20]
 8008cfe:	006d      	lsls	r5, r5, #1
 8008d00:	eb09 0e43 	add.w	lr, r9, r3, lsl #1
 8008d04:	9b07      	ldr	r3, [sp, #28]
 8008d06:	442a      	add	r2, r5
 8008d08:	9201      	str	r2, [sp, #4]
 8008d0a:	4429      	add	r1, r5
 8008d0c:	2b00      	cmp	r3, #0
 8008d0e:	f000 80f2 	beq.w	8008ef6 <arm_fir_decimate_q15+0x28e>
 8008d12:	2300      	movs	r3, #0
 8008d14:	9d06      	ldr	r5, [sp, #24]
 8008d16:	461c      	mov	r4, r3
 8008d18:	461a      	mov	r2, r3
 8008d1a:	4618      	mov	r0, r3
 8008d1c:	46f4      	mov	ip, lr
 8008d1e:	464f      	mov	r7, r9
 8008d20:	682e      	ldr	r6, [r5, #0]
 8008d22:	f8d7 b000 	ldr.w	fp, [r7]
 8008d26:	f8dc a000 	ldr.w	sl, [ip]
 8008d2a:	fbcb 20c6 	smlald	r2, r0, fp, r6
 8008d2e:	fbca 34c6 	smlald	r3, r4, sl, r6
 8008d32:	686e      	ldr	r6, [r5, #4]
 8008d34:	f8d7 b004 	ldr.w	fp, [r7, #4]
 8008d38:	f8dc a004 	ldr.w	sl, [ip, #4]
 8008d3c:	3508      	adds	r5, #8
 8008d3e:	3708      	adds	r7, #8
 8008d40:	f10c 0c08 	add.w	ip, ip, #8
 8008d44:	fbcb 20c6 	smlald	r2, r0, fp, r6
 8008d48:	fbca 34c6 	smlald	r3, r4, sl, r6
 8008d4c:	45a8      	cmp	r8, r5
 8008d4e:	d1e7      	bne.n	8008d20 <arm_fir_decimate_q15+0xb8>
 8008d50:	9e09      	ldr	r6, [sp, #36]	; 0x24
 8008d52:	44b6      	add	lr, r6
 8008d54:	eb09 0a06 	add.w	sl, r9, r6
 8008d58:	9e08      	ldr	r6, [sp, #32]
 8008d5a:	b166      	cbz	r6, 8008d76 <arm_fir_decimate_q15+0x10e>
 8008d5c:	4637      	mov	r7, r6
 8008d5e:	f93e cb02 	ldrsh.w	ip, [lr], #2
 8008d62:	f93a bb02 	ldrsh.w	fp, [sl], #2
 8008d66:	f935 6b02 	ldrsh.w	r6, [r5], #2
 8008d6a:	fbcb 20c6 	smlald	r2, r0, fp, r6
 8008d6e:	fbcc 34c6 	smlald	r3, r4, ip, r6
 8008d72:	3f01      	subs	r7, #1
 8008d74:	d1f3      	bne.n	8008d5e <arm_fir_decimate_q15+0xf6>
 8008d76:	0bd2      	lsrs	r2, r2, #15
 8008d78:	ea42 4240 	orr.w	r2, r2, r0, lsl #17
 8008d7c:	9804      	ldr	r0, [sp, #16]
 8008d7e:	f302 020f 	ssat	r2, #16, r2
 8008d82:	0bdb      	lsrs	r3, r3, #15
 8008d84:	ea43 4344 	orr.w	r3, r3, r4, lsl #17
 8008d88:	f303 030f 	ssat	r3, #16, r3
 8008d8c:	f820 3c02 	strh.w	r3, [r0, #-2]
 8008d90:	9b05      	ldr	r3, [sp, #20]
 8008d92:	f820 2c04 	strh.w	r2, [r0, #-4]
 8008d96:	eb09 0983 	add.w	r9, r9, r3, lsl #2
 8008d9a:	1d03      	adds	r3, r0, #4
 8008d9c:	9304      	str	r3, [sp, #16]
 8008d9e:	9b03      	ldr	r3, [sp, #12]
 8008da0:	3b01      	subs	r3, #1
 8008da2:	9303      	str	r3, [sp, #12]
 8008da4:	d00d      	beq.n	8008dc2 <arm_fir_decimate_q15+0x15a>
 8008da6:	9b02      	ldr	r3, [sp, #8]
 8008da8:	7818      	ldrb	r0, [r3, #0]
 8008daa:	e787      	b.n	8008cbc <arm_fir_decimate_q15+0x54>
 8008dac:	9b01      	ldr	r3, [sp, #4]
 8008dae:	460a      	mov	r2, r1
 8008db0:	1e98      	subs	r0, r3, #2
 8008db2:	462b      	mov	r3, r5
 8008db4:	f932 4b02 	ldrsh.w	r4, [r2], #2
 8008db8:	f820 4f02 	strh.w	r4, [r0, #2]!
 8008dbc:	3b01      	subs	r3, #1
 8008dbe:	d1f9      	bne.n	8008db4 <arm_fir_decimate_q15+0x14c>
 8008dc0:	e799      	b.n	8008cf6 <arm_fir_decimate_q15+0x8e>
 8008dc2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8008dc4:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8008dc6:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 8008dca:	930b      	str	r3, [sp, #44]	; 0x2c
 8008dcc:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8008dce:	2b00      	cmp	r3, #0
 8008dd0:	d054      	beq.n	8008e7c <arm_fir_decimate_q15+0x214>
 8008dd2:	9801      	ldr	r0, [sp, #4]
 8008dd4:	9c02      	ldr	r4, [sp, #8]
 8008dd6:	1d02      	adds	r2, r0, #4
 8008dd8:	1d0b      	adds	r3, r1, #4
 8008dda:	7825      	ldrb	r5, [r4, #0]
 8008ddc:	4298      	cmp	r0, r3
 8008dde:	bf38      	it	cc
 8008de0:	4291      	cmpcc	r1, r2
 8008de2:	f105 32ff 	add.w	r2, r5, #4294967295	; 0xffffffff
 8008de6:	f0c0 808c 	bcc.w	8008f02 <arm_fir_decimate_q15+0x29a>
 8008dea:	2a09      	cmp	r2, #9
 8008dec:	f240 8089 	bls.w	8008f02 <arm_fir_decimate_q15+0x29a>
 8008df0:	1eab      	subs	r3, r5, #2
 8008df2:	085b      	lsrs	r3, r3, #1
 8008df4:	3301      	adds	r3, #1
 8008df6:	460c      	mov	r4, r1
 8008df8:	2200      	movs	r2, #0
 8008dfa:	3201      	adds	r2, #1
 8008dfc:	f854 6b04 	ldr.w	r6, [r4], #4
 8008e00:	f840 6b04 	str.w	r6, [r0], #4
 8008e04:	4293      	cmp	r3, r2
 8008e06:	d8f8      	bhi.n	8008dfa <arm_fir_decimate_q15+0x192>
 8008e08:	ebb5 0f43 	cmp.w	r5, r3, lsl #1
 8008e0c:	d004      	beq.n	8008e18 <arm_fir_decimate_q15+0x1b0>
 8008e0e:	f931 2023 	ldrsh.w	r2, [r1, r3, lsl #2]
 8008e12:	9901      	ldr	r1, [sp, #4]
 8008e14:	f821 2023 	strh.w	r2, [r1, r3, lsl #2]
 8008e18:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8008e1a:	089a      	lsrs	r2, r3, #2
 8008e1c:	d07e      	beq.n	8008f1c <arm_fir_decimate_q15+0x2b4>
 8008e1e:	00d5      	lsls	r5, r2, #3
 8008e20:	9806      	ldr	r0, [sp, #24]
 8008e22:	2200      	movs	r2, #0
 8008e24:	eb09 0405 	add.w	r4, r9, r5
 8008e28:	4613      	mov	r3, r2
 8008e2a:	4649      	mov	r1, r9
 8008e2c:	f8d0 c000 	ldr.w	ip, [r0]
 8008e30:	6847      	ldr	r7, [r0, #4]
 8008e32:	680e      	ldr	r6, [r1, #0]
 8008e34:	3008      	adds	r0, #8
 8008e36:	fbc6 23cc 	smlald	r2, r3, r6, ip
 8008e3a:	684e      	ldr	r6, [r1, #4]
 8008e3c:	3108      	adds	r1, #8
 8008e3e:	fbc6 23c7 	smlald	r2, r3, r6, r7
 8008e42:	428c      	cmp	r4, r1
 8008e44:	d1f2      	bne.n	8008e2c <arm_fir_decimate_q15+0x1c4>
 8008e46:	9806      	ldr	r0, [sp, #24]
 8008e48:	4428      	add	r0, r5
 8008e4a:	9006      	str	r0, [sp, #24]
 8008e4c:	980a      	ldr	r0, [sp, #40]	; 0x28
 8008e4e:	f010 0003 	ands.w	r0, r0, #3
 8008e52:	d008      	beq.n	8008e66 <arm_fir_decimate_q15+0x1fe>
 8008e54:	9e06      	ldr	r6, [sp, #24]
 8008e56:	f931 4b02 	ldrsh.w	r4, [r1], #2
 8008e5a:	f936 5b02 	ldrsh.w	r5, [r6], #2
 8008e5e:	fbc4 23c5 	smlald	r2, r3, r4, r5
 8008e62:	3801      	subs	r0, #1
 8008e64:	d1f7      	bne.n	8008e56 <arm_fir_decimate_q15+0x1ee>
 8008e66:	9902      	ldr	r1, [sp, #8]
 8008e68:	0bd2      	lsrs	r2, r2, #15
 8008e6a:	7809      	ldrb	r1, [r1, #0]
 8008e6c:	ea42 4243 	orr.w	r2, r2, r3, lsl #17
 8008e70:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8008e72:	f302 020f 	ssat	r2, #16, r2
 8008e76:	eb09 0941 	add.w	r9, r9, r1, lsl #1
 8008e7a:	801a      	strh	r2, [r3, #0]
 8008e7c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8008e7e:	1e5e      	subs	r6, r3, #1
 8008e80:	9b02      	ldr	r3, [sp, #8]
 8008e82:	08b0      	lsrs	r0, r6, #2
 8008e84:	689f      	ldr	r7, [r3, #8]
 8008e86:	d023      	beq.n	8008ed0 <arm_fir_decimate_q15+0x268>
 8008e88:	f109 0308 	add.w	r3, r9, #8
 8008e8c:	f107 0208 	add.w	r2, r7, #8
 8008e90:	4591      	cmp	r9, r2
 8008e92:	bf38      	it	cc
 8008e94:	429f      	cmpcc	r7, r3
 8008e96:	bf2c      	ite	cs
 8008e98:	2301      	movcs	r3, #1
 8008e9a:	2300      	movcc	r3, #0
 8008e9c:	1e42      	subs	r2, r0, #1
 8008e9e:	2a04      	cmp	r2, #4
 8008ea0:	bf94      	ite	ls
 8008ea2:	2300      	movls	r3, #0
 8008ea4:	f003 0301 	andhi.w	r3, r3, #1
 8008ea8:	2b00      	cmp	r3, #0
 8008eaa:	d03a      	beq.n	8008f22 <arm_fir_decimate_q15+0x2ba>
 8008eac:	ea47 0309 	orr.w	r3, r7, r9
 8008eb0:	075b      	lsls	r3, r3, #29
 8008eb2:	d136      	bne.n	8008f22 <arm_fir_decimate_q15+0x2ba>
 8008eb4:	f1a9 0108 	sub.w	r1, r9, #8
 8008eb8:	463a      	mov	r2, r7
 8008eba:	2300      	movs	r3, #0
 8008ebc:	e9f1 4502 	ldrd	r4, r5, [r1, #8]!
 8008ec0:	3301      	adds	r3, #1
 8008ec2:	4298      	cmp	r0, r3
 8008ec4:	e8e2 4502 	strd	r4, r5, [r2], #8
 8008ec8:	d1f8      	bne.n	8008ebc <arm_fir_decimate_q15+0x254>
 8008eca:	00c0      	lsls	r0, r0, #3
 8008ecc:	4407      	add	r7, r0
 8008ece:	4481      	add	r9, r0
 8008ed0:	f016 0603 	ands.w	r6, r6, #3
 8008ed4:	d00c      	beq.n	8008ef0 <arm_fir_decimate_q15+0x288>
 8008ed6:	f9b9 3000 	ldrsh.w	r3, [r9]
 8008eda:	803b      	strh	r3, [r7, #0]
 8008edc:	3e01      	subs	r6, #1
 8008ede:	d007      	beq.n	8008ef0 <arm_fir_decimate_q15+0x288>
 8008ee0:	f9b9 3002 	ldrsh.w	r3, [r9, #2]
 8008ee4:	807b      	strh	r3, [r7, #2]
 8008ee6:	2e01      	cmp	r6, #1
 8008ee8:	bf1c      	itt	ne
 8008eea:	f9b9 3004 	ldrshne.w	r3, [r9, #4]
 8008eee:	80bb      	strhne	r3, [r7, #4]
 8008ef0:	b00f      	add	sp, #60	; 0x3c
 8008ef2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8008ef6:	4618      	mov	r0, r3
 8008ef8:	46ca      	mov	sl, r9
 8008efa:	9d06      	ldr	r5, [sp, #24]
 8008efc:	461c      	mov	r4, r3
 8008efe:	461a      	mov	r2, r3
 8008f00:	e72a      	b.n	8008d58 <arm_fir_decimate_q15+0xf0>
 8008f02:	9b01      	ldr	r3, [sp, #4]
 8008f04:	3b02      	subs	r3, #2
 8008f06:	e000      	b.n	8008f0a <arm_fir_decimate_q15+0x2a2>
 8008f08:	3a01      	subs	r2, #1
 8008f0a:	f931 0b02 	ldrsh.w	r0, [r1], #2
 8008f0e:	f823 0f02 	strh.w	r0, [r3, #2]!
 8008f12:	2a00      	cmp	r2, #0
 8008f14:	d1f8      	bne.n	8008f08 <arm_fir_decimate_q15+0x2a0>
 8008f16:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8008f18:	089a      	lsrs	r2, r3, #2
 8008f1a:	d180      	bne.n	8008e1e <arm_fir_decimate_q15+0x1b6>
 8008f1c:	4613      	mov	r3, r2
 8008f1e:	4649      	mov	r1, r9
 8008f20:	e794      	b.n	8008e4c <arm_fir_decimate_q15+0x1e4>
 8008f22:	463a      	mov	r2, r7
 8008f24:	464b      	mov	r3, r9
 8008f26:	4601      	mov	r1, r0
 8008f28:	681c      	ldr	r4, [r3, #0]
 8008f2a:	6014      	str	r4, [r2, #0]
 8008f2c:	685c      	ldr	r4, [r3, #4]
 8008f2e:	6054      	str	r4, [r2, #4]
 8008f30:	3901      	subs	r1, #1
 8008f32:	f103 0308 	add.w	r3, r3, #8
 8008f36:	f102 0208 	add.w	r2, r2, #8
 8008f3a:	d1f5      	bne.n	8008f28 <arm_fir_decimate_q15+0x2c0>
 8008f3c:	e7c5      	b.n	8008eca <arm_fir_decimate_q15+0x262>
 8008f3e:	bf00      	nop

08008f40 <arm_fir_decimate_init_q15>:
 8008f40:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8008f42:	e9dd 7c06 	ldrd	r7, ip, [sp, #24]
 8008f46:	fbbc f4f2 	udiv	r4, ip, r2
 8008f4a:	fb02 c414 	mls	r4, r2, r4, ip
 8008f4e:	b984      	cbnz	r4, 8008f72 <arm_fir_decimate_init_q15+0x32>
 8008f50:	4616      	mov	r6, r2
 8008f52:	f101 4200 	add.w	r2, r1, #2147483648	; 0x80000000
 8008f56:	3a01      	subs	r2, #1
 8008f58:	4605      	mov	r5, r0
 8008f5a:	4462      	add	r2, ip
 8008f5c:	8041      	strh	r1, [r0, #2]
 8008f5e:	6043      	str	r3, [r0, #4]
 8008f60:	0052      	lsls	r2, r2, #1
 8008f62:	4621      	mov	r1, r4
 8008f64:	4638      	mov	r0, r7
 8008f66:	f000 f84f 	bl	8009008 <memset>
 8008f6a:	60af      	str	r7, [r5, #8]
 8008f6c:	702e      	strb	r6, [r5, #0]
 8008f6e:	4620      	mov	r0, r4
 8008f70:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8008f72:	f06f 0001 	mvn.w	r0, #1
 8008f76:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08008f78 <__errno>:
 8008f78:	4b01      	ldr	r3, [pc, #4]	; (8008f80 <__errno+0x8>)
 8008f7a:	6818      	ldr	r0, [r3, #0]
 8008f7c:	4770      	bx	lr
 8008f7e:	bf00      	nop
 8008f80:	200004c8 	.word	0x200004c8

08008f84 <__libc_init_array>:
 8008f84:	b570      	push	{r4, r5, r6, lr}
 8008f86:	4d0d      	ldr	r5, [pc, #52]	; (8008fbc <__libc_init_array+0x38>)
 8008f88:	4c0d      	ldr	r4, [pc, #52]	; (8008fc0 <__libc_init_array+0x3c>)
 8008f8a:	1b64      	subs	r4, r4, r5
 8008f8c:	10a4      	asrs	r4, r4, #2
 8008f8e:	2600      	movs	r6, #0
 8008f90:	42a6      	cmp	r6, r4
 8008f92:	d109      	bne.n	8008fa8 <__libc_init_array+0x24>
 8008f94:	4d0b      	ldr	r5, [pc, #44]	; (8008fc4 <__libc_init_array+0x40>)
 8008f96:	4c0c      	ldr	r4, [pc, #48]	; (8008fc8 <__libc_init_array+0x44>)
 8008f98:	f000 fd40 	bl	8009a1c <_init>
 8008f9c:	1b64      	subs	r4, r4, r5
 8008f9e:	10a4      	asrs	r4, r4, #2
 8008fa0:	2600      	movs	r6, #0
 8008fa2:	42a6      	cmp	r6, r4
 8008fa4:	d105      	bne.n	8008fb2 <__libc_init_array+0x2e>
 8008fa6:	bd70      	pop	{r4, r5, r6, pc}
 8008fa8:	f855 3b04 	ldr.w	r3, [r5], #4
 8008fac:	4798      	blx	r3
 8008fae:	3601      	adds	r6, #1
 8008fb0:	e7ee      	b.n	8008f90 <__libc_init_array+0xc>
 8008fb2:	f855 3b04 	ldr.w	r3, [r5], #4
 8008fb6:	4798      	blx	r3
 8008fb8:	3601      	adds	r6, #1
 8008fba:	e7f2      	b.n	8008fa2 <__libc_init_array+0x1e>
 8008fbc:	08009d50 	.word	0x08009d50
 8008fc0:	08009d50 	.word	0x08009d50
 8008fc4:	08009d50 	.word	0x08009d50
 8008fc8:	08009d54 	.word	0x08009d54

08008fcc <malloc>:
 8008fcc:	4b02      	ldr	r3, [pc, #8]	; (8008fd8 <malloc+0xc>)
 8008fce:	4601      	mov	r1, r0
 8008fd0:	6818      	ldr	r0, [r3, #0]
 8008fd2:	f000 b88d 	b.w	80090f0 <_malloc_r>
 8008fd6:	bf00      	nop
 8008fd8:	200004c8 	.word	0x200004c8

08008fdc <free>:
 8008fdc:	4b02      	ldr	r3, [pc, #8]	; (8008fe8 <free+0xc>)
 8008fde:	4601      	mov	r1, r0
 8008fe0:	6818      	ldr	r0, [r3, #0]
 8008fe2:	f000 b819 	b.w	8009018 <_free_r>
 8008fe6:	bf00      	nop
 8008fe8:	200004c8 	.word	0x200004c8

08008fec <memcpy>:
 8008fec:	440a      	add	r2, r1
 8008fee:	4291      	cmp	r1, r2
 8008ff0:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
 8008ff4:	d100      	bne.n	8008ff8 <memcpy+0xc>
 8008ff6:	4770      	bx	lr
 8008ff8:	b510      	push	{r4, lr}
 8008ffa:	f811 4b01 	ldrb.w	r4, [r1], #1
 8008ffe:	f803 4f01 	strb.w	r4, [r3, #1]!
 8009002:	4291      	cmp	r1, r2
 8009004:	d1f9      	bne.n	8008ffa <memcpy+0xe>
 8009006:	bd10      	pop	{r4, pc}

08009008 <memset>:
 8009008:	4402      	add	r2, r0
 800900a:	4603      	mov	r3, r0
 800900c:	4293      	cmp	r3, r2
 800900e:	d100      	bne.n	8009012 <memset+0xa>
 8009010:	4770      	bx	lr
 8009012:	f803 1b01 	strb.w	r1, [r3], #1
 8009016:	e7f9      	b.n	800900c <memset+0x4>

08009018 <_free_r>:
 8009018:	b537      	push	{r0, r1, r2, r4, r5, lr}
 800901a:	2900      	cmp	r1, #0
 800901c:	d044      	beq.n	80090a8 <_free_r+0x90>
 800901e:	f851 3c04 	ldr.w	r3, [r1, #-4]
 8009022:	9001      	str	r0, [sp, #4]
 8009024:	2b00      	cmp	r3, #0
 8009026:	f1a1 0404 	sub.w	r4, r1, #4
 800902a:	bfb8      	it	lt
 800902c:	18e4      	addlt	r4, r4, r3
 800902e:	f000 f8e3 	bl	80091f8 <__malloc_lock>
 8009032:	4a1e      	ldr	r2, [pc, #120]	; (80090ac <_free_r+0x94>)
 8009034:	9801      	ldr	r0, [sp, #4]
 8009036:	6813      	ldr	r3, [r2, #0]
 8009038:	b933      	cbnz	r3, 8009048 <_free_r+0x30>
 800903a:	6063      	str	r3, [r4, #4]
 800903c:	6014      	str	r4, [r2, #0]
 800903e:	b003      	add	sp, #12
 8009040:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 8009044:	f000 b8de 	b.w	8009204 <__malloc_unlock>
 8009048:	42a3      	cmp	r3, r4
 800904a:	d908      	bls.n	800905e <_free_r+0x46>
 800904c:	6825      	ldr	r5, [r4, #0]
 800904e:	1961      	adds	r1, r4, r5
 8009050:	428b      	cmp	r3, r1
 8009052:	bf01      	itttt	eq
 8009054:	6819      	ldreq	r1, [r3, #0]
 8009056:	685b      	ldreq	r3, [r3, #4]
 8009058:	1949      	addeq	r1, r1, r5
 800905a:	6021      	streq	r1, [r4, #0]
 800905c:	e7ed      	b.n	800903a <_free_r+0x22>
 800905e:	461a      	mov	r2, r3
 8009060:	685b      	ldr	r3, [r3, #4]
 8009062:	b10b      	cbz	r3, 8009068 <_free_r+0x50>
 8009064:	42a3      	cmp	r3, r4
 8009066:	d9fa      	bls.n	800905e <_free_r+0x46>
 8009068:	6811      	ldr	r1, [r2, #0]
 800906a:	1855      	adds	r5, r2, r1
 800906c:	42a5      	cmp	r5, r4
 800906e:	d10b      	bne.n	8009088 <_free_r+0x70>
 8009070:	6824      	ldr	r4, [r4, #0]
 8009072:	4421      	add	r1, r4
 8009074:	1854      	adds	r4, r2, r1
 8009076:	42a3      	cmp	r3, r4
 8009078:	6011      	str	r1, [r2, #0]
 800907a:	d1e0      	bne.n	800903e <_free_r+0x26>
 800907c:	681c      	ldr	r4, [r3, #0]
 800907e:	685b      	ldr	r3, [r3, #4]
 8009080:	6053      	str	r3, [r2, #4]
 8009082:	4421      	add	r1, r4
 8009084:	6011      	str	r1, [r2, #0]
 8009086:	e7da      	b.n	800903e <_free_r+0x26>
 8009088:	d902      	bls.n	8009090 <_free_r+0x78>
 800908a:	230c      	movs	r3, #12
 800908c:	6003      	str	r3, [r0, #0]
 800908e:	e7d6      	b.n	800903e <_free_r+0x26>
 8009090:	6825      	ldr	r5, [r4, #0]
 8009092:	1961      	adds	r1, r4, r5
 8009094:	428b      	cmp	r3, r1
 8009096:	bf04      	itt	eq
 8009098:	6819      	ldreq	r1, [r3, #0]
 800909a:	685b      	ldreq	r3, [r3, #4]
 800909c:	6063      	str	r3, [r4, #4]
 800909e:	bf04      	itt	eq
 80090a0:	1949      	addeq	r1, r1, r5
 80090a2:	6021      	streq	r1, [r4, #0]
 80090a4:	6054      	str	r4, [r2, #4]
 80090a6:	e7ca      	b.n	800903e <_free_r+0x26>
 80090a8:	b003      	add	sp, #12
 80090aa:	bd30      	pop	{r4, r5, pc}
 80090ac:	200028e0 	.word	0x200028e0

080090b0 <sbrk_aligned>:
 80090b0:	b570      	push	{r4, r5, r6, lr}
 80090b2:	4e0e      	ldr	r6, [pc, #56]	; (80090ec <sbrk_aligned+0x3c>)
 80090b4:	460c      	mov	r4, r1
 80090b6:	6831      	ldr	r1, [r6, #0]
 80090b8:	4605      	mov	r5, r0
 80090ba:	b911      	cbnz	r1, 80090c2 <sbrk_aligned+0x12>
 80090bc:	f000 f88c 	bl	80091d8 <_sbrk_r>
 80090c0:	6030      	str	r0, [r6, #0]
 80090c2:	4621      	mov	r1, r4
 80090c4:	4628      	mov	r0, r5
 80090c6:	f000 f887 	bl	80091d8 <_sbrk_r>
 80090ca:	1c43      	adds	r3, r0, #1
 80090cc:	d00a      	beq.n	80090e4 <sbrk_aligned+0x34>
 80090ce:	1cc4      	adds	r4, r0, #3
 80090d0:	f024 0403 	bic.w	r4, r4, #3
 80090d4:	42a0      	cmp	r0, r4
 80090d6:	d007      	beq.n	80090e8 <sbrk_aligned+0x38>
 80090d8:	1a21      	subs	r1, r4, r0
 80090da:	4628      	mov	r0, r5
 80090dc:	f000 f87c 	bl	80091d8 <_sbrk_r>
 80090e0:	3001      	adds	r0, #1
 80090e2:	d101      	bne.n	80090e8 <sbrk_aligned+0x38>
 80090e4:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
 80090e8:	4620      	mov	r0, r4
 80090ea:	bd70      	pop	{r4, r5, r6, pc}
 80090ec:	200028e4 	.word	0x200028e4

080090f0 <_malloc_r>:
 80090f0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80090f4:	1ccd      	adds	r5, r1, #3
 80090f6:	f025 0503 	bic.w	r5, r5, #3
 80090fa:	3508      	adds	r5, #8
 80090fc:	2d0c      	cmp	r5, #12
 80090fe:	bf38      	it	cc
 8009100:	250c      	movcc	r5, #12
 8009102:	2d00      	cmp	r5, #0
 8009104:	4607      	mov	r7, r0
 8009106:	db01      	blt.n	800910c <_malloc_r+0x1c>
 8009108:	42a9      	cmp	r1, r5
 800910a:	d905      	bls.n	8009118 <_malloc_r+0x28>
 800910c:	230c      	movs	r3, #12
 800910e:	603b      	str	r3, [r7, #0]
 8009110:	2600      	movs	r6, #0
 8009112:	4630      	mov	r0, r6
 8009114:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8009118:	4e2e      	ldr	r6, [pc, #184]	; (80091d4 <_malloc_r+0xe4>)
 800911a:	f000 f86d 	bl	80091f8 <__malloc_lock>
 800911e:	6833      	ldr	r3, [r6, #0]
 8009120:	461c      	mov	r4, r3
 8009122:	bb34      	cbnz	r4, 8009172 <_malloc_r+0x82>
 8009124:	4629      	mov	r1, r5
 8009126:	4638      	mov	r0, r7
 8009128:	f7ff ffc2 	bl	80090b0 <sbrk_aligned>
 800912c:	1c43      	adds	r3, r0, #1
 800912e:	4604      	mov	r4, r0
 8009130:	d14d      	bne.n	80091ce <_malloc_r+0xde>
 8009132:	6834      	ldr	r4, [r6, #0]
 8009134:	4626      	mov	r6, r4
 8009136:	2e00      	cmp	r6, #0
 8009138:	d140      	bne.n	80091bc <_malloc_r+0xcc>
 800913a:	6823      	ldr	r3, [r4, #0]
 800913c:	4631      	mov	r1, r6
 800913e:	4638      	mov	r0, r7
 8009140:	eb04 0803 	add.w	r8, r4, r3
 8009144:	f000 f848 	bl	80091d8 <_sbrk_r>
 8009148:	4580      	cmp	r8, r0
 800914a:	d13a      	bne.n	80091c2 <_malloc_r+0xd2>
 800914c:	6821      	ldr	r1, [r4, #0]
 800914e:	3503      	adds	r5, #3
 8009150:	1a6d      	subs	r5, r5, r1
 8009152:	f025 0503 	bic.w	r5, r5, #3
 8009156:	3508      	adds	r5, #8
 8009158:	2d0c      	cmp	r5, #12
 800915a:	bf38      	it	cc
 800915c:	250c      	movcc	r5, #12
 800915e:	4629      	mov	r1, r5
 8009160:	4638      	mov	r0, r7
 8009162:	f7ff ffa5 	bl	80090b0 <sbrk_aligned>
 8009166:	3001      	adds	r0, #1
 8009168:	d02b      	beq.n	80091c2 <_malloc_r+0xd2>
 800916a:	6823      	ldr	r3, [r4, #0]
 800916c:	442b      	add	r3, r5
 800916e:	6023      	str	r3, [r4, #0]
 8009170:	e00e      	b.n	8009190 <_malloc_r+0xa0>
 8009172:	6822      	ldr	r2, [r4, #0]
 8009174:	1b52      	subs	r2, r2, r5
 8009176:	d41e      	bmi.n	80091b6 <_malloc_r+0xc6>
 8009178:	2a0b      	cmp	r2, #11
 800917a:	d916      	bls.n	80091aa <_malloc_r+0xba>
 800917c:	1961      	adds	r1, r4, r5
 800917e:	42a3      	cmp	r3, r4
 8009180:	6025      	str	r5, [r4, #0]
 8009182:	bf18      	it	ne
 8009184:	6059      	strne	r1, [r3, #4]
 8009186:	6863      	ldr	r3, [r4, #4]
 8009188:	bf08      	it	eq
 800918a:	6031      	streq	r1, [r6, #0]
 800918c:	5162      	str	r2, [r4, r5]
 800918e:	604b      	str	r3, [r1, #4]
 8009190:	4638      	mov	r0, r7
 8009192:	f104 060b 	add.w	r6, r4, #11
 8009196:	f000 f835 	bl	8009204 <__malloc_unlock>
 800919a:	f026 0607 	bic.w	r6, r6, #7
 800919e:	1d23      	adds	r3, r4, #4
 80091a0:	1af2      	subs	r2, r6, r3
 80091a2:	d0b6      	beq.n	8009112 <_malloc_r+0x22>
 80091a4:	1b9b      	subs	r3, r3, r6
 80091a6:	50a3      	str	r3, [r4, r2]
 80091a8:	e7b3      	b.n	8009112 <_malloc_r+0x22>
 80091aa:	6862      	ldr	r2, [r4, #4]
 80091ac:	42a3      	cmp	r3, r4
 80091ae:	bf0c      	ite	eq
 80091b0:	6032      	streq	r2, [r6, #0]
 80091b2:	605a      	strne	r2, [r3, #4]
 80091b4:	e7ec      	b.n	8009190 <_malloc_r+0xa0>
 80091b6:	4623      	mov	r3, r4
 80091b8:	6864      	ldr	r4, [r4, #4]
 80091ba:	e7b2      	b.n	8009122 <_malloc_r+0x32>
 80091bc:	4634      	mov	r4, r6
 80091be:	6876      	ldr	r6, [r6, #4]
 80091c0:	e7b9      	b.n	8009136 <_malloc_r+0x46>
 80091c2:	230c      	movs	r3, #12
 80091c4:	603b      	str	r3, [r7, #0]
 80091c6:	4638      	mov	r0, r7
 80091c8:	f000 f81c 	bl	8009204 <__malloc_unlock>
 80091cc:	e7a1      	b.n	8009112 <_malloc_r+0x22>
 80091ce:	6025      	str	r5, [r4, #0]
 80091d0:	e7de      	b.n	8009190 <_malloc_r+0xa0>
 80091d2:	bf00      	nop
 80091d4:	200028e0 	.word	0x200028e0

080091d8 <_sbrk_r>:
 80091d8:	b538      	push	{r3, r4, r5, lr}
 80091da:	4d06      	ldr	r5, [pc, #24]	; (80091f4 <_sbrk_r+0x1c>)
 80091dc:	2300      	movs	r3, #0
 80091de:	4604      	mov	r4, r0
 80091e0:	4608      	mov	r0, r1
 80091e2:	602b      	str	r3, [r5, #0]
 80091e4:	f7f8 f992 	bl	800150c <_sbrk>
 80091e8:	1c43      	adds	r3, r0, #1
 80091ea:	d102      	bne.n	80091f2 <_sbrk_r+0x1a>
 80091ec:	682b      	ldr	r3, [r5, #0]
 80091ee:	b103      	cbz	r3, 80091f2 <_sbrk_r+0x1a>
 80091f0:	6023      	str	r3, [r4, #0]
 80091f2:	bd38      	pop	{r3, r4, r5, pc}
 80091f4:	200028e8 	.word	0x200028e8

080091f8 <__malloc_lock>:
 80091f8:	4801      	ldr	r0, [pc, #4]	; (8009200 <__malloc_lock+0x8>)
 80091fa:	f000 b809 	b.w	8009210 <__retarget_lock_acquire_recursive>
 80091fe:	bf00      	nop
 8009200:	200028ec 	.word	0x200028ec

08009204 <__malloc_unlock>:
 8009204:	4801      	ldr	r0, [pc, #4]	; (800920c <__malloc_unlock+0x8>)
 8009206:	f000 b804 	b.w	8009212 <__retarget_lock_release_recursive>
 800920a:	bf00      	nop
 800920c:	200028ec 	.word	0x200028ec

08009210 <__retarget_lock_acquire_recursive>:
 8009210:	4770      	bx	lr

08009212 <__retarget_lock_release_recursive>:
 8009212:	4770      	bx	lr

08009214 <roundf>:
 8009214:	f3c0 52c7 	ubfx	r2, r0, #23, #8
 8009218:	3a7f      	subs	r2, #127	; 0x7f
 800921a:	2a16      	cmp	r2, #22
 800921c:	ee07 0a90 	vmov	s15, r0
 8009220:	dc15      	bgt.n	800924e <roundf+0x3a>
 8009222:	2a00      	cmp	r2, #0
 8009224:	da08      	bge.n	8009238 <roundf+0x24>
 8009226:	3201      	adds	r2, #1
 8009228:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
 800922c:	d101      	bne.n	8009232 <roundf+0x1e>
 800922e:	f043 537e 	orr.w	r3, r3, #1065353216	; 0x3f800000
 8009232:	ee07 3a90 	vmov	s15, r3
 8009236:	e00e      	b.n	8009256 <roundf+0x42>
 8009238:	4908      	ldr	r1, [pc, #32]	; (800925c <roundf+0x48>)
 800923a:	4111      	asrs	r1, r2
 800923c:	4208      	tst	r0, r1
 800923e:	d00a      	beq.n	8009256 <roundf+0x42>
 8009240:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 8009244:	4113      	asrs	r3, r2
 8009246:	4403      	add	r3, r0
 8009248:	ea23 0301 	bic.w	r3, r3, r1
 800924c:	e7f1      	b.n	8009232 <roundf+0x1e>
 800924e:	2a80      	cmp	r2, #128	; 0x80
 8009250:	d101      	bne.n	8009256 <roundf+0x42>
 8009252:	ee77 7aa7 	vadd.f32	s15, s15, s15
 8009256:	ee17 0a90 	vmov	r0, s15
 800925a:	4770      	bx	lr
 800925c:	007fffff 	.word	0x007fffff

08009260 <powf>:
 8009260:	b510      	push	{r4, lr}
 8009262:	ed2d 8b02 	vpush	{d8}
 8009266:	ee08 1a10 	vmov	s16, r1
 800926a:	4604      	mov	r4, r0
 800926c:	f000 f84e 	bl	800930c <__ieee754_powf>
 8009270:	eeb4 8a48 	vcmp.f32	s16, s16
 8009274:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009278:	ee08 0a90 	vmov	s17, r0
 800927c:	d63e      	bvs.n	80092fc <powf+0x9c>
 800927e:	ee07 4a90 	vmov	s15, r4
 8009282:	eef5 7a40 	vcmp.f32	s15, #0.0
 8009286:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800928a:	d112      	bne.n	80092b2 <powf+0x52>
 800928c:	eeb5 8a40 	vcmp.f32	s16, #0.0
 8009290:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009294:	d037      	beq.n	8009306 <powf+0xa6>
 8009296:	ee18 0a10 	vmov	r0, s16
 800929a:	f000 fb40 	bl	800991e <finitef>
 800929e:	b368      	cbz	r0, 80092fc <powf+0x9c>
 80092a0:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
 80092a4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80092a8:	d528      	bpl.n	80092fc <powf+0x9c>
 80092aa:	f7ff fe65 	bl	8008f78 <__errno>
 80092ae:	2322      	movs	r3, #34	; 0x22
 80092b0:	e013      	b.n	80092da <powf+0x7a>
 80092b2:	f000 fb34 	bl	800991e <finitef>
 80092b6:	b990      	cbnz	r0, 80092de <powf+0x7e>
 80092b8:	4620      	mov	r0, r4
 80092ba:	f000 fb30 	bl	800991e <finitef>
 80092be:	b170      	cbz	r0, 80092de <powf+0x7e>
 80092c0:	ee18 0a10 	vmov	r0, s16
 80092c4:	f000 fb2b 	bl	800991e <finitef>
 80092c8:	b148      	cbz	r0, 80092de <powf+0x7e>
 80092ca:	eef4 8a68 	vcmp.f32	s17, s17
 80092ce:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80092d2:	d7ea      	bvc.n	80092aa <powf+0x4a>
 80092d4:	f7ff fe50 	bl	8008f78 <__errno>
 80092d8:	2321      	movs	r3, #33	; 0x21
 80092da:	6003      	str	r3, [r0, #0]
 80092dc:	e00e      	b.n	80092fc <powf+0x9c>
 80092de:	eef5 8a40 	vcmp.f32	s17, #0.0
 80092e2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80092e6:	d109      	bne.n	80092fc <powf+0x9c>
 80092e8:	4620      	mov	r0, r4
 80092ea:	f000 fb18 	bl	800991e <finitef>
 80092ee:	b128      	cbz	r0, 80092fc <powf+0x9c>
 80092f0:	ee18 0a10 	vmov	r0, s16
 80092f4:	f000 fb13 	bl	800991e <finitef>
 80092f8:	2800      	cmp	r0, #0
 80092fa:	d1d6      	bne.n	80092aa <powf+0x4a>
 80092fc:	ee18 0a90 	vmov	r0, s17
 8009300:	ecbd 8b02 	vpop	{d8}
 8009304:	bd10      	pop	{r4, pc}
 8009306:	eef7 8a00 	vmov.f32	s17, #112	; 0x3f800000  1.0
 800930a:	e7f7      	b.n	80092fc <powf+0x9c>

0800930c <__ieee754_powf>:
 800930c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8009310:	f031 4800 	bics.w	r8, r1, #2147483648	; 0x80000000
 8009314:	ed2d 8b02 	vpush	{d8}
 8009318:	4607      	mov	r7, r0
 800931a:	ee08 0a10 	vmov	s16, r0
 800931e:	ee08 1a90 	vmov	s17, r1
 8009322:	460c      	mov	r4, r1
 8009324:	d10e      	bne.n	8009344 <__ieee754_powf+0x38>
 8009326:	f480 0780 	eor.w	r7, r0, #4194304	; 0x400000
 800932a:	007f      	lsls	r7, r7, #1
 800932c:	f517 0f00 	cmn.w	r7, #8388608	; 0x800000
 8009330:	f240 829e 	bls.w	8009870 <__ieee754_powf+0x564>
 8009334:	ee78 7a28 	vadd.f32	s15, s16, s17
 8009338:	ecbd 8b02 	vpop	{d8}
 800933c:	ee17 0a90 	vmov	r0, s15
 8009340:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8009344:	f020 4500 	bic.w	r5, r0, #2147483648	; 0x80000000
 8009348:	f1b5 4fff 	cmp.w	r5, #2139095040	; 0x7f800000
 800934c:	dcf2      	bgt.n	8009334 <__ieee754_powf+0x28>
 800934e:	f1b8 4fff 	cmp.w	r8, #2139095040	; 0x7f800000
 8009352:	dd08      	ble.n	8009366 <__ieee754_powf+0x5a>
 8009354:	f1b0 5f7e 	cmp.w	r0, #1065353216	; 0x3f800000
 8009358:	d1ec      	bne.n	8009334 <__ieee754_powf+0x28>
 800935a:	f481 0480 	eor.w	r4, r1, #4194304	; 0x400000
 800935e:	0064      	lsls	r4, r4, #1
 8009360:	f514 0f00 	cmn.w	r4, #8388608	; 0x800000
 8009364:	e7e4      	b.n	8009330 <__ieee754_powf+0x24>
 8009366:	2800      	cmp	r0, #0
 8009368:	da20      	bge.n	80093ac <__ieee754_powf+0xa0>
 800936a:	f1b8 4f97 	cmp.w	r8, #1266679808	; 0x4b800000
 800936e:	da2d      	bge.n	80093cc <__ieee754_powf+0xc0>
 8009370:	f1b8 5f7e 	cmp.w	r8, #1065353216	; 0x3f800000
 8009374:	f2c0 8285 	blt.w	8009882 <__ieee754_powf+0x576>
 8009378:	ea4f 53e8 	mov.w	r3, r8, asr #23
 800937c:	f1c3 0396 	rsb	r3, r3, #150	; 0x96
 8009380:	fa48 f603 	asr.w	r6, r8, r3
 8009384:	fa06 f303 	lsl.w	r3, r6, r3
 8009388:	4543      	cmp	r3, r8
 800938a:	f040 827a 	bne.w	8009882 <__ieee754_powf+0x576>
 800938e:	f006 0601 	and.w	r6, r6, #1
 8009392:	f1c6 0602 	rsb	r6, r6, #2
 8009396:	f1b8 5f7e 	cmp.w	r8, #1065353216	; 0x3f800000
 800939a:	d11f      	bne.n	80093dc <__ieee754_powf+0xd0>
 800939c:	2c00      	cmp	r4, #0
 800939e:	f280 826d 	bge.w	800987c <__ieee754_powf+0x570>
 80093a2:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 80093a6:	eec7 7a08 	vdiv.f32	s15, s14, s16
 80093aa:	e7c5      	b.n	8009338 <__ieee754_powf+0x2c>
 80093ac:	2600      	movs	r6, #0
 80093ae:	f1b8 4fff 	cmp.w	r8, #2139095040	; 0x7f800000
 80093b2:	d1f0      	bne.n	8009396 <__ieee754_powf+0x8a>
 80093b4:	f1b5 5f7e 	cmp.w	r5, #1065353216	; 0x3f800000
 80093b8:	f000 825a 	beq.w	8009870 <__ieee754_powf+0x564>
 80093bc:	dd08      	ble.n	80093d0 <__ieee754_powf+0xc4>
 80093be:	eddf 7ac4 	vldr	s15, [pc, #784]	; 80096d0 <__ieee754_powf+0x3c4>
 80093c2:	2c00      	cmp	r4, #0
 80093c4:	bfa8      	it	ge
 80093c6:	eef0 7a68 	vmovge.f32	s15, s17
 80093ca:	e7b5      	b.n	8009338 <__ieee754_powf+0x2c>
 80093cc:	2602      	movs	r6, #2
 80093ce:	e7ee      	b.n	80093ae <__ieee754_powf+0xa2>
 80093d0:	2c00      	cmp	r4, #0
 80093d2:	f280 8250 	bge.w	8009876 <__ieee754_powf+0x56a>
 80093d6:	eef1 7a68 	vneg.f32	s15, s17
 80093da:	e7ad      	b.n	8009338 <__ieee754_powf+0x2c>
 80093dc:	f1b4 4f80 	cmp.w	r4, #1073741824	; 0x40000000
 80093e0:	d102      	bne.n	80093e8 <__ieee754_powf+0xdc>
 80093e2:	ee68 7a08 	vmul.f32	s15, s16, s16
 80093e6:	e7a7      	b.n	8009338 <__ieee754_powf+0x2c>
 80093e8:	f1b4 5f7c 	cmp.w	r4, #1056964608	; 0x3f000000
 80093ec:	ee18 0a10 	vmov	r0, s16
 80093f0:	d107      	bne.n	8009402 <__ieee754_powf+0xf6>
 80093f2:	2f00      	cmp	r7, #0
 80093f4:	db05      	blt.n	8009402 <__ieee754_powf+0xf6>
 80093f6:	ecbd 8b02 	vpop	{d8}
 80093fa:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 80093fe:	f000 ba59 	b.w	80098b4 <__ieee754_sqrtf>
 8009402:	f000 fa89 	bl	8009918 <fabsf>
 8009406:	ee07 0a90 	vmov	s15, r0
 800940a:	b125      	cbz	r5, 8009416 <__ieee754_powf+0x10a>
 800940c:	f027 4340 	bic.w	r3, r7, #3221225472	; 0xc0000000
 8009410:	f1b3 5f7e 	cmp.w	r3, #1065353216	; 0x3f800000
 8009414:	d117      	bne.n	8009446 <__ieee754_powf+0x13a>
 8009416:	2c00      	cmp	r4, #0
 8009418:	bfbc      	itt	lt
 800941a:	eeb7 7a00 	vmovlt.f32	s14, #112	; 0x3f800000  1.0
 800941e:	eec7 7a27 	vdivlt.f32	s15, s14, s15
 8009422:	2f00      	cmp	r7, #0
 8009424:	da88      	bge.n	8009338 <__ieee754_powf+0x2c>
 8009426:	f1a5 557e 	sub.w	r5, r5, #1065353216	; 0x3f800000
 800942a:	ea55 0306 	orrs.w	r3, r5, r6
 800942e:	d104      	bne.n	800943a <__ieee754_powf+0x12e>
 8009430:	ee37 7ae7 	vsub.f32	s14, s15, s15
 8009434:	eec7 7a07 	vdiv.f32	s15, s14, s14
 8009438:	e77e      	b.n	8009338 <__ieee754_powf+0x2c>
 800943a:	2e01      	cmp	r6, #1
 800943c:	f47f af7c 	bne.w	8009338 <__ieee754_powf+0x2c>
 8009440:	eef1 7a67 	vneg.f32	s15, s15
 8009444:	e778      	b.n	8009338 <__ieee754_powf+0x2c>
 8009446:	0ff8      	lsrs	r0, r7, #31
 8009448:	3801      	subs	r0, #1
 800944a:	ea56 0300 	orrs.w	r3, r6, r0
 800944e:	d104      	bne.n	800945a <__ieee754_powf+0x14e>
 8009450:	ee38 8a48 	vsub.f32	s16, s16, s16
 8009454:	eec8 7a08 	vdiv.f32	s15, s16, s16
 8009458:	e76e      	b.n	8009338 <__ieee754_powf+0x2c>
 800945a:	f1b8 4f9a 	cmp.w	r8, #1291845632	; 0x4d000000
 800945e:	dd74      	ble.n	800954a <__ieee754_powf+0x23e>
 8009460:	4b9c      	ldr	r3, [pc, #624]	; (80096d4 <__ieee754_powf+0x3c8>)
 8009462:	429d      	cmp	r5, r3
 8009464:	dc08      	bgt.n	8009478 <__ieee754_powf+0x16c>
 8009466:	2c00      	cmp	r4, #0
 8009468:	da0b      	bge.n	8009482 <__ieee754_powf+0x176>
 800946a:	2000      	movs	r0, #0
 800946c:	ecbd 8b02 	vpop	{d8}
 8009470:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8009474:	f000 ba46 	b.w	8009904 <__math_oflowf>
 8009478:	4b97      	ldr	r3, [pc, #604]	; (80096d8 <__ieee754_powf+0x3cc>)
 800947a:	429d      	cmp	r5, r3
 800947c:	dd08      	ble.n	8009490 <__ieee754_powf+0x184>
 800947e:	2c00      	cmp	r4, #0
 8009480:	dcf3      	bgt.n	800946a <__ieee754_powf+0x15e>
 8009482:	2000      	movs	r0, #0
 8009484:	ecbd 8b02 	vpop	{d8}
 8009488:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 800948c:	f000 ba30 	b.w	80098f0 <__math_uflowf>
 8009490:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 8009494:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8009498:	eddf 6a90 	vldr	s13, [pc, #576]	; 80096dc <__ieee754_powf+0x3d0>
 800949c:	eeb5 7a00 	vmov.f32	s14, #80	; 0x3e800000  0.250
 80094a0:	eee7 6ac7 	vfms.f32	s13, s15, s14
 80094a4:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
 80094a8:	eea6 7ae7 	vfms.f32	s14, s13, s15
 80094ac:	ee27 6aa7 	vmul.f32	s12, s15, s15
 80094b0:	ee66 6a07 	vmul.f32	s13, s12, s14
 80094b4:	ed9f 7a8a 	vldr	s14, [pc, #552]	; 80096e0 <__ieee754_powf+0x3d4>
 80094b8:	ed9f 6a8a 	vldr	s12, [pc, #552]	; 80096e4 <__ieee754_powf+0x3d8>
 80094bc:	ee27 7a66 	vnmul.f32	s14, s14, s13
 80094c0:	eddf 6a89 	vldr	s13, [pc, #548]	; 80096e8 <__ieee754_powf+0x3dc>
 80094c4:	eea7 7aa6 	vfma.f32	s14, s15, s13
 80094c8:	eef0 6a47 	vmov.f32	s13, s14
 80094cc:	eee7 6a86 	vfma.f32	s13, s15, s12
 80094d0:	ee16 3a90 	vmov	r3, s13
 80094d4:	f423 637f 	bic.w	r3, r3, #4080	; 0xff0
 80094d8:	f023 030f 	bic.w	r3, r3, #15
 80094dc:	ee05 3a90 	vmov	s11, r3
 80094e0:	eee7 5ac6 	vfms.f32	s11, s15, s12
 80094e4:	ee06 3a90 	vmov	s13, r3
 80094e8:	ee37 7a65 	vsub.f32	s14, s14, s11
 80094ec:	3e01      	subs	r6, #1
 80094ee:	f424 647f 	bic.w	r4, r4, #4080	; 0xff0
 80094f2:	ea56 0300 	orrs.w	r3, r6, r0
 80094f6:	eeff 7a00 	vmov.f32	s15, #240	; 0xbf800000 -1.0
 80094fa:	f024 040f 	bic.w	r4, r4, #15
 80094fe:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
 8009502:	bf08      	it	eq
 8009504:	eeb0 8a67 	vmoveq.f32	s16, s15
 8009508:	ee07 4a90 	vmov	s15, r4
 800950c:	ee27 7a28 	vmul.f32	s14, s14, s17
 8009510:	ee78 7ae7 	vsub.f32	s15, s17, s15
 8009514:	eea7 7aa6 	vfma.f32	s14, s15, s13
 8009518:	ee07 4a90 	vmov	s15, r4
 800951c:	ee66 6aa7 	vmul.f32	s13, s13, s15
 8009520:	ee77 7a26 	vadd.f32	s15, s14, s13
 8009524:	ee17 0a90 	vmov	r0, s15
 8009528:	2800      	cmp	r0, #0
 800952a:	f020 4300 	bic.w	r3, r0, #2147483648	; 0x80000000
 800952e:	f340 8181 	ble.w	8009834 <__ieee754_powf+0x528>
 8009532:	f1b3 4f86 	cmp.w	r3, #1124073472	; 0x43000000
 8009536:	f340 80f9 	ble.w	800972c <__ieee754_powf+0x420>
 800953a:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
 800953e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009542:	bf4c      	ite	mi
 8009544:	2001      	movmi	r0, #1
 8009546:	2000      	movpl	r0, #0
 8009548:	e790      	b.n	800946c <__ieee754_powf+0x160>
 800954a:	f017 4fff 	tst.w	r7, #2139095040	; 0x7f800000
 800954e:	bf01      	itttt	eq
 8009550:	ed9f 7a66 	vldreq	s14, [pc, #408]	; 80096ec <__ieee754_powf+0x3e0>
 8009554:	ee67 7a87 	vmuleq.f32	s15, s15, s14
 8009558:	f06f 0317 	mvneq.w	r3, #23
 800955c:	ee17 5a90 	vmoveq	r5, s15
 8009560:	ea4f 52e5 	mov.w	r2, r5, asr #23
 8009564:	bf18      	it	ne
 8009566:	2300      	movne	r3, #0
 8009568:	3a7f      	subs	r2, #127	; 0x7f
 800956a:	441a      	add	r2, r3
 800956c:	4b60      	ldr	r3, [pc, #384]	; (80096f0 <__ieee754_powf+0x3e4>)
 800956e:	f3c5 0516 	ubfx	r5, r5, #0, #23
 8009572:	429d      	cmp	r5, r3
 8009574:	f045 517e 	orr.w	r1, r5, #1065353216	; 0x3f800000
 8009578:	dd06      	ble.n	8009588 <__ieee754_powf+0x27c>
 800957a:	4b5e      	ldr	r3, [pc, #376]	; (80096f4 <__ieee754_powf+0x3e8>)
 800957c:	429d      	cmp	r5, r3
 800957e:	f340 80a4 	ble.w	80096ca <__ieee754_powf+0x3be>
 8009582:	3201      	adds	r2, #1
 8009584:	f5a1 0100 	sub.w	r1, r1, #8388608	; 0x800000
 8009588:	2500      	movs	r5, #0
 800958a:	4b5b      	ldr	r3, [pc, #364]	; (80096f8 <__ieee754_powf+0x3ec>)
 800958c:	eb03 0385 	add.w	r3, r3, r5, lsl #2
 8009590:	ee07 1a90 	vmov	s15, r1
 8009594:	ed93 7a00 	vldr	s14, [r3]
 8009598:	4b58      	ldr	r3, [pc, #352]	; (80096fc <__ieee754_powf+0x3f0>)
 800959a:	ee37 6a27 	vadd.f32	s12, s14, s15
 800959e:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
 80095a2:	eec5 6a86 	vdiv.f32	s13, s11, s12
 80095a6:	1049      	asrs	r1, r1, #1
 80095a8:	f041 5100 	orr.w	r1, r1, #536870912	; 0x20000000
 80095ac:	f501 2180 	add.w	r1, r1, #262144	; 0x40000
 80095b0:	eb01 5145 	add.w	r1, r1, r5, lsl #21
 80095b4:	ee37 5ac7 	vsub.f32	s10, s15, s14
 80095b8:	ee06 1a10 	vmov	s12, r1
 80095bc:	ee65 4a26 	vmul.f32	s9, s10, s13
 80095c0:	ee36 7a47 	vsub.f32	s14, s12, s14
 80095c4:	ee14 7a90 	vmov	r7, s9
 80095c8:	401f      	ands	r7, r3
 80095ca:	ee05 7a90 	vmov	s11, r7
 80095ce:	eea5 5ac6 	vfms.f32	s10, s11, s12
 80095d2:	ee77 7ac7 	vsub.f32	s15, s15, s14
 80095d6:	ee24 7aa4 	vmul.f32	s14, s9, s9
 80095da:	eea5 5ae7 	vfms.f32	s10, s11, s15
 80095de:	eddf 7a48 	vldr	s15, [pc, #288]	; 8009700 <__ieee754_powf+0x3f4>
 80095e2:	ee25 6a26 	vmul.f32	s12, s10, s13
 80095e6:	eddf 6a47 	vldr	s13, [pc, #284]	; 8009704 <__ieee754_powf+0x3f8>
 80095ea:	eee7 7a26 	vfma.f32	s15, s14, s13
 80095ee:	eddf 6a46 	vldr	s13, [pc, #280]	; 8009708 <__ieee754_powf+0x3fc>
 80095f2:	eee7 6a87 	vfma.f32	s13, s15, s14
 80095f6:	eddf 7a39 	vldr	s15, [pc, #228]	; 80096dc <__ieee754_powf+0x3d0>
 80095fa:	eee6 7a87 	vfma.f32	s15, s13, s14
 80095fe:	eddf 6a43 	vldr	s13, [pc, #268]	; 800970c <__ieee754_powf+0x400>
 8009602:	eee7 6a87 	vfma.f32	s13, s15, s14
 8009606:	eddf 7a42 	vldr	s15, [pc, #264]	; 8009710 <__ieee754_powf+0x404>
 800960a:	eee6 7a87 	vfma.f32	s15, s13, s14
 800960e:	ee74 6aa5 	vadd.f32	s13, s9, s11
 8009612:	ee27 5a07 	vmul.f32	s10, s14, s14
 8009616:	ee66 6a86 	vmul.f32	s13, s13, s12
 800961a:	eee5 6a27 	vfma.f32	s13, s10, s15
 800961e:	eeb0 5a08 	vmov.f32	s10, #8	; 0x40400000  3.0
 8009622:	eeb0 7a45 	vmov.f32	s14, s10
 8009626:	eea5 7aa5 	vfma.f32	s14, s11, s11
 800962a:	ee37 7a26 	vadd.f32	s14, s14, s13
 800962e:	ee17 1a10 	vmov	r1, s14
 8009632:	4019      	ands	r1, r3
 8009634:	ee07 1a10 	vmov	s14, r1
 8009638:	ee77 7a45 	vsub.f32	s15, s14, s10
 800963c:	eee5 7ae5 	vfms.f32	s15, s11, s11
 8009640:	ee76 7ae7 	vsub.f32	s15, s13, s15
 8009644:	ee67 7aa4 	vmul.f32	s15, s15, s9
 8009648:	eee6 7a07 	vfma.f32	s15, s12, s14
 800964c:	eeb0 5a67 	vmov.f32	s10, s15
 8009650:	eea5 5a87 	vfma.f32	s10, s11, s14
 8009654:	ee15 1a10 	vmov	r1, s10
 8009658:	4019      	ands	r1, r3
 800965a:	ee06 1a90 	vmov	s13, r1
 800965e:	eee5 6ac7 	vfms.f32	s13, s11, s14
 8009662:	ed9f 7a2c 	vldr	s14, [pc, #176]	; 8009714 <__ieee754_powf+0x408>
 8009666:	eddf 5a2c 	vldr	s11, [pc, #176]	; 8009718 <__ieee754_powf+0x40c>
 800966a:	ee77 7ae6 	vsub.f32	s15, s15, s13
 800966e:	ee05 1a10 	vmov	s10, r1
 8009672:	ee67 7a87 	vmul.f32	s15, s15, s14
 8009676:	ed9f 7a29 	vldr	s14, [pc, #164]	; 800971c <__ieee754_powf+0x410>
 800967a:	4929      	ldr	r1, [pc, #164]	; (8009720 <__ieee754_powf+0x414>)
 800967c:	eee5 7a07 	vfma.f32	s15, s10, s14
 8009680:	eb01 0185 	add.w	r1, r1, r5, lsl #2
 8009684:	ed91 7a00 	vldr	s14, [r1]
 8009688:	ee77 7a87 	vadd.f32	s15, s15, s14
 800968c:	ee07 2a10 	vmov	s14, r2
 8009690:	eef0 6a67 	vmov.f32	s13, s15
 8009694:	4a23      	ldr	r2, [pc, #140]	; (8009724 <__ieee754_powf+0x418>)
 8009696:	eee5 6a25 	vfma.f32	s13, s10, s11
 800969a:	eb02 0585 	add.w	r5, r2, r5, lsl #2
 800969e:	eeb8 6ac7 	vcvt.f32.s32	s12, s14
 80096a2:	ed95 7a00 	vldr	s14, [r5]
 80096a6:	ee76 6a87 	vadd.f32	s13, s13, s14
 80096aa:	ee76 6a86 	vadd.f32	s13, s13, s12
 80096ae:	ee16 2a90 	vmov	r2, s13
 80096b2:	401a      	ands	r2, r3
 80096b4:	ee06 2a90 	vmov	s13, r2
 80096b8:	ee36 6ac6 	vsub.f32	s12, s13, s12
 80096bc:	ee36 7a47 	vsub.f32	s14, s12, s14
 80096c0:	eea5 7a65 	vfms.f32	s14, s10, s11
 80096c4:	ee37 7ac7 	vsub.f32	s14, s15, s14
 80096c8:	e710      	b.n	80094ec <__ieee754_powf+0x1e0>
 80096ca:	2501      	movs	r5, #1
 80096cc:	e75d      	b.n	800958a <__ieee754_powf+0x27e>
 80096ce:	bf00      	nop
 80096d0:	00000000 	.word	0x00000000
 80096d4:	3f7ffff3 	.word	0x3f7ffff3
 80096d8:	3f800007 	.word	0x3f800007
 80096dc:	3eaaaaab 	.word	0x3eaaaaab
 80096e0:	3fb8aa3b 	.word	0x3fb8aa3b
 80096e4:	3fb8aa00 	.word	0x3fb8aa00
 80096e8:	36eca570 	.word	0x36eca570
 80096ec:	4b800000 	.word	0x4b800000
 80096f0:	001cc471 	.word	0x001cc471
 80096f4:	005db3d6 	.word	0x005db3d6
 80096f8:	08009d30 	.word	0x08009d30
 80096fc:	fffff000 	.word	0xfffff000
 8009700:	3e6c3255 	.word	0x3e6c3255
 8009704:	3e53f142 	.word	0x3e53f142
 8009708:	3e8ba305 	.word	0x3e8ba305
 800970c:	3edb6db7 	.word	0x3edb6db7
 8009710:	3f19999a 	.word	0x3f19999a
 8009714:	3f76384f 	.word	0x3f76384f
 8009718:	3f763800 	.word	0x3f763800
 800971c:	369dc3a0 	.word	0x369dc3a0
 8009720:	08009d40 	.word	0x08009d40
 8009724:	08009d38 	.word	0x08009d38
 8009728:	3338aa3c 	.word	0x3338aa3c
 800972c:	f040 8097 	bne.w	800985e <__ieee754_powf+0x552>
 8009730:	ed1f 6a03 	vldr	s12, [pc, #-12]	; 8009728 <__ieee754_powf+0x41c>
 8009734:	ee77 7ae6 	vsub.f32	s15, s15, s13
 8009738:	ee37 6a06 	vadd.f32	s12, s14, s12
 800973c:	eeb4 6ae7 	vcmpe.f32	s12, s15
 8009740:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009744:	f73f aef9 	bgt.w	800953a <__ieee754_powf+0x22e>
 8009748:	15db      	asrs	r3, r3, #23
 800974a:	f1a3 017e 	sub.w	r1, r3, #126	; 0x7e
 800974e:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
 8009752:	410b      	asrs	r3, r1
 8009754:	4403      	add	r3, r0
 8009756:	494c      	ldr	r1, [pc, #304]	; (8009888 <__ieee754_powf+0x57c>)
 8009758:	f3c3 52c7 	ubfx	r2, r3, #23, #8
 800975c:	3a7f      	subs	r2, #127	; 0x7f
 800975e:	4111      	asrs	r1, r2
 8009760:	ea23 0401 	bic.w	r4, r3, r1
 8009764:	ee07 4a90 	vmov	s15, r4
 8009768:	f3c3 0116 	ubfx	r1, r3, #0, #23
 800976c:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
 8009770:	f1c2 0217 	rsb	r2, r2, #23
 8009774:	4111      	asrs	r1, r2
 8009776:	2800      	cmp	r0, #0
 8009778:	ee76 6ae7 	vsub.f32	s13, s13, s15
 800977c:	bfb8      	it	lt
 800977e:	4249      	neglt	r1, r1
 8009780:	ee36 6a87 	vadd.f32	s12, s13, s14
 8009784:	eddf 7a41 	vldr	s15, [pc, #260]	; 800988c <__ieee754_powf+0x580>
 8009788:	eddf 5a41 	vldr	s11, [pc, #260]	; 8009890 <__ieee754_powf+0x584>
 800978c:	ee16 3a10 	vmov	r3, s12
 8009790:	f423 637f 	bic.w	r3, r3, #4080	; 0xff0
 8009794:	f023 030f 	bic.w	r3, r3, #15
 8009798:	ee06 3a10 	vmov	s12, r3
 800979c:	ee76 6a66 	vsub.f32	s13, s12, s13
 80097a0:	ee37 7a66 	vsub.f32	s14, s14, s13
 80097a4:	eddf 6a3b 	vldr	s13, [pc, #236]	; 8009894 <__ieee754_powf+0x588>
 80097a8:	ee66 6a26 	vmul.f32	s13, s12, s13
 80097ac:	eee7 6a27 	vfma.f32	s13, s14, s15
 80097b0:	eef0 7a66 	vmov.f32	s15, s13
 80097b4:	eee6 7a25 	vfma.f32	s15, s12, s11
 80097b8:	eeb0 7a67 	vmov.f32	s14, s15
 80097bc:	eea6 7a65 	vfms.f32	s14, s12, s11
 80097c0:	eddf 5a35 	vldr	s11, [pc, #212]	; 8009898 <__ieee754_powf+0x58c>
 80097c4:	ed9f 6a35 	vldr	s12, [pc, #212]	; 800989c <__ieee754_powf+0x590>
 80097c8:	ee36 7ac7 	vsub.f32	s14, s13, s14
 80097cc:	ee67 6aa7 	vmul.f32	s13, s15, s15
 80097d0:	eea7 7a87 	vfma.f32	s14, s15, s14
 80097d4:	eea6 6aa5 	vfma.f32	s12, s13, s11
 80097d8:	eddf 5a31 	vldr	s11, [pc, #196]	; 80098a0 <__ieee754_powf+0x594>
 80097dc:	eee6 5a26 	vfma.f32	s11, s12, s13
 80097e0:	ed9f 6a30 	vldr	s12, [pc, #192]	; 80098a4 <__ieee754_powf+0x598>
 80097e4:	eea5 6aa6 	vfma.f32	s12, s11, s13
 80097e8:	eddf 5a2f 	vldr	s11, [pc, #188]	; 80098a8 <__ieee754_powf+0x59c>
 80097ec:	eee6 5a26 	vfma.f32	s11, s12, s13
 80097f0:	eeb0 6a67 	vmov.f32	s12, s15
 80097f4:	eea5 6ae6 	vfms.f32	s12, s11, s13
 80097f8:	eef0 6a00 	vmov.f32	s13, #0	; 0x40000000  2.0
 80097fc:	ee67 5a86 	vmul.f32	s11, s15, s12
 8009800:	ee36 6a66 	vsub.f32	s12, s12, s13
 8009804:	eec5 6a86 	vdiv.f32	s13, s11, s12
 8009808:	ee36 7ac7 	vsub.f32	s14, s13, s14
 800980c:	ee77 7a67 	vsub.f32	s15, s14, s15
 8009810:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 8009814:	ee77 7a67 	vsub.f32	s15, s14, s15
 8009818:	ee17 0a90 	vmov	r0, s15
 800981c:	eb00 53c1 	add.w	r3, r0, r1, lsl #23
 8009820:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 8009824:	da21      	bge.n	800986a <__ieee754_powf+0x55e>
 8009826:	f000 f883 	bl	8009930 <scalbnf>
 800982a:	ee07 0a90 	vmov	s15, r0
 800982e:	ee67 7a88 	vmul.f32	s15, s15, s16
 8009832:	e581      	b.n	8009338 <__ieee754_powf+0x2c>
 8009834:	4a1d      	ldr	r2, [pc, #116]	; (80098ac <__ieee754_powf+0x5a0>)
 8009836:	4293      	cmp	r3, r2
 8009838:	dd07      	ble.n	800984a <__ieee754_powf+0x53e>
 800983a:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
 800983e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009842:	bf4c      	ite	mi
 8009844:	2001      	movmi	r0, #1
 8009846:	2000      	movpl	r0, #0
 8009848:	e61c      	b.n	8009484 <__ieee754_powf+0x178>
 800984a:	d108      	bne.n	800985e <__ieee754_powf+0x552>
 800984c:	ee77 7ae6 	vsub.f32	s15, s15, s13
 8009850:	eef4 7ac7 	vcmpe.f32	s15, s14
 8009854:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009858:	f6ff af76 	blt.w	8009748 <__ieee754_powf+0x43c>
 800985c:	e7ed      	b.n	800983a <__ieee754_powf+0x52e>
 800985e:	f1b3 5f7c 	cmp.w	r3, #1056964608	; 0x3f000000
 8009862:	f73f af71 	bgt.w	8009748 <__ieee754_powf+0x43c>
 8009866:	2100      	movs	r1, #0
 8009868:	e78a      	b.n	8009780 <__ieee754_powf+0x474>
 800986a:	ee07 3a90 	vmov	s15, r3
 800986e:	e7de      	b.n	800982e <__ieee754_powf+0x522>
 8009870:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8009874:	e560      	b.n	8009338 <__ieee754_powf+0x2c>
 8009876:	eddf 7a0e 	vldr	s15, [pc, #56]	; 80098b0 <__ieee754_powf+0x5a4>
 800987a:	e55d      	b.n	8009338 <__ieee754_powf+0x2c>
 800987c:	eef0 7a48 	vmov.f32	s15, s16
 8009880:	e55a      	b.n	8009338 <__ieee754_powf+0x2c>
 8009882:	2600      	movs	r6, #0
 8009884:	e587      	b.n	8009396 <__ieee754_powf+0x8a>
 8009886:	bf00      	nop
 8009888:	007fffff 	.word	0x007fffff
 800988c:	3f317218 	.word	0x3f317218
 8009890:	3f317200 	.word	0x3f317200
 8009894:	35bfbe8c 	.word	0x35bfbe8c
 8009898:	3331bb4c 	.word	0x3331bb4c
 800989c:	b5ddea0e 	.word	0xb5ddea0e
 80098a0:	388ab355 	.word	0x388ab355
 80098a4:	bb360b61 	.word	0xbb360b61
 80098a8:	3e2aaaab 	.word	0x3e2aaaab
 80098ac:	43160000 	.word	0x43160000
 80098b0:	00000000 	.word	0x00000000

080098b4 <__ieee754_sqrtf>:
 80098b4:	ee07 0a90 	vmov	s15, r0
 80098b8:	eef1 7ae7 	vsqrt.f32	s15, s15
 80098bc:	ee17 0a90 	vmov	r0, s15
 80098c0:	4770      	bx	lr

080098c2 <with_errnof>:
 80098c2:	b513      	push	{r0, r1, r4, lr}
 80098c4:	4604      	mov	r4, r0
 80098c6:	ed8d 0a01 	vstr	s0, [sp, #4]
 80098ca:	f7ff fb55 	bl	8008f78 <__errno>
 80098ce:	ed9d 0a01 	vldr	s0, [sp, #4]
 80098d2:	6004      	str	r4, [r0, #0]
 80098d4:	b002      	add	sp, #8
 80098d6:	bd10      	pop	{r4, pc}

080098d8 <xflowf>:
 80098d8:	b130      	cbz	r0, 80098e8 <xflowf+0x10>
 80098da:	eef1 7a40 	vneg.f32	s15, s0
 80098de:	ee27 0a80 	vmul.f32	s0, s15, s0
 80098e2:	2022      	movs	r0, #34	; 0x22
 80098e4:	f7ff bfed 	b.w	80098c2 <with_errnof>
 80098e8:	eef0 7a40 	vmov.f32	s15, s0
 80098ec:	e7f7      	b.n	80098de <xflowf+0x6>
	...

080098f0 <__math_uflowf>:
 80098f0:	b508      	push	{r3, lr}
 80098f2:	ed9f 0a03 	vldr	s0, [pc, #12]	; 8009900 <__math_uflowf+0x10>
 80098f6:	f7ff ffef 	bl	80098d8 <xflowf>
 80098fa:	ee10 0a10 	vmov	r0, s0
 80098fe:	bd08      	pop	{r3, pc}
 8009900:	10000000 	.word	0x10000000

08009904 <__math_oflowf>:
 8009904:	b508      	push	{r3, lr}
 8009906:	ed9f 0a03 	vldr	s0, [pc, #12]	; 8009914 <__math_oflowf+0x10>
 800990a:	f7ff ffe5 	bl	80098d8 <xflowf>
 800990e:	ee10 0a10 	vmov	r0, s0
 8009912:	bd08      	pop	{r3, pc}
 8009914:	70000000 	.word	0x70000000

08009918 <fabsf>:
 8009918:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
 800991c:	4770      	bx	lr

0800991e <finitef>:
 800991e:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
 8009922:	f1b0 4fff 	cmp.w	r0, #2139095040	; 0x7f800000
 8009926:	bfac      	ite	ge
 8009928:	2000      	movge	r0, #0
 800992a:	2001      	movlt	r0, #1
 800992c:	4770      	bx	lr
	...

08009930 <scalbnf>:
 8009930:	f030 4200 	bics.w	r2, r0, #2147483648	; 0x80000000
 8009934:	ee07 0a90 	vmov	s15, r0
 8009938:	4603      	mov	r3, r0
 800993a:	d004      	beq.n	8009946 <scalbnf+0x16>
 800993c:	f1b2 4fff 	cmp.w	r2, #2139095040	; 0x7f800000
 8009940:	d304      	bcc.n	800994c <scalbnf+0x1c>
 8009942:	ee77 7aa7 	vadd.f32	s15, s15, s15
 8009946:	ee17 0a90 	vmov	r0, s15
 800994a:	4770      	bx	lr
 800994c:	f010 4fff 	tst.w	r0, #2139095040	; 0x7f800000
 8009950:	d122      	bne.n	8009998 <scalbnf+0x68>
 8009952:	4b2b      	ldr	r3, [pc, #172]	; (8009a00 <scalbnf+0xd0>)
 8009954:	ed9f 7a2b 	vldr	s14, [pc, #172]	; 8009a04 <scalbnf+0xd4>
 8009958:	4299      	cmp	r1, r3
 800995a:	ee67 7a87 	vmul.f32	s15, s15, s14
 800995e:	db16      	blt.n	800998e <scalbnf+0x5e>
 8009960:	ee17 3a90 	vmov	r3, s15
 8009964:	f3c3 52c7 	ubfx	r2, r3, #23, #8
 8009968:	3a19      	subs	r2, #25
 800996a:	440a      	add	r2, r1
 800996c:	2afe      	cmp	r2, #254	; 0xfe
 800996e:	dd15      	ble.n	800999c <scalbnf+0x6c>
 8009970:	ee17 3a90 	vmov	r3, s15
 8009974:	ed9f 7a24 	vldr	s14, [pc, #144]	; 8009a08 <scalbnf+0xd8>
 8009978:	eddf 7a24 	vldr	s15, [pc, #144]	; 8009a0c <scalbnf+0xdc>
 800997c:	2b00      	cmp	r3, #0
 800997e:	eef0 6a47 	vmov.f32	s13, s14
 8009982:	bfb8      	it	lt
 8009984:	eeb0 7a67 	vmovlt.f32	s14, s15
 8009988:	ee67 7a26 	vmul.f32	s15, s14, s13
 800998c:	e7db      	b.n	8009946 <scalbnf+0x16>
 800998e:	ed9f 7a20 	vldr	s14, [pc, #128]	; 8009a10 <scalbnf+0xe0>
 8009992:	ee67 7a87 	vmul.f32	s15, s15, s14
 8009996:	e7d6      	b.n	8009946 <scalbnf+0x16>
 8009998:	0dd2      	lsrs	r2, r2, #23
 800999a:	e7e6      	b.n	800996a <scalbnf+0x3a>
 800999c:	2a00      	cmp	r2, #0
 800999e:	dd06      	ble.n	80099ae <scalbnf+0x7e>
 80099a0:	f023 43ff 	bic.w	r3, r3, #2139095040	; 0x7f800000
 80099a4:	ea43 53c2 	orr.w	r3, r3, r2, lsl #23
 80099a8:	ee07 3a90 	vmov	s15, r3
 80099ac:	e7cb      	b.n	8009946 <scalbnf+0x16>
 80099ae:	f112 0f16 	cmn.w	r2, #22
 80099b2:	da1a      	bge.n	80099ea <scalbnf+0xba>
 80099b4:	f24c 3350 	movw	r3, #50000	; 0xc350
 80099b8:	4299      	cmp	r1, r3
 80099ba:	ee17 3a90 	vmov	r3, s15
 80099be:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
 80099c2:	dd0a      	ble.n	80099da <scalbnf+0xaa>
 80099c4:	eddf 7a10 	vldr	s15, [pc, #64]	; 8009a08 <scalbnf+0xd8>
 80099c8:	eddf 6a10 	vldr	s13, [pc, #64]	; 8009a0c <scalbnf+0xdc>
 80099cc:	eeb0 7a67 	vmov.f32	s14, s15
 80099d0:	2b00      	cmp	r3, #0
 80099d2:	bf18      	it	ne
 80099d4:	eef0 7a66 	vmovne.f32	s15, s13
 80099d8:	e7db      	b.n	8009992 <scalbnf+0x62>
 80099da:	eddf 7a0d 	vldr	s15, [pc, #52]	; 8009a10 <scalbnf+0xe0>
 80099de:	eddf 6a0d 	vldr	s13, [pc, #52]	; 8009a14 <scalbnf+0xe4>
 80099e2:	eeb0 7a67 	vmov.f32	s14, s15
 80099e6:	2b00      	cmp	r3, #0
 80099e8:	e7f3      	b.n	80099d2 <scalbnf+0xa2>
 80099ea:	3219      	adds	r2, #25
 80099ec:	f023 43ff 	bic.w	r3, r3, #2139095040	; 0x7f800000
 80099f0:	ea43 53c2 	orr.w	r3, r3, r2, lsl #23
 80099f4:	ed9f 7a08 	vldr	s14, [pc, #32]	; 8009a18 <scalbnf+0xe8>
 80099f8:	ee07 3a90 	vmov	s15, r3
 80099fc:	e7c9      	b.n	8009992 <scalbnf+0x62>
 80099fe:	bf00      	nop
 8009a00:	ffff3cb0 	.word	0xffff3cb0
 8009a04:	4c000000 	.word	0x4c000000
 8009a08:	7149f2ca 	.word	0x7149f2ca
 8009a0c:	f149f2ca 	.word	0xf149f2ca
 8009a10:	0da24260 	.word	0x0da24260
 8009a14:	8da24260 	.word	0x8da24260
 8009a18:	33000000 	.word	0x33000000

08009a1c <_init>:
 8009a1c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8009a1e:	bf00      	nop
 8009a20:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8009a22:	bc08      	pop	{r3}
 8009a24:	469e      	mov	lr, r3
 8009a26:	4770      	bx	lr

08009a28 <_fini>:
 8009a28:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8009a2a:	bf00      	nop
 8009a2c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8009a2e:	bc08      	pop	{r3}
 8009a30:	469e      	mov	lr, r3
 8009a32:	4770      	bx	lr
